<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「CF1006F」Xor-Paths Meet-in-the-middle]]></title>
    <url>%2F2018%2F07%2F21%2F%E3%80%8CCF1006F%E3%80%8DXor-Paths-Meet-in-the-middle%2F</url>
    <content type="text"><![CDATA[(第一份屯题计划?) Links there:CF1006F 题意给定一个$n \times m$的矩阵,从起点$(1,1)$起步到$(n,m)$,每次只能向下或者向右走. 求所有满足路径上的异或和为 $k$ 的路径条数. $ n,m \leq 20 ,\space k\leq 1e18$ 思路采用中间相遇的方法.显然每次从$(1,1)$ 到 $(n,m)$ 需要走$(n+m-2)$步.前一半暴力大法师.后一半直接判断是否可以异或到$k$即可.$k$很大的话不如开个$map$. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 25;map&lt;int,int&gt;cnt[MAXN][MAXN];int a[MAXN][MAXN],ans=0,n,m,k,h;inline void dfs(int x,int y,int val,int step)&#123; if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) return ; int cur = val ^ a[x][y]; if (x+y == h+2) &#123; ++cnt[x][y][cur]; return ; &#125; dfs(x+1,y,cur,step+1); dfs(x,y+1,cur,step+1);&#125;inline void dfs2(int x,int y,int val,int step)&#123; if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) return ; int cur = val ^ a[x][y]; if (x+y == h+2) &#123; if (cnt[x][y][val^k]) ans += cnt[x][y][val^k]; return ; &#125; dfs2(x-1,y,cur,step+1); dfs2(x,y-1,cur,step+1);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),m=read(),k=read(); h=(n+m-2)&gt;&gt;1; rep(i,1,n) rep(j,1,m) a[i][j]=read(); dfs(1,1,0,0); dfs2(n,m,0,0); printf("%lld\n",ans); return 0;&#125;/* Examples: *//*3 3 112 1 57 10 012 6 4*//*3*/]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「屯题计划」Codeforces 泛做]]></title>
    <url>%2F2018%2F07%2F21%2F%E3%80%8C%E5%B1%AF%E9%A2%98%E8%AE%A1%E5%88%92%E3%80%8DCodeforces-%E6%B3%9B%E5%81%9A%2F</url>
    <content type="text"><![CDATA[也算是个脑子康复训练吧。 蒟蒻不做题提前退役。蒟蒻不撕烤智熵何来？蒟蒻不反省天天被D。 Codeforces: 1 / 50]]></content>
      <categories>
        <category>屯题计划</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ5028」小Z的加油店 差分 线段树单点修改区间求gcd]]></title>
    <url>%2F2018%2F07%2F21%2F%E3%80%8CBZOJ5028%E3%80%8D%E5%B0%8FZ%E7%9A%84%E5%8A%A0%E6%B2%B9%E5%BA%97-%E5%B7%AE%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%B1%82gcd%2F</url>
    <content type="text"><![CDATA[Links there:BZOJ5028 题意参见传送门(懒得写了) 思路考试时的我:”md怎么搞啊 应该是求个区间gcd吧 那这样的话加标记对求gcd有影响怎么算啊 不会不是线段树这个东西吧 会不会是分块啊 难道还有其他姿势吗…” 诶 那么差分一下不久完事了!多开个线段树或者树状数组记录原序列就好了啊! Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long long#define lowbit(x) (x&amp;-x)inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1const int N = 1e5+100;int n,m,B[N],ans[4*N],C[4*N];inline void add(int p,int v)&#123;for(int i = p;i &lt; N;i += lowbit(i)) C[i] += v;&#125;inline int sum(int p)&#123;int ret = 0;for(int i = p;i;i -= lowbit(i)) ret += C[i];return ret;&#125;inline int _gcd(int a,int b)&#123;a=abs(a);b=abs(b);return __gcd(a,b);&#125;inline void build(int o,int l,int r)&#123; if(l == r)&#123;ans[o] = B[l] - B[l - 1];return;&#125; int mid = (l + r) &gt;&gt; 1; build(lc,l,mid);build(rc,mid + 1,r); ans[o] = _gcd(ans[lc],ans[rc]);&#125;inline void modify(int o,int l,int r,int p,int v)&#123; if(l == r)&#123;ans[o] += v;return;&#125; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) modify(lc,l,mid,p,v); else modify(rc,mid + 1,r,p,v); ans[o] = _gcd(ans[lc],ans[rc]);&#125;inline int query(int o,int l,int r,int L,int R)&#123; if(l == L &amp;&amp; r == R) return ans[o]; int mid = (l + r) &gt;&gt; 1; if(R &lt;= mid) return query(lc,l,mid,L,R); if(L &gt; mid) return query(rc,mid + 1,r,L,R); return _gcd(query(lc,l,mid,L,mid),query(rc,mid + 1,r,mid + 1,R));&#125;signed main(signed argc, char *argv[])&#123; // freopen("bucket.in","r",stdin); // freopen("bucket.out","w",stdout); n = read(),m = read(); MM(B,0);MM(C,0); for(int i = 1;i &lt;= n;i++)&#123; B[i] = read(); add(i,B[i]); add(i + 1,-B[i]); &#125; build(1,1,n); while(m--)&#123; int opt = read(),l = read(),r = read(),v; if(opt == 1)&#123; v = read(); modify(1,1,n,l,v); if(r &lt; n) modify(1,1,n,r + 1,-v); add(l,v); add(r + 1,-v); &#125; else&#123; if(l == r)&#123; printf("%lld\n",sum(l)); continue; &#125; printf("%lld\n",_gcd(query(1,1,n,l + 1,r),sum(r))); &#125; &#125; // fclose(stdin); fclose(stdout); return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU1290」(加强) 数学 递推]]></title>
    <url>%2F2018%2F07%2F21%2FHDU1290-%E5%8A%A0%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[Links there:HDU1290(弱化版) 题意给一个球,把球切 $N$ 刀(允许各个方向但是必须直线切),问最多可以分成多少块(对$1e9+7$取模). 加强,$N \leq 1,000,000,000$ 思路令$f(n)$表示答案,既最多可以分成的块数,$d(n)$表示二维平面内 $N$ 条直线分成的块数 考虑$f(n)$与$f(n-1)$的关系,相当于在$f(n-1)$的基础上再在一个平面内多分出$d(n-1)$块 所以有$f(n)=f(n-1)+d(n-1)$ $d(n-1) = 1+\frac{(n-1)\times n}{2}$ (这个应该小学奥数就教过吧..找一下规律就行了) 所以$f(n) = f(1) + \sum_{i=1}^{n-1}d(i)$ 明显$f(1)=2$ $f(n)=2+(n-1)+\sum{i=2}^{n}\frac{n^2}{2}-\sum{i=2}^{n}\frac{n}{2}$ 诶我们似乎发现把后面两个$\sum$中$i$下标从1开始对答案没有影响而且似乎更优美了! $\therefore f(n) = n+1+\frac{n\times (n+1) \times (2n+1)}{12}+\frac{(1+n)\times n}{4}$ 于是求一下逆元啊什么的就解决了啊 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int Mod = 1e9+7;///------------------head------------------signed main(signed argc,char *argv[])&#123; freopen("melon.in","r",stdin); freopen("melon.out","w",stdout); rep(i,1,5) &#123; int n=read(); int ans=(1+n+(getinv(12,Mod) * n % Mod * (n+1) % Mod * (2*n+1) % Mod) - (getinv(4,Mod) * n % Mod * (n+1) % Mod) + Mod) % Mod; printf("%lld\n",ans); &#125; fclose(stdin); fclose(stdout); return 0;&#125;/* Examples: *//**//**/]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2018」屠龙勇士 CRT,EXCRT]]></title>
    <url>%2F2018%2F07%2F21%2FNOI2018-%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB-CRT-EXCRT%2F</url>
    <content type="text"><![CDATA[一道细节毒瘤的签到题 题意小D 最近在网上发现了一款小游戏。游戏的规则如下： 游戏的目标是按照编号$1 - n$ 顺序杀掉 $n$ 条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 $p_i$ ,直至生命值非负。只有在攻击结束后且当生命值恰好为 $0$ 时它才会死去。 游戏开始时玩家拥有 $m$ 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。 小D觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格，于是小D决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则： 每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择攻击力最低的一把剑作为武器。 机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的$x$次，使巨龙的生命值减少 $x \times ATK$ 。 之后，巨龙会不断使用恢复能力，每次恢复pi 生命值。若在使用恢复能力前或 某一次恢复后其生命值为0 ，则巨龙死亡，玩家通过本关。 那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数x设置为多少，才能用最少的攻击次数通关游戏吗？ 当然如果无论设置成多少都无法通关游戏，输出$-1$即可。 思路不难发现 每次使用的剑都是可以确定的 用priority_queue或者map或者set或者脑残地手写一个平衡树都可以在$logn$的时间内得到. 所以用$O(nlogn)$的时间得到所有的$swd_i,p_i,a_i$ 我们的任务是解对于所有模方程组成立的 $x$. swd_i\times x \space -a_i \equiv0 \pmod {p_i} x \equiv a_i * inv(swd_i) \pmod {p_i}似乎用一个EXCRT就好了,因为不保证$p_i$是质数,要用ex_gcd求逆元,特判负数情况. 如果用乘起来的CRT秒秒钟爆炸long long哦 用合并式的EXCRT似乎更加资瓷哦 中间爆long long导致我同步赛就只有25分了….炒鸡难受… Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 2e5+100;///------------------head------------------int a[MAXN],p[MAXN],swd[MAXN],tag[MAXN],cur=1,cc;int Remain[MAXN];inline int MulMod(int a,int b,int m)&#123; int t = a * b - (int)((long double) a * b /m) *m; return t%m+(t&gt;&gt;63&amp;m);&#125;struct Node&#123; int pri,atk; bool operator &lt; (const Node &amp;b) const &#123; if (pri &lt; cur &amp;&amp; b.pri &lt; cur)&#123; if(atk &lt;= cc &amp;&amp; b.atk &lt;= cc) return atk &lt; b.atk; else return atk &gt; b.atk; &#125; else return pri &lt; b.pri; &#125; Node(int xx=0,int yy=0):pri(xx),atk(yy)&#123;&#125;&#125;b[MAXN];priority_queue&lt;Node&gt;pq;int n,m;void Pref()&#123; while(!pq.empty()) pq.pop(); cur=1; cc=0;&#125;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123;if(!b)&#123;x=1;y=0;return a;&#125;int k=exgcd(b,a%b,y,x);y-=x*(a/b); return k;&#125;inline int exgcd_inv(int a,int b)&#123; //calc inv(a) in mod b int x,y,ans; if (exgcd(a,b,x,y) == 1) ans = (x%b+b) % b; else ans = -1; return ans;&#125;inline bool merge(int a1, int m1, int a2, int m2, int &amp;a3, int &amp;m3) &#123; int d = __gcd(m1, m2); int c = a2 - a1; if(c % d) return false; c = (c % m2 + m2) % m2; m1 /= d;m2 /= d;c /= d; c = MulMod(c,exgcd_inv(m1, m2),m2); c *= m1 * d; c += a1; m3 = m1 * m2 * d; a3 = (c % m3 + m3) % m3; return true;&#125;int CRT(int a[], int m[], int n) &#123; int a1 = a[1]; int m1 = m[1]; for(int i=2; i&lt;=n; i++) &#123; int a2 = a[i]; int m2 = m[i]; int m3, a3; if(!merge(a1, m1, a2, m2, a3, m3)) return -1; a1 = a3; m1 = m3; &#125; return (a1 % m1 + m1) % m1;&#125;signed main(signed argc, char *argv[])&#123; freopen("dragon.in","r",stdin); freopen("dragon.out","w",stdout); int T=read(); while(T--)&#123; int flg=0,minans=0; Pref(); n=read(); m=read(); rep(i,1,n) a[i]=read();rep(i,1,n) p[i]=read(); rep(i,1,n) b[i]=Node(i,read());rep(i,1,m) b[n+i] = Node(0,read()); rep(i,1,m) pq.push(b[n+i]); rep(i,1,n)&#123; cur=i; cc=a[cur]; Node t=pq.top(); swd[i]=t.atk; pq.pop(); pq.push(b[i]); minans = max(minans,((a[i]+swd[i]-1)/swd[i])); &#125; rep(i,1,n) &#123; int iv = exgcd_inv(swd[i],p[i]); if (iv == -1) &#123;flg = 1; break;&#125; Remain[i] = MulMod(iv,a[i],p[i]); //iv * a[i] % p[i]; &#125; if (flg) &#123;puts("-1"); continue;&#125; int ans = CRT(Remain,p,n); if (ans == -1) puts("-1"); else printf("%lld\n",max(ans,minans)); &#125; fclose(stdin); fclose(stdout); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「PKUSC2018」神仙的游戏 NTT 生成函数 字符串]]></title>
    <url>%2F2018%2F07%2F19%2F%E3%80%8CPKUSC2018%E3%80%8D%E7%A5%9E%E4%BB%99%E7%9A%84%E6%B8%B8%E6%88%8F-NTT-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Links there:PKUSC2018-神仙的游戏 先向考场只做了18分的我凭吊. 上次考完听说这是个多翔式的题,但似乎一直忘了去思考为什么…所以就当补上了吧. 题意给出一个由 $0$ , $1$ , $?$ 构成的串 $s$ .问号可以换成 $0,1$,现在定义$f(len)$ 表示 $s$ 中长度为 $len$ 的前缀是否能够成为$border$,如果是则值为$1$,否则为$0$. 求异或和 (f(1) ×1^2 ) xor(f(2)×2^2)xor··\space xor(f(n) ×n^2) 思路寻找所谓的$border$的性质,如果对于一个长度为$len$的border存在,当且仅当 $\forall i∈[1,n−len]$ 有 $s[i] = s[n-len+1]$ 等价于在Mod $n-len$的意义下分组,每一组的所有01必须相同。 那么对于每一对01来说对于任意的$x,x|(pos_0 - pos_1)$都不可行. 考虑求出所有的$(pos_0 - pos_1)$然后暴力枚举他的倍数就行啦,复杂度是$O(n lnn)$ 考虑构造这样两个生成函数 $f1(x)=\sum{i=0}^{n}[s_i== 0] x^i$ $f2(x)=\sum{i=0}^n[s_{n-i}==1]x^i$ 构造卷积$f_1 * f_2 = f_3$ 在$f_3$中发现$pos_0-pos_1$对应的就是$pos_0-pos_1+n$ $NTT$优化后在$f_3$中统计答案就行啦.复杂度是$O(nlogn)$,这也是总复杂度. 果然是神仙的游戏! Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 2e6+100;const int Mod = 998244353;int A[MAXN],B[MAXN],Rev[MAXN],N,l=0,w = 3;char s[MAXN];///------------------head------------------void NTT(int *a,int op)&#123; for(int i=0;i&lt;N;i++) if(i&lt;Rev[i]) swap(a[i],a[Rev[i]]); for(int i=1;i&lt;N;i&lt;&lt;=1) &#123; int wn = quickpow(w,op==1?(Mod-1)/(2*i):Mod-1-(Mod-1)/(2*i),Mod),t,w; for(int j=0;j&lt;N;j+=i&lt;&lt;1) &#123; w=1; for(int k=0;k&lt;i;k++) &#123; t=w*a[i+j+k]%Mod; w=w*wn%Mod; a[i+j+k]=(a[j+k]-t+Mod)%Mod; a[j+k]=(a[j+k]+t)%Mod; &#125; &#125; &#125; if(~op) for(int i=0,inv=getinv(N,Mod);i&lt;N;i++) a[i]=a[i]*inv%Mod;&#125;int ans = 0;signed main(signed argc, char *argv[])&#123; scanf("%s",s); int Len = strlen(s); for (N=1;N&lt;Len+Len;N&lt;&lt;=1) ++l; for (int i=0;i&lt;N;++i) Rev[i] = (Rev[i&gt;&gt;1] &gt;&gt; 1) | ((i&amp;1)&lt;&lt;(l-1)); for (int i=0;i&lt;Len;++i) A[i] = s[i] == '0',B[i] = s[Len-i-1] == '1'; NTT(A,1); NTT(B,1); for (int i=0;i&lt;N;i++) A[i]=A[i]*B[i]%Mod; NTT(A,-1); ans = Len * Len; for (int i = 1; i &lt; Len; i++)&#123; ans ^= (Len-i) * (Len - i); for (int j = i; j &lt; Len; j += i) if (A[Len-1+j] || A[Len-1-j]) &#123;ans ^= (Len - i) * (Len - i); break;&#125; &#125; printf("%lld\n",ans); return 0;&#125;/* Examples: *//*1?0?*//*17*/]]></content>
      <categories>
        <category>FFT/NTT</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2011」道路修建 树形dp]]></title>
    <url>%2F2018%2F07%2F16%2F%E3%80%8CNOI2011%E3%80%8D%E9%81%93%E8%B7%AF%E4%BF%AE%E5%BB%BA-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[Links there:NOI2011道路修建 题意给出一个树,定义每条边的建造费用为边两侧点的差的绝对值于边权$w_i$的乘积,求出总的建造费用. (诶是不是太简洁了) 思路直接树形dp就行啦.似乎没什么可以思考的地方呢… Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 1e6+100;int sz[MAXN],n,vis[MAXN];struct Edges&#123; int to,w,nxt;&#125;E[MAXN&lt;&lt;1];int head[MAXN],cnt=0,ans=0;inline void addedge(int u,int v,int w)&#123; E[++cnt].nxt = head[u];E[cnt].to = v;E[cnt].w = w;head[u] = cnt; E[++cnt].nxt = head[v];E[cnt].to = u;E[cnt].w = w;head[v] = cnt;&#125;void dfs(int cur)&#123; sz[cur] = 1; for (int i = head[cur]; i; i = E[i].nxt) &#123; int v = E[i].to,w = E[i].w; if (!vis[v]) &#123; vis[v] = 1; dfs(v); sz[cur] += sz[v]; ans += w * abs(n-(sz[v]) - sz[v]); &#125; &#125;&#125;signed main(signed argc, char *argv[])&#123; n=read(); MM(head,0); MM(vis,0); rep(i,1,n-1) &#123;int u=read(),v=read(),w=read(); addedge(u,v,w);&#125; vis[1]=1; dfs(1); printf("%lld\n",ans); return 0;&#125;/* Examples: *//*61 2 11 3 11 4 26 3 15 2 1*//*20*/]]></content>
      <categories>
        <category>DP-树形DP</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HEOI2015」兔子与樱花 贪心+树形dp]]></title>
    <url>%2F2018%2F07%2F16%2F%E3%80%8CHEOI2015%E3%80%8D%E5%85%94%E5%AD%90%E4%B8%8E%E6%A8%B1%E8%8A%B1-%E8%B4%AA%E5%BF%83-%E6%A0%91%E5%BD%A2dp%E2%80%98%2F</url>
    <content type="text"><![CDATA[Links there:HEOI2015 兔子与樱花 题意给出一个有根树,每个节点有一个权值(樱花个数) $c_i$ ,给出定值 $m$ ,定义删除节点操作. 当一个节点被去掉之后,这个节点上的樱花和它的儿子节点都被连到删掉节点的父节点上.如果父节点也被删除,那么就会继续向上连接,直到第一个没有被删除的节点为止。 对于每一个节点 $i​$ ,它的儿子节点的个数和 $i​$ 节点上樱花个数之和不能超过 $m​$ ,$son_i + c_i \leq m​$. 求最多删去节点的个数. 思路（感觉整天傻逼题写半天好颓废啊） 可以把树上每个点的权值看为$c_i + son_i$ 每次先统计子树信息,对子树贪心从权值小的开始选并删除,直到无法使得$son_i + c_i \leq m$为止. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 2e6+10;vector&lt;int&gt;lt[MAXN];int n,m,a[MAXN],fa[MAXN],vis[MAXN],ans;///------------------head------------------inline bool cmp(const int &amp;x,const int &amp;y)&#123; return a[x] &lt; a[y];&#125;void dfs(int u)&#123; for (int i = 0; i &lt; (int)(lt[u].size()); i++) dfs(lt[u][i]); a[u] += lt[u].size(); sort(lt[u].begin(),lt[u].end(),cmp); for (int i = 0,v; i &lt; (int)(lt[u].size()); i++) &#123; v = lt[u][i]; if (a[u] + a[v] &lt;= m+1) ++ans,a[u] += a[v] - 1; else break; &#125;&#125;signed main(signed argc, char *argv[])&#123; n=read(),m=read(); rep(i,0,n-1) a[i]=read(); rep(i,0,n-1) &#123; int k=read(); while(k--)&#123; int v=read(); fa[v]=i; lt[i].pb(v); &#125; &#125; dfs(0); printf("%lld\n",ans); return 0;&#125;/* Examples: *//*10 40 2 2 2 4 1 0 4 1 13 6 2 31 91 81 1002 7 401 50*//*4*/]]></content>
      <categories>
        <category>DP-树形DP</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SHOI2017」分手是祝愿 差分,期望dp]]></title>
    <url>%2F2018%2F07%2F15%2F%E3%80%8CSHOI2017%E3%80%8D%E5%88%86%E6%89%8B%E6%98%AF%E7%A5%9D%E6%84%BF-%E5%B7%AE%E5%88%86-%E6%9C%9F%E6%9C%9Bdp%2F</url>
    <content type="text"><![CDATA[Links there:LOJ-2145/SHOI2017 题意B 君在玩一个游戏,这个游戏由 $N$ 个灯和 $N$个开关组成，给定这 $N$ 个灯的初始状态.下标为从 $1$ 到 $N$ 的正整数。 每个灯有两个状态亮和灭，我们用 $1$ 来表示这个灯是亮的，用 $0$ 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。 但是当操作第 $i$ 个开关时，所有编号为 $i$ 的约数（包括 $1$ 和 $i$）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。 B 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。 这个策略需要的操作次数很多，B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 $k$ 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 $k$ 步）操作这些开关。 B 君想知道按照这个策略（也就是先随机操作，最后 小于等于 $k​$ 步，使用操作次数最小的操作方法）的操作次数的期望。 这个期望可能很大，但是 B 君发现这个期望乘以 $N$ 的阶乘一定是整数，所以他只需要知道这个整数对 $100003$ 取模之后的结果。 思路bike的题就是简洁干净. 考虑$N=K$的情况,发现只要贪心从大到小取就行啦,所以50分是送的!? 令$f(i)$表示还有$i$步达成目标的期望步数. f(i)=\frac{i}{n}f(i-1)+(1-\frac{i}{n})f(i+1) \\\\ f(i+1)=\frac{i+1}{n}f(i)+(1-\frac{i+1}{n})f(i+2)\\\\ ...但是这样并不好计算啊!在算$f(i)$的时候并不能保证都知道$f(i-1),f(i+1)$ 考虑差分.差分$g$的意义就是从第$i$步到第$i-1$步的期望. g(i)=\frac{i}{n}+\frac{n-i}{n}(1+g(i+1)+g(i))\\\\ g(i)=\frac{i}{n}+\frac{n-i}{n}g(i)+\frac{n-i}{n}(1+g(i+1))\\\\ \frac{i}{n}g(i)=\frac{i}{n}+\frac{n-i}{n}(1+g(i+1))\\\\ g(i)=1+\frac{n-i}{i}(i+g(i+1))最终把$g(i)$加起来就是答案啦 CODE123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+100;const int Mod = 1e5+3;int g[MAXN],n,k,lt[MAXN];inline int calc(void)&#123; int ret = 0; for (int i = n; i; i--)&#123; if (lt[i]) &#123; int tt = sqrt(i+0.5); ++ret; for (int j = 1; j &lt;= tt; ++j) if(!(i%j))&#123; lt[j] ^= 1; if (i != j * j) lt[i/j] ^= 1; &#125; &#125; &#125; return ret;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),k=read(); int fac = 1,ans = 0; rep(i,1,n) fac = fac * i % Mod; rep(i,1,n) lt[i]=read(); int t = calc(); if (t &lt;= k) return printf("%lld\n", t * fac % Mod),0; rep(i,1,k) g[i] = 1; g[n] = 1; per(i,n-1,k+1) g[i] = (1 + (g[i+1] + 1) * (n - i) % Mod * getinv(i,Mod) % Mod) % Mod; rep(i,1,t) &#123;ans += g[i]; if (ans &gt;= Mod) ans -= Mod;&#125; ans = ans * fac % Mod; printf("%lld\n",ans); return 0;&#125;/* Examples: *//*4 00 0 1 1*//*512*/]]></content>
      <categories>
        <category>DP-期望DP</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[课件/个人总结[-RESERVED-]]]></title>
    <url>%2F2018%2F07%2F11%2F%E8%AF%BE%E4%BB%B6-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-RESERVED%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/IIFoAplhClTHKQFPXPgLkLDCTp7UusYLldxBkE06Jd4+ga4JLecxE1OO7eJmdXIBpOXSiYdxy4sHBme0S50CBfkRUQC5WmpwvuvAK5NIqsx3p2yfeTMkj var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU2089」不要62 数位dp]]></title>
    <url>%2F2018%2F07%2F10%2F%E3%80%8CHDU2089%E3%80%8D%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%2F</url>
    <content type="text"><![CDATA[Links there:HDU-2089-不要62 题意身为杭州人看到这个题意笑出了声. 求规定区间内数字中满足不含62连号、不含4的数字. 思路和windy数差不多的 反正都是一个套路. 预处理之后再统计即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int f[14][14];int a[14],cnt=0;///------------------head------------------inline void init(void)&#123; rep(i,0,9) f[1][i] = 1; f[1][4] = 0; rep(i,2,13) rep(j,0,9) &#123; if (j == 4) continue; rep(k,0,9) &#123; if ((k == 2 &amp;&amp; j == 6)) continue; f[i][j] += f[i-1][k]; &#125; &#125;&#125;inline int calc(int x)&#123; int ret = 0; cnt = 0; while(x)&#123;a[++cnt]=x%10;x/=10;&#125; rep(i,1,cnt-1) rep(j,1,9) ret += f[i][j]; rep(j,1,a[cnt]-1) ret += f[cnt][j]; per(i,cnt-1,1) &#123; rep(j,0,a[i]-1) if (j != 4 &amp;&amp; a[i+1] != 4) ret += f[i][j] * (!(a[i+1] == 6 &amp;&amp; j == 2)); if ((a[i+1] == 6 &amp;&amp; a[i] == 2) || a[i+1] == 4 || a[i] == 4) break; if (i==1) ++ret; &#125; return ret;&#125;signed main(signed argc, char *argv[])&#123; init(); int a,b; while(scanf("%lld %lld",&amp;a,&amp;b) == 2 &amp;&amp; (a+b)) printf("%lld\n",calc(b)-calc(a-1)+((!a)||(!b))); return 0;&#125;]]></content>
      <categories>
        <category>DP-数位DP</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1026/SCOI2009」windy数 数位dp]]></title>
    <url>%2F2018%2F07%2F10%2F%E3%80%8CBZOJ1026%E3%80%8Dwindy%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%2F</url>
    <content type="text"><![CDATA[Links there:BZOJ1026-windy数 题意定义不含前导零且相邻两个数字之差至少为2的正整数被称为windy数.给出$A,B$,求在$A,B$之间windy数的个数. 思路(别问我为什么这么晚才来补题) 令$f[i][j]$表示当前数字有$i$位,最高位取到$j$以下的满足条件的windy数. 很明显有转移$f[i][j] = \sum f[i-1][k] * (|k - j|&gt;=2)$ 预处理出$f[i][j]$后来迭代或者递归计算$x$以内的答案即可 注意细节讨论. 在计算$calc(x)$的时候,先处理$x$的位数和各数位的值. 令位数为$cnt$,当$i&lt;=n-1$的时候直接统计. $j = 最高位-1$ 独立计算一次 rep(j,1,a[cnt]-1) ret+=f[cnt][j]; 对于剩余的位数$ret += f[i][j],cnt-1\geq i \geq 1 ,0 \leq j \leq a[i] - 1$. 然后要保证$|a[i]-a[i+1] |&gt;= 2$,否则直接退出. 差不多就这样了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int a[15],cnt=0,f[15][15];///------------------head------------------inline void init(void)&#123; rep(i,0,9) f[1][i]=1; rep(i,2,13) rep(j,0,9) rep(k,0,9) if (abs(k-j)&gt;=2) f[i][j] += f[i-1][k];&#125;inline int calc(int x)&#123; cnt=0; int ret=0; while(x)&#123;a[++cnt]=x%10;x/=10;&#125; rep(i,1,cnt-1) rep(j,1,9) ret+=f[i][j]; rep(j,1,a[cnt]-1) ret+=f[cnt][j]; per(i,cnt-1,1)&#123; rep(j,0,a[i]-1) ret+=f[i][j]*(abs(a[i+1]-j)&gt;=2); if (abs(a[i]-a[i+1])&lt;2) break; if (i==1) ++ret; &#125; return ret;&#125;signed main(signed argc, char *argv[])&#123; init(); int a=read(),b=read(); printf("%lld\n",calc(b)-calc(a-1)); return 0;&#125;]]></content>
      <categories>
        <category>DP-数位DP</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2007」仓库建设 -斜率优化dp]]></title>
    <url>%2F2018%2F07%2F10%2F%E3%80%8CZJOI2007%E3%80%8D%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[Links there:ZJOI2007-仓库建设 题意凑字数我来copy一波$L$公司有$N$个工厂，由高到底分布在一座山上。如图所示，工厂$1$在山顶，工厂$N$在山脚。由于这座山处于高原内陆地区（干燥少雨），$L$公司一般把产品直接堆放在露天，以节省费用。突然有一天，$L$公司的总裁$L$先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是$L$先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第$i$个工厂目前已有成品$P_i$件，在第$i$个工厂位置建立仓库的费用$C_i$。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于$L$公司产品的对外销售处设置在山脚的工厂$N$，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送$1$个单位距离的费用是$1$。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：$1$：工厂$i$距离工厂$1$的距离$Xi$（其中X1=0）;$2$：工厂$i$目前已有成品数量$P_i$;$3$：在工厂$i$建立仓库的费用$C_i$;请你帮助$L$公司寻找一个仓库建设的方案，使得总的费用（建造费用+运输费用）最小。 思路斜率题做多了真的就几步推出斜率公式维护凸包就好了 代码还短… $O(n^3)$的转移还是非常显然的.展开后通过维护前缀和可以优化成$O(n^2)$ f[i] = max\{(f[j]+x[i]*(sump[i]-sump[j])-(sumpx[i]-sumpx[j]))\} + c[i]这是一个十分十分显然的斜率优化的形式. 老套路 假设有$x&lt;y$, $x$的转移比$y$更优. 那么有 \frac{(f[x]+sumpx[x])-(f[y]+sumpx[y])}{(sump[x]-sump[y])} < x[i]对这个式子维护一个凸包即可.我代码里还是用double来判断斜率的。 其实改用分母分子分别相乘判大小的写法更严谨。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e6+100;int n,x[MAXN],c[MAXN],p[MAXN],f[MAXN];int K[MAXN],l,r;int sump[MAXN],sumpx[MAXN];///------------------head------------------inline double calc(int x,int y)&#123;return 1.0*((f[x]+sumpx[x])-(f[y]+sumpx[y]))/(sump[x]-sump[y]);&#125;signed main(signed argc, char *argv[])&#123; n=read(); rep(i,1,n) x[i]=read(),p[i]=read(),c[i]=read(); rep(i,1,n) sump[i] = sump[i-1] + p[i]; rep(i,1,n) sumpx[i] = sumpx[i-1] + x[i]*p[i]; // rep(i,1,n) printf("%lld %lld\n",sump[i],sumpx[i]); rep(i,1,n)&#123; while(l&lt;r &amp;&amp; calc(K[l],K[l+1]) &lt; x[i]) ++l; int j = K[l]; f[i] = f[j] + x[i] * (sump[i] - sump[j]) - (sumpx[i] - sumpx[j]) + c[i]; while(l&lt;r &amp;&amp; calc(K[r-1],K[r]) &gt; calc(K[r],i)) --r; //维护下凸包.. K[++r] = i; &#125; printf("%lld\n",f[n]); return 0;&#125;]]></content>
      <categories>
        <category>DP-斜率优化DP</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU3507」Print Article 斜率优化dp]]></title>
    <url>%2F2018%2F07%2F10%2F%E3%80%8CHDU3507%E3%80%8DPrint-Article-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[Links there:HDU-3507-PrintArticle 题意将$n$个数分成若干个区间,每个区间的代价为区间和的平方加上一个常数$m$,求最小代价. 思路考虑斜率优化,假设存在$x&lt;y$, $x$的转移比$y$优. 则有 \frac{(f[y] - f[x] + (sum[y]*sum[y]) - (sum[x]*sum[x])) }{2*(sum[x]-sum[y])} < sum[i]维护一个凸包就完事了. （完了我更新博客越来越懒了 难道这就是颓废退役的前兆？！） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 5e5+100;int sum[MAXN],a[MAXN],M,N;int f[MAXN],q[MAXN];double calc(int x,int y)&#123;return 1.0 * (f[y] - f[x] + (sum[y]*sum[y]) - (sum[x]*sum[x]))/(2*(sum[x]-sum[y]));&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; scanf("%lld %lld",&amp;N,&amp;M); &#123; MM(f,0);MM(q,0); rep(i,1,N) sum[i] = sum[i-1] + read(); int l = 0,r = 0; rep(i,1,N) &#123; while(l &lt; r &amp;&amp; calc(q[l],q[l+1]) &lt; sum[i]) ++l; int j = q[l]; f[i] = f[j] + (sum[i] - sum[j]) * (sum[i] - sum[j]) + M; while(l &lt; r &amp;&amp; calc(q[r-1],q[r]) &gt; calc(q[r],i)) --r; q[++r] = i; &#125; printf("%lld\n",f[N]); &#125; return 0;&#125;/* Examples: *//**//**/]]></content>
      <categories>
        <category>DP-斜率优化DP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「APIO2010」特别行动队-斜率优化dp]]></title>
    <url>%2F2018%2F07%2F10%2F%E3%80%8CAPIO2010%E3%80%8D%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[Links there:APIO2010-特别行动队 题意看链接去 懒得搬运 还是照例先推一个最弱的$O(n^3)$的转移. 令$f[i]$表示取到前$i$个士兵时的最大战斗力,考虑枚举$[j+1,i]$区间新成一队. f[i] = max\{f[j],calc(i,j)\},calc(i,j) = a(\sum_{k=j+1}^{i}x_i)^2+b\sum_{k=j+1}^{i}x_i+c)这样的转移可以再优化前缀和得到$O(n^2)$的转移. 考虑斜率优化. 假设存在$j &gt; k$,$j$的转移比$k$优.（这里的$x[i]$已经是前缀和啦） f[j]+Ax[j]^{2}-2Ax[i]x[j]-Bx[j] > f[k]+Ax[k]^{2}-2Ax[i]x[k]-Bx[k]移项。 2Ax[i](x[j]-x[k]) < (f[j]+Ax[j]^{2}-Bx[j])-(f[k]+Ax[k]^{2}-Bx[k])然后就可以斜率优化啦. x[i] < \frac{(f[j]+Ax[j]^{2}-Bx[j])-(f[k]+Ax[k]^{2}-Bx[k])}{2A(x[j]-x[k])}然后维护一个下凸包就可以啦. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e6+100;int sum[MAXN],a,b,c,x[MAXN],n;int f[MAXN],q[MAXN];inline int calc(int x)&#123;return x*x*a+b*x+c;&#125;inline int UP(int x,int y)&#123;return ((f[x]+a*sum[x]*sum[x]-b*sum[x])-(f[y]+a*sum[y]*sum[y]-b*sum[y]));&#125;inline int DOWN(int x,int y)&#123;return 2LL*a*(sum[x]-sum[y]);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(); a=read(),b=read(),c=read(); rep(i,1,n) sum[i] = sum[i-1] + read(); int l = 0,r = 0; rep(i,1,n)&#123; while(l &lt; r &amp;&amp; UP(q[l],q[l+1]) &lt;= sum[i] * DOWN(q[l],q[l+1])) ++l; int j = q[l]; f[i] = f[j] + calc(sum[i]-sum[j]); while(l &lt; r &amp;&amp; UP(q[r-1],q[r]) * DOWN(q[r],i) &gt;= UP(q[r],i) * DOWN(q[r-1],q[r])) --r; q[++r] = i; &#125; //rep(i,1,n) printf("%lld ",f[i]); printf("%lld\n",f[n]); return 0;&#125;]]></content>
      <categories>
        <category>DP-斜率优化DP</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Atcoder」ARC075 E - Meaningful Mean]]></title>
    <url>%2F2018%2F06%2F30%2F%E3%80%8CAtcoder%E3%80%8DARC075-E-Meaningful-Mean%2F</url>
    <content type="text"><![CDATA[h fake q安利的题. Links there:ARC075E 题意:给出一个长为$N$的序列 ,求出所有的连续序列,满足他们的算术平均数小于等于$K$. 范围:$N\leq 200000,1 \leq A_i \leq 10^9,1 \leq K \leq 10^9$ 分析:首先可以考虑简化问题,将每一个数先减去$K$,再维护一个前缀和$sum$,那么问题简化成求出所有对$(l,r)$使得$sum(r)-sum(l-1) \geq 0$.那么我们求出所有$sum$中的顺序对,也就是满足$i&lt;j,sum[i]&lt;sum[j]$的个数就行了,我们可以用树状数组来维护这个东西.注意离散化. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;#define lowbit(x) (x&amp;-x)inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 2e5 + 100;int n,k,a[MAXN],s[MAXN],ans = 0;int C[MAXN];vector&lt;int&gt;v;inline void add(int x,int d)&#123;for(int i=x;i&lt;MAXN;i+=lowbit(i)) C[i]+=d;&#125;inline int Gsum(int x)&#123;int ret = 0;for (int i=x;i&gt;=1;i-=lowbit(i)) ret += C[i]; return ret;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(); k=read(); rep(i,1,n) a[i]=read()-k,s[i]=s[i-1]+a[i]; rep(i,0,n) v.pb(s[i]); sort(v.begin(),v.end()); v.resize(unique(v.begin(),v.end())-v.begin()); rep(i,0,n) s[i]=lower_bound(v.begin(),v.end(),s[i])-v.begin()+1; rep(i,0,n)&#123; ans += Gsum(s[i]); add(s[i],1); &#125; printf("%lld\n",ans); return 0;&#125;/* Examples: *//*7 2610203040302010*//*13*/]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ6277-6285」数列分块入门傻逼题]]></title>
    <url>%2F2018%2F06%2F28%2F%E3%80%8CLOJ6277-6285%E3%80%8D%E6%95%B0%E5%88%97%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8%E5%82%BB%E9%80%BC%E9%A2%98%2F</url>
    <content type="text"><![CDATA[突然想起之前就想做的分块练习. 现在做起来真的感觉好傻逼啊. 分块暴力美学 有时候花里胡哨的数据结构出锅的时候也算是 一种补救方法吧. 分块代码不长也比较好写,根据hzwer的blog,分块时一定要想想这几个问题: 对于每次区间操作： 1.不完整的块 的$O(\sqrt{n})$个元素怎么处理? 2.$O(\sqrt{n})$个 整块 怎么处理? 3.要预处理什么信息（复杂度不能超过后面的操作）? 分块在大数据下很容易找出锅. 一般查错就分不同大小的块就好啦. 我贴完代码就跑! 分块入门1 区间加法 单点查值没错 树状数组同学今天请你坐下！ 1234567891011121314151617181920212223242526272829303132333435363738394041//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 5e4+10;int sum_B[251],ref[MAXN],a[MAXN],n,m;int refer_blk(int x)&#123;return (x-1)/m+1;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read();MM(sum_B,0); m=sqrt(n+0.5); rep(i,1,n) a[i]=read(); rep(i,1,n)&#123; int opt=read(),l=read(),r=read(),c=read(); if (opt) &#123;printf("%lld\n",a[r]+sum_B[refer_blk(r)]);continue;&#125; int L = refer_blk(l),R = refer_blk(r); if (L == R) &#123;rep(j,l,r) a[j] += c; continue;&#125; rep(j,L+1,R-1) sum_B[j] += c; rep(j,l,refer_blk(l)*m) a[j] += c; rep(j,(refer_blk(r)-1)*m+1,r) a[j] += c; &#125; return 0;&#125; 分块入门2 区间加法 求区间小于c的元素个数没错 树状数组同学您还是坐下吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 8e4+100;const int MAXM = 500;struct Blks&#123; vector&lt;int&gt;v; int add; int query(int x)&#123;int q = lower_bound(v.begin(),v.end(),x-add)-v.begin();return q;&#125;&#125;Blk[MAXM];int n,a[MAXN],m,cnt=0,p=1,D;int refer_blk(int x)&#123;return (x-1)/m+1;&#125;void Reset(int x)&#123; Blk[x].v.clear(); rep(i,(x-1)*m+1,x*m) Blk[x].v.pb(a[i]); sort(Blk[x].v.begin(),Blk[x].v.end());&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read();D=n; m=sqrt(n); rep(i,1,n) &#123;a[i]=read();Blk[refer_blk(i)].v.push_back(a[i]);&#125; rep(i,1,m) sort(Blk[i].v.begin(),Blk[i].v.end()); //rep(k,1,n) &#123;for (auto it : Blk[k].v) printf("%lld ",it); puts("");&#125; rep(ss,1,D)&#123; //printf("%lld\n",o); //rep(k,1,n) &#123;for (auto it : Blk[k].v) printf("%lld ",it); puts("");&#125; int opt,l,r,c; opt=read(),l=read(),r=read(),c=read(); int L = refer_blk(l),R = refer_blk(r); if (opt) &#123; int ret = 0; rep(i,l,min(m*L,r)) ret += (Blk[L].add + a[i] &lt; c * c); if (L != R) rep(i,(R-1)*m+1,r) ret += (Blk[R].add + a[i] &lt; c * c); rep(i,L+1,R-1) ret += Blk[i].query(c*c); // cerr &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; c &lt;&lt; endl; printf("%lld\n",ret); &#125; else &#123; rep(i,l,min(m*L,r)) a[i] += c; Reset(L); if (L != R) &#123;rep(i,(R-1)*m+1,r) a[i] += c;Reset(R);&#125; rep(i,L+1,R-1) Blk[i].add += c; &#125; &#125; return 0;&#125; 分块入门3 区间加法 查找前驱1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+10;const int MAXM = 500+50;//----------head----------int n,M;int v[MAXN],BL[MAXN],atag[MAXN];set&lt;int&gt;Sets[MAXM];void add(int a,int b,int c)&#123; for(int i=a;i&lt;=min(BL[a]*M,b);i++) &#123; Sets[BL[a]].erase(v[i]); v[i]+=c; Sets[BL[a]].insert(v[i]); &#125; if(BL[a]!=BL[b]) &#123; for(int i=(BL[b]-1)*M+1;i&lt;=b;i++) &#123; Sets[BL[b]].erase(v[i]); v[i]+=c; Sets[BL[b]].insert(v[i]); &#125; &#125; for(int i=BL[a]+1;i&lt;=BL[b]-1;i++) atag[i]+=c;&#125;int query(int a,int b,int c)&#123; int Ret=-1; for(int i=a;i&lt;=min(BL[a]*M,b);i++) &#123; int val=v[i]+atag[BL[a]]; if(val&lt;c)Ret=max(val,Ret); &#125; if(BL[a]!=BL[b])for(int i=(BL[b]-1)*M+1;i&lt;=b;i++)&#123;int val=v[i]+atag[BL[b]];if(val&lt;c)Ret=max(val,Ret);&#125; for(int i=BL[a]+1;i&lt;=BL[b]-1;i++)&#123;int x=c-atag[i];set&lt;int&gt;::iterator it=Sets[i].lower_bound(x);if(it==Sets[i].begin())continue;--it;Ret=max(Ret,*it+atag[i]);&#125; return Ret;&#125;signed main(signed argc, char *argv[])&#123; n=read();M=sqrt(n+0.5); for(int i=1;i&lt;=n;i++)v[i]=read(); for(int i=1;i&lt;=n;i++) &#123; BL[i]=(i-1)/M+1; Sets[BL[i]].insert(v[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; int f=read(),a=read(),b=read(),c=read(); if(f==0)add(a,b,c); if(f==1)printf("%lld\n",query(a,b,c)); &#125; return 0;&#125; 分块入门4 区间加法 区间求和其实多统计个sum信息就好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define RG register#define rep(i,a,b) for(RG int i=a;i&lt;=b;i++)#define per(i,a,b) for(RG int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline char gc()&#123; static char now[1&lt;&lt;16],*S,*T; if(S==T) &#123;T=(S=now)+fread(now,1,1&lt;&lt;16,stdin); if(S==T) return EOF;&#125; return *S++;&#125;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=gc(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=gc();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=gc();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 8e4+100;const int MAXM = 300+50;int n,m,a[MAXN],add[MAXM],sum[MAXM];inline int refer_blk(int x)&#123;return (x-1)/m+1;&#125;signed main(signed argc, char *argv[])&#123; n=read(),m=sqrt(n+0.5); rep(i,1,n) a[i]=read(),sum[refer_blk(i)] += a[i]; rep(op,1,n)&#123; int opt=read(),l=read(),r=read(),c=read(); int L = refer_blk(l),R = refer_blk(r); if(!opt)&#123; rep(i,l,min(r,L*m)) a[i] += c,sum[L] += c; if (L != R) rep(i,(R-1)*m+1,r) a[i] += c,sum[R] += c; rep(i,L+1,R-1) add[i] += c; &#125; else&#123; int ret = 0; rep(i,l,min(r,L*m)) ret += a[i] + add[L]; if (L != R) rep(i,(R-1)*m+1,r) ret += a[i] + add[R]; rep(i,L+1,R-1) ret += sum[i] + m * add[i]; printf("%lld\n",ret % (c+1)); &#125; &#125; return 0;&#125; 分块入门5 区间开方 区间求和就是利用一个数在有限次内(根据范围最多5~6次)一定可以被开方成1给整个块打标记 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 8e4+100;const int MAXM = 4e2+10;int n,m,sum[MAXM],f[MAXM],a[MAXN];inline int refer_blk(int x)&#123;return (x-1)/m+1;&#125;inline void Upd_in_blk(int x)&#123; if (f[x]) return ; f[x] = 1; sum[x] = 0; rep(i,(x-1)*m+1,x*m) &#123; a[i] = sqrt(a[i] + 0.5); sum[x] += a[i]; f[x] = a[i] &gt; 1 ? 0 : f[x]; &#125;&#125;signed main(signed argc, char *argv[])&#123; n=read(),m=sqrt(n+0.5); rep(i,1,n) a[i]=read(),sum[refer_blk(i)] += a[i]; rep(op,1,n)&#123; int opt=read(),l=read(),r=read(),c=read(); int L=refer_blk(l),R=refer_blk(r); if(!opt)&#123; rep(i,l,min(r,L*m)) sum[L] -= a[i],a[i] = sqrt(a[i] + 0.5),sum[L] += a[i]; if (L != R) rep(i,(R-1)*m+1,r) sum[R] -= a[i],a[i] = sqrt(a[i] + 0.5),sum[R] += a[i]; rep(i,L+1,R-1) Upd_in_blk(i); &#125; else&#123; int ans = 0; rep(i,l,min(r,L*m)) ans += a[i]; if(L != R) rep(i,(R-1)*m+1,r) ans += a[i]; rep(i,L+1,R-1) ans += sum[i]; printf("%lld\n",ans); &#125; &#125; return 0;&#125; 分块入门6 单点插入 单点求值可以扔链表 但是分块我们可以资瓷更多的区间操作 本来的做法是找到新元素所在的块然后暴力向右移动 但是玩意所有操作都放在同一个块怎么办？ 不难发现每次重构块是$O(n)$的 那么我们增加$\sqrt{n}$个元素就重构一次块 使得所有的块大小均衡 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 1e5+100;const int MAXM = 400+10;int n,m,a[MAXN],M;inline int refer_blk(int x)&#123;return (x-1)/M+1;&#125;vector&lt;int&gt;v[MAXM];int buc[MAXN&lt;&lt;1],head = 0;pair&lt;int,int&gt; query(int x)&#123; int xx = 1; while(x &gt; v[xx].size()) x -= v[xx].size(),++xx; return make_pair(xx,x-1);&#125;inline void Reset(void)&#123; head = 0; rep(i,1,m)&#123; for (auto j = v[i].begin(); j != v[i].end(); j++) buc[++head] = *j; v[i].clear(); &#125; int mm = sqrt(head); rep(i,1,head) v[(i-1)/mm+1].push_back(buc[i]); m=(head-1)/mm+1;&#125;void ins(int x,int d)&#123; pair&lt;int,int&gt; t = query(x); int f1 = t.fi,f2 = t.se; v[f1].insert(v[f1].begin()+f2,d); if(v[f1].size() &gt; 20 * M) Reset();&#125;//insert x to pos dsigned main(signed argc, char *argv[])&#123; // freopen("a1.in","r",stdin); // freopen("my.out","w",stdout); n=read(),M=sqrt(n+0.5); rep(i,1,n) a[i]=read(); rep(i,1,n) v[refer_blk(i)].pb(a[i]); m = (n - 1) / M + 1; rep(op,1,n)&#123; int opt = read(),l = read(),r = read(),c = read(); if (!opt) &#123;ins(l,r);&#125; else &#123;pair&lt;int,int&gt;t = query(r);int f1 = t.fi,f2 = t.se;printf("%lld\n",v[f1][f2]);&#125; &#125; return 0;&#125; 分块入门7 区间加法 区间乘法 单点询问注意优先度就行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+100;const int MAXM = 400+50;int n,m,a[MAXN],mul[MAXM],add[MAXM];///------------------head------------------const int Mod = 1e4+7;inline int refer_blk(int x)&#123;return (x-1)/m+1;&#125;inline void Reset(int x)&#123; rep(i,(x-1)*m+1,min(x*m,n)) a[i]=(a[i]*mul[x]+add[x])%Mod; add[x] = 0; mul[x] = 1;&#125;signed main(signed argc, char *argv[])&#123; n=read(),m=sqrt(n+0.5); rep(i,1,n) a[i]=read(); rep(i,1,refer_blk(n)) mul[i] = 1; rep(op,1,n)&#123; int opt=read(),l=read(),r=read(),c=read(); int L = refer_blk(l),R = refer_blk(r); if (!opt) &#123; Reset(L); rep(i,l,min(r,m*L)) a[i] += c,a[i] %= Mod; if (L != R) &#123;Reset(R); rep(i,(R-1)*m+1,r) a[i] += c,a[i] %= Mod;&#125; rep(i,L+1,R-1) &#123;add[i] += c; add[i] %= Mod;&#125; &#125; else if (opt == 1)&#123; Reset(L); rep(i,l,min(r,m*L)) a[i] *= c,a[i] %= Mod; if (L != R) &#123;Reset(R); rep(i,(R-1)*m+1,r) a[i] *= c,a[i] %= Mod;&#125; rep(i,L+1,R-1) &#123;add[i] *= c; add[i] %= Mod;mul[i] *= c;mul[i] %= Mod;&#125; &#125; else printf("%lld\n",(a[r]*mul[R]+add[R])%Mod); &#125; return 0;&#125; 分块入门8 区间修改 区间询问挺傻逼的. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+100;const int MAXM = 400+50;int n,m,a[MAXN],f[MAXM];///------------------head------------------const int Mod = 1e4+7;inline int refer_blk(int x)&#123;return (x-1)/m+1;&#125;inline void Reset(int x)&#123; if (f[x]==-1) return ; rep(i,(x-1)*m+1,min(x*m,n)) a[i]=f[x]; f[x]=-1;&#125;signed main(signed argc, char *argv[])&#123; MM(f,-1); n=read(),m=sqrt(n+0.5); rep(i,1,n) a[i]=read(); rep(op,1,n)&#123; int l=read(),r=read(),c=read(); int L = refer_blk(l),R = refer_blk(r),ans = 0; Reset(L); rep(i,l,min(L*m,r)) &#123;ans += a[i] == c; if (a[i] != c) a[i] = c;&#125; if (L != R) &#123; Reset(R); rep(i,(R-1)*m+1,r) &#123;ans += a[i] == c; if (a[i] != c) a[i] = c;&#125; &#125; rep(i,L+1,R-1)&#123; if (f[i] != -1) &#123; if (f[i] == c) ans += m; else f[i] = c; &#125; else &#123; rep(j,(i-1)*m+1,i*m)&#123;ans += a[j] == c; if(a[j] != c) a[j] = c;&#125; f[i] = c; &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125; 分块入门9 区间众数查询离线版本不难想到 但似乎可以在线资瓷带修操作？ bzoj2724了解一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 1e5+10;const int MAXM = 500+10;int n,m,id,v[MAXN],f[MAXM][MAXM];map&lt;int,int&gt;mp;int val[MAXM],cnt[MAXM];vector&lt;int&gt;ve[MAXM];inline int refer_blk(int x)&#123;return (x-1)/m+1;&#125;void pre(int x)&#123; memset(cnt,0,sizeof(cnt)); int mx=0,ans=0; for(int i=(x-1)*m+1;i&lt;=n;i++) &#123; cnt[v[i]]++; int t=refer_blk(i); if(cnt[v[i]]&gt;mx||(cnt[v[i]]==mx&amp;&amp;val[v[i]]&lt;val[ans])) ans=v[i],mx=cnt[v[i]]; f[x][t]=ans; &#125;&#125;int query(int l,int r,int x)&#123; int t=upper_bound(ve[x].begin(),ve[x].end(),r)-lower_bound(ve[x].begin(),ve[x].end(),l); return t;&#125;int query(int a,int b)&#123; int ans,mx; ans=f[refer_blk(a)+1][refer_blk(b)-1]; mx=query(a,b,ans); for(int i=a;i&lt;=min(refer_blk(a)*m,b);i++) &#123; int t=query(a,b,v[i]); if(t&gt;mx||(t==mx&amp;&amp;val[v[i]]&lt;val[ans]))ans=v[i],mx=t; &#125; if(refer_blk(a)!=refer_blk(b)) for(int i=(refer_blk(b)-1)*m+1;i&lt;=b;i++) &#123; int t=query(a,b,v[i]); if(t&gt;mx||(t==mx&amp;&amp;val[v[i]]&lt;val[ans]))ans=v[i],mx=t; &#125; return ans;&#125;signed main(signed argc, char *argv[])&#123; n=read();m=sqrt(n+0.5); rep(i,1,n)&#123;v[i]=read();if(!mp[v[i]])&#123;mp[v[i]]=++id;val[id]=v[i];&#125; v[i]=mp[v[i]];ve[v[i]].push_back(i); &#125;; rep(i,1,refer_blk(n)) pre(i); rep(i,1,n)&#123;int a=read(),b=read();if(a&gt;b)swap(a,b);printf("%lld\n",val[query(a,b)]);&#125; return 0;&#125;]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2014」魔法森林]]></title>
    <url>%2F2018%2F06%2F26%2F%E3%80%8CNOI2014%E3%80%8D%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[NOI2014-魔法森林 Links there:NOI2014MogicForest 题意:给出一个无向图,每一条边有两个权值$A_i,B_i$ 要求从$1$节点跑到$n$节点的可能路径上,求出最小的$A_i+B_i$ 思路: 首先对边进行排序,很显然的针对某个变量($A$或者$B$)关键字排序. 然后用$LCT$动态维护一个MST.每次找边的时候,如果两个点已经连结,那么在该换上找到最大值并换成次大值,特别的,如果1,n联通,则说明有路径存在,我们更新答案.这样就做到了动态维护. 上述为正常$LCT$做法. 但是听大爷们讲这题可以用$SPFA$的$O(玄学)$复杂度水掉. 个人感觉其实如果数据出的比较强的话可以卡掉$SPFA$的,但是估计出题人也没想到那么多吧… （md调了半天一个pushup写错了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define lc ch[u][0]#define rc ch[u][1]const int INF = 0x3f3f3f3f;const int MAXN = 5e4+10;const int MAXM = 1e5+10;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv( int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int n,m,F[MAXN&lt;&lt;1];int getf(int x)&#123;return x==F[x]?x:F[x]=getf(F[x]);&#125;struct Edges&#123; int u,v,A,B; inline bool operator &lt; (const Edges &amp;b) const &#123; return (A==b.A)?(B&lt;b.B):A&lt;b.A; &#125; inline void Rd(void)&#123;u=read(),v=read(),A=read(),B=read();&#125;&#125;E[MAXM&lt;&lt;1];struct LinkCutTree&#123; int ch[MAXN&lt;&lt;2][2],fa[MAXN&lt;&lt;2],rev[MAXN&lt;&lt;2],sum[MAXN&lt;&lt;2],mx[MAXN&lt;&lt;2],w[MAXN&lt;&lt;2]; inline bool isRson(int u)&#123;return ch[fa[u]][1] == u;&#125; inline bool isRoot(int u)&#123;return (ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u);&#125; inline void Reverse(int u)&#123;rev[u] ^= 1;swap(lc,rc);&#125; inline void pushdown(int u)&#123;if(rev[u])&#123;if (lc) Reverse(lc); if(rc)Reverse(rc); rev[u]=0;&#125;&#125; inline void pushup(int u)&#123; mx[u]=u; mx[u]=w[mx[u]]&lt;w[mx[lc]]?mx[lc]:mx[u]; mx[u]=w[mx[u]]&lt;w[mx[rc]]?mx[rc]:mx[u]; &#125; inline void Update(int u)&#123;if (!isRoot(u)) Update(fa[u]); pushdown(u);&#125;/* ----------- Splay part ------------*/ inline void rotate(int u)&#123; int fau = fa[u],ffau = fa[fau],d = isRson(u); fa[u]=ffau; if (!isRoot(fau)) ch[ffau][isRson(fau)] = u; fa[ch[fau][d] = ch[u][d^1]] = fau; fa[ch[u][d^1] = fau] = u; pushup(fau); pushup(u); &#125; inline void Splay(int u)&#123; //边Splay边向根传递信息 Update(u); for (;(!isRoot(u));rotate(u))&#123; if (!isRoot(fa[u])) rotate(isRson(fa[u])==isRson(u)?fa[u]:u); &#125; &#125;/* ----------- LCT part ------------*/ inline void access(int u)&#123; for(int f = 0; u; f = u,u = fa[u])&#123; Splay(u); rc = f; pushup(u); &#125; &#125; inline void makeroot(int u)&#123;access(u);Splay(u);Reverse(u);&#125; inline int find(int u)&#123;access(u);Splay(u);while(lc)pushdown(u),u=lc;return u;&#125; inline void split(int x,int y)&#123;makeroot(x);access(y);Splay(y);&#125; inline void link(int x,int y)&#123;makeroot(x);fa[x]=y;&#125; inline void cut(int u,int v)&#123;split(u,v);if(fa[u]==v&amp;&amp;(!rc))fa[u]=ch[v][0]=0;pushup(v);&#125; inline int query(int u,int v)&#123;makeroot(u);access(v);Splay(v);return mx[ch[v][0]];&#125;&#125;LCT;int ans = INF;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),m=read(); rep(i,1,m) E[i].Rd(); sort(E+1,E+m+1); rep(i,1,m)&#123; int u=E[i].u,v=E[i].v,A=E[i].A,B=E[i].B; LCT.w[n+i]=B; LCT.mx[n+i] = n+i; if(LCT.find(u)==LCT.find(v)) &#123; int ret = LCT.query(u,v); if (LCT.w[ret] &gt; B)&#123; LCT.cut(ret,E[ret-n].u); LCT.cut(ret,E[ret-n].v); LCT.link(u,n+i); LCT.link(v,n+i); &#125; &#125; else&#123;LCT.link(u,n+i); LCT.link(v,n+i);&#125; if (LCT.find(1)==LCT.find(n)) ans = min(ans,A+LCT.w[LCT.query(1,n)]); &#125; printf("%d\n",ans==INF?-1:ans); return 0;&#125;]]></content>
      <categories>
        <category>动态树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2008」树的统计]]></title>
    <url>%2F2018%2F06%2F26%2F%E3%80%8CZJOI2008%E3%80%8D%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[ZJOI-2008树的统计 Links there:ZJOI-2008树的统计 题意:要求实现这些操作 I. CHANGE u t : 把结点u的权值改为t II. QMAX u v: 询问从点u到点v的路径上的节点的最大权值 III. QSUM u v: 询问从点u到点v的路径上的节点的权值和 注意：从点u到点v的路径上的节点包括u和v本身 其实是个树剖裸题啊.但是学了$LCT$这种更强大的东西么写起来岂不是更舒服. 其实和模板题差不多,注意pushup更新的时候维护信息时,每个节点的Mx和Sum先赋值为自己然后建立虚拟点Mx[0]=-INF. 傻逼的我还是调了好久才对,发现自己调$LCT$的题真心不熟. P.S. LCT写起来比树剖优美多了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define lc ch[u][0]#define rc ch[u][1]inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 3e4+10;int n,m,u[MAXN],v[MAXN];inline char NextChar(void)&#123; char c=getchar(); while(!isalpha(c)) c=getchar(); return c;&#125;struct LinkCutTree&#123; int ch[MAXN][2],sum[MAXN],rev[MAXN],w[MAXN],fa[MAXN],Mx[MAXN]; inline bool isRson(int u)&#123;return ch[fa[u]][1] == u;&#125; inline bool isRoot(int u)&#123;return (ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u);&#125; inline void Reverse(int u)&#123;rev[u] ^= 1;swap(lc,rc);&#125; inline void pushdown(int u)&#123;if(rev[u])&#123;if (lc) Reverse(lc); if(rc)Reverse(rc); rev[u]=0;&#125;&#125; inline void pushup(int u)&#123;sum[u]=sum[lc]+sum[rc]+w[u];Mx[u]=max(w[u],max(Mx[lc],Mx[rc]));&#125; inline void Update(int u)&#123;if (!isRoot(u)) Update(fa[u]); pushdown(u);&#125;/* ----------- Splay part ------------*/ inline void rotate(int u)&#123; int fau = fa[u],ffau = fa[fau],d = isRson(u); fa[u]=ffau; if (!isRoot(fau)) ch[ffau][isRson(fau)] = u; fa[ch[fau][d] = ch[u][d^1]] = fau; fa[ch[u][d^1] = fau] = u; pushup(fau); pushup(u); &#125; inline void Splay(int u)&#123; Update(u); for (;(!isRoot(u));rotate(u))&#123; if (!isRoot(fa[u])) rotate(isRson(fa[u])==isRson(u)?fa[u]:u); &#125; &#125;/* ----------- LCT part ------------*/ inline void access(int u)&#123; for(int f = 0; u; f = u,u = fa[u])&#123; Splay(u); rc = f; pushup(u); &#125; &#125; inline void makeroot(int u)&#123;access(u);Splay(u);Reverse(u);&#125; inline int find(int u)&#123;access(u);Splay(u);while(lc)pushdown(u),u=lc;return u;&#125; inline void split(int x,int y)&#123;makeroot(x);access(y);Splay(y);&#125; inline void link(int x,int y)&#123;makeroot(x);fa[x]=y;&#125; inline void cut(int u,int v)&#123;split(u,v);if(fa[u]==v&amp;&amp;(!rc))fa[u]=ch[v][0]=0;pushup(v);&#125;&#125;LCT;signed main(signed argc, char *argv[])&#123; //freopen("1.in","r",stdin); //freopen("my.out","w",stdout); n=read();rep(i,1,n-1)&#123;u[i]=read(),v[i]=read();&#125; rep(i,1,n) LCT.w[i]=read(),LCT.sum[i]=LCT.Mx[i]=LCT.w[i]; LCT.Mx[0]=-INT_MAX; rep(i,1,n-1) LCT.link(u[i],v[i]); m=read(); rep(i,1,m) &#123; char xx=NextChar(); while(isalpha(xx)) &#123;char t=xx;xx=getchar();if(!isalpha(xx))&#123;xx=t;break;&#125;&#125; int x=read(),y=read(); switch(xx)&#123; case 'X':&#123;LCT.split(x,y);printf("%d\n",LCT.Mx[y]);break;&#125; case 'M':&#123;LCT.split(x,y);printf("%d\n",LCT.sum[y]);break;&#125; case 'E':&#123;LCT.Splay(x);LCT.w[x]=y;LCT.pushup(x);break;&#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2008」Cave 洞穴勘测]]></title>
    <url>%2F2018%2F06%2F26%2F%E3%80%8CSDOI2008%E3%80%8DCave-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[SDOI2008-洞穴勘测 Links there:SDOI2008 Cave 题意:要求你实现只有Link与Cut操作的,真正意义上的,$LCT$! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define lc ch[u][0]#define rc ch[u][1]//#define localinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;inline char NextChar(void)&#123; char c = getchar(); while(!isalpha(c)) c=getchar(); return c;&#125;///------------------head------------------int n,m,op;const int MAXN = 1e4+10;struct LinkCutTree&#123; int ch[MAXN][2],sum[MAXN],rev[MAXN],w[MAXN],fa[MAXN]; inline bool isRson(int u)&#123;return ch[fa[u]][1] == u;&#125; inline bool isRoot(int u)&#123;return (ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u);&#125; inline void Reverse(int u)&#123;rev[u] ^= 1;swap(lc,rc);&#125; inline void pushdown(int u)&#123;if(rev[u])&#123;if (lc) Reverse(lc); if(rc)Reverse(rc); rev[u]=0;&#125;&#125; inline void pushup(int u)&#123;sum[u]=sum[lc]^sum[rc]^w[u];&#125; inline void Update(int u)&#123;if (!isRoot(u)) Update(fa[u]); pushdown(u);&#125;/* ----------- Splay part ------------*/ inline void rotate(int u)&#123; int fau = fa[u],ffau = fa[fau],d = isRson(u); fa[u]=ffau; if (!isRoot(fau)) ch[ffau][isRson(fau)] = u; fa[ch[fau][d] = ch[u][d^1]] = fau; fa[ch[u][d^1] = fau] = u; pushup(fau); pushup(u); &#125; inline void Splay(int u)&#123; //边Splay边向根传递信息 Update(u); for (;(!isRoot(u));rotate(u))&#123; if (!isRoot(fa[u])) rotate(isRson(fa[u])==isRson(u)?fa[u]:u); &#125; &#125;/* ----------- LCT part ------------*/ inline void access(int u)&#123; for(int f = 0; u; f = u,u = fa[u])&#123; Splay(u); rc = f; pushup(u); &#125; &#125; inline void makeroot(int u)&#123;access(u);Splay(u);Reverse(u);&#125; inline int find(int u)&#123;access(u);Splay(u);while(lc)pushdown(u),u=lc;return u;&#125; inline void split(int x,int y)&#123;makeroot(x);access(y);Splay(y);&#125; inline void link(int x,int y)&#123;makeroot(x);fa[x]=y;&#125; inline void cut(int u,int v)&#123;split(u,v);if(fa[u]==v&amp;&amp;(!rc))fa[u]=ch[v][0]=0;pushup(v);&#125;&#125;LCT;signed main(signed argc, char *argv[])&#123; #ifdef local freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif n=read(),m=read(); rep(i,1,m)&#123; char x = NextChar();// putchar(x);puts(""); switch(x)&#123; case 'C':&#123; int x=read(),y=read(); if (LCT.find(x) != LCT.find(y)) LCT.link(x,y); break; &#125; case 'Q':&#123; int x=read(),y=read(); printf("%s\n",LCT.find(x)==LCT.find(y)?"Yes":"No"); break; &#125; default :&#123; int x=read(),y=read(); if (LCT.find(x) == LCT.find(y)) LCT.cut(x,y); break; &#125; &#125; &#125; #ifdef local fclose(stdin); fclose(stdout); #endif return 0;&#125;]]></content>
      <categories>
        <category>动态树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Link-Cut-Trees」LCT动态树学习笔记]]></title>
    <url>%2F2018%2F06%2F14%2F%E3%80%8CLink-Cut-Trees%E3%80%8DLCT%E5%8A%A8%E6%80%81%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[调了差不多一下午+晚上左右的LCT,算是搞懂了 感谢qxq巨爷的倾情讲解（大雾 LCT讲稿(无比生动版) LUOGU P3690 LCT[模板] Link there 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define lc ch[u][0]#define rc ch[u][1]inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------int n,m,op;const int MAXN = 3e5+10;struct LinkCutTree&#123; int ch[MAXN][2],sum[MAXN],rev[MAXN],w[MAXN],fa[MAXN]; inline bool isRson(int u)&#123;return ch[fa[u]][1] == u;&#125; inline bool isRoot(int u)&#123;return (ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u);&#125; inline void Reverse(int u)&#123;rev[u] ^= 1;swap(lc,rc);&#125; inline void pushdown(int u)&#123;if(rev[u])&#123;if (lc) Reverse(lc); if(rc)Reverse(rc); rev[u]=0;&#125;&#125; inline void pushup(int u)&#123;sum[u]=sum[lc]^sum[rc]^w[u];&#125; inline void Update(int u)&#123;if (!isRoot(u)) Update(fa[u]); pushdown(u);&#125;/* ----------- Splay part ------------*/ inline void rotate(int u)&#123; int fau = fa[u],ffau = fa[fau],d = isRson(u); fa[u]=ffau; if (!isRoot(fau)) ch[ffau][isRson(fau)] = u; fa[ch[fau][d] = ch[u][d^1]] = fau; fa[ch[u][d^1] = fau] = u; pushup(fau); pushup(u); &#125; inline void Splay(int u)&#123; //边Splay边向根传递信息 Update(u); for (;(!isRoot(u));rotate(u))&#123; if (!isRoot(fa[u])) rotate(isRson(fa[u])==isRson(u)?fa[u]:u); &#125; &#125;/* ----------- LCT part ------------*/ inline void access(int u)&#123; for(int f = 0; u; f = u,u = fa[u])&#123; Splay(u); rc = f; pushup(u); &#125; &#125; inline void makeroot(int u)&#123;access(u);Splay(u);Reverse(u);&#125; inline int find(int u)&#123;access(u);Splay(u);while(lc)pushdown(u),u=lc;return u;&#125; inline void split(int x,int y)&#123;makeroot(x);access(y);Splay(y);&#125; inline void link(int x,int y)&#123;makeroot(x);fa[x]=y;&#125; inline void cut(int u,int v)&#123;split(u,v);if(fa[u]==v&amp;&amp;(!rc))fa[u]=ch[v][0]=0;pushup(v);&#125;&#125;LCT;signed main(signed argc, char *argv[])&#123; n=read(),m=read(); rep(i,1,n) LCT.w[i]=read(); rep(i,1,m) &#123; int op=read(),x=read(),y=read(); switch(op)&#123; case 0:&#123;LCT.split(x,y);printf("%d\n",LCT.sum[y]);break;&#125; case 1:&#123;if(LCT.find(x) != LCT.find(y))LCT.link(x,y);break;&#125; case 2:&#123;if(LCT.find(x) == LCT.find(y))LCT.cut(x,y);break;&#125; case 3:&#123;LCT.w[x]=y;LCT.Splay(x);break;&#125; &#125; &#125; return 0;&#125; 剩下的中考之后再补辣.]]></content>
      <categories>
        <category>动态树</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces」 Educational Round 45 复盘]]></title>
    <url>%2F2018%2F06%2F10%2F%E3%80%8CCodeforces%E3%80%8D-Educational-Round-45%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[没有体验. 首先网速就很不给力 裸连ping在1000ms+,LOSS爆炸,根本打不开. 于是科学上网勉强可以打. 垃圾ER,整天卡人的小数据出出 题意不明不知道要构造的图的性质 卡我一个多小时的D,最后就改了一行代码赛后一发AC（赛时4发WA）,体验极差！ 掉Rating是肯定的. shit. :( 后来发现E原来是傻逼题 F也一眼可做的样子 mdzz我完完全全错失ELO机会 不是先把做了的丢上来吧. A 12345678910111213141516171819202122232425262728293031323334353637383940//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; int n=read(),m=read(),a=read(),b=read(); if (!(n % m)) &#123;puts("0"); return 0;&#125; int x1 = n % m,x2 = m - x1; printf("%lld\n",min(x1 * b,x2 * a)); return 0;&#125;/* Examples: *//**//**/ B 123456789101112131415161718192021222324252627282930313233343536373839404142434445//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int maxn = 2e5+10;int n,k,a[maxn],b[maxn],c[maxn];pair&lt;int,int&gt;pa[maxn];///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),k=read(); rep(i,1,n) a[i]=read(),pa[i]=make_pair(a[i],i); int ans = 0; sort(pa+1,pa+n+1); rep(i,1,n) b[i]=pa[i].fi,c[i]=pa[i].se; rep(i,1,n) &#123;int tof = b[i],s; s = (upper_bound(b+1,b+n+1,tof+k) - b) - 1 - (upper_bound(b+1,b+n+1,tof)-b) + 1; if (s &gt; 0) ++ans;&#125; printf("%lld\n",n-ans); return 0;&#125;/* Examples: *//**//**/ C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 3e5+10;int n,ans = 0;map&lt;int,int&gt;buc;string a;pair&lt;int,int&gt; check(string a,int l)&#123; int lf = 0,rt = 0; int lneed=0; rep(i,0,l-1) &#123; if (lf == 0 &amp;&amp; a[i] == ')') &#123;++lneed;continue;&#125; lf += a[i] == '('; rt += a[i] == ')'; int x=min(lf,rt); lf -= x; rt -= x; &#125; return make_pair(lneed,lf);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; int n=read(); rep(i,1,n)&#123; int ret = 0; cin &gt;&gt; a; int l = a.length(); pair&lt;int,int&gt; Re = check(a,l); if (Re.fi &gt; 0 &amp;&amp; Re.se &gt; 0) continue; if (Re.fi == 0 &amp;&amp; Re.se == 0) ++buc[0]; else if (Re.fi != 0) ++buc[Re.fi]; else ++buc[-Re.se]; &#125; for (int i = 1; i &lt;= MAXN; i++) &#123; if (!buc[i] || !buc[-i]) continue; ans += buc[i] * buc[-i]; &#125; ans += buc[0] * buc[0]; printf("%lld",ans); return 0;&#125;/* Examples: *//**//**/ D 我挂张图希望泥萌感受到我的绝望 可能是我菜吧. 赛后一发就对我也不知道是什么操作啊(雾) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int n,a,b,g[1001][1001],flag = 0;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),a=read(),b=read(); if (a != 1 &amp;&amp; b != 1) &#123;puts("NO"); return 0;&#125; if (n == 2 &amp;&amp; a == 1 &amp;&amp; b == 1) &#123;puts("NO"); return 0;&#125; if (n == 3 &amp;&amp; a == 1 &amp;&amp; b == 1) &#123;puts("NO"); return 0;&#125; if (a &gt; b) swap(a,b),flag = 1; for (int i = b; i &lt;= n - 1; i++) g[i][i+1] = g[i+1][i] = 1; if (!flag) rep(i,1,n) rep(j,1,n) &#123;if (i==j) continue; g[i][j]^=1;&#125; puts("YES"); rep(i,1,n) &#123; rep(j,1,n) printf("%d",g[i][j]); puts(""); &#125; return 0;&#125;/* Examples: *//**//**/ E 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e6+10;int n,m,k,x[MAXN],ans = LLONG_MAX;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),m=read(),k=read(); while(m--)&#123; int t = read(); x[t] = 1; &#125; rep(i,0,n-1)&#123; if (x[i]) &#123; if (!i) x[i] = -1; else x[i] = x[i-1]; &#125; else x[i] = i; &#125; rep(i,1,k)&#123; int e1=0,e2=0,y; y=read(); while(e1 &lt; n)&#123; if (x[e1] &lt; 0 || x[e1] &lt;= e1 - i) break; e1 = i + x[e1]; ++e2; &#125; ans = (e1 &gt;= n) ? min(ans,y * e2) : ans; &#125; printf("%lld\n",ans==LLONG_MAX?-1:ans); return 0;&#125;/* Examples: *//**//**/ gg my friend. 明天div2见. 我真的比老狗还菜 加油.]]></content>
      <categories>
        <category>ELO Record</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ-3237」Tree]]></title>
    <url>%2F2018%2F06%2F10%2F%E3%80%8CPOJ-3237%E3%80%8DTree%2F</url>
    <content type="text"><![CDATA[POJ-3237 Description You are given a tree with N nodes. The tree’s nodes are numbered 1 through N and its edges are numbered 1 through N − 1. Each edge is associated with a weight. Then you are to execute a series of instructions on the tree. The instructions can be one of the following forms: CHANGE i v Change the weight of the ith edge to v NEGATE a b Negate the weight of every edge on the path from a to b QUERY a b Find the maximum weight of edges on the path from a to b Input The input contains multiple test cases. The first line of input contains an integer t (t ≤ 20), the number of test cases. Then follow the test cases.Each test case is preceded by an empty line. The first nonempty line of its contains N (N ≤ 10,000). The next N − 1 lines each contains three integers a, b and c, describing an edge connecting nodes a and b with weight c. The edges are numbered in the order they appear in the input. Below them are the instructions, each sticking to the specification above. A lines with the word “DONE” ends the test case. Output For each “QUERY” instruction, output the result on a separate line. Sample Input 12345678131 2 12 3 2QUERY 1 2CHANGE 1 3QUERY 1 2DONE Sample Output 1213 树剖码农题,是真的难调. 似乎for (int i = head[u]; ~i; i = E[i].next)和for (int i = head[u]; i; i = E[i].next) 有差别? 坑了我好久啊… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230//my vegetable has exploded. :(#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;climits&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 21000+10;struct Edges&#123; int to,w,next;&#125;E[MAXN&lt;&lt;2];int cnt=0,dfs_cnt=0;struct SegmentTree&#123; int L,R,rev; int minn,maxx;&#125;tree[MAXN&lt;&lt;3];int fa[MAXN],sz[MAXN],hson[MAXN],dep[MAXN],top[MAXN],dfn[MAXN],head[MAXN],T,n,uu[MAXN],vv[MAXN],ww[MAXN];int R1[MAXN],R[MAXN];//映射void addedge(int u,int v,int w)&#123; E[++cnt].to = v; E[cnt].w = w; E[cnt].next = head[u]; head[u]=cnt;&#125;inline void Reset(void)&#123; MM(hson,-1);MM(sz,0);MM(head,0); cnt=dfs_cnt=0;&#125;///------------------head------------------/*void dfs1(int u,int F,int depth)&#123; printf("%d %d %d\n",u,F,depth); sz[u]=1;fa[u]=F;dep[u]=depth; for(int i=head[u]; i; i=E[i].next) &#123; int v = E[i].to; if (v != F) &#123; R[v]=E[i].w; dfs1(v,u,depth+1); sz[u] += sz[v]; if((hson[u] == -1) || sz[hson[u]] &lt; sz[v]) hson[u] = v; &#125; &#125;&#125;*/void dfs1(int u, int father, int depth) &#123; dep[u] = depth; fa[u] = father; sz[u] = 1; for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != fa[u]) &#123; R[v] = E[i].w; dfs1(v, u, depth + 1); sz[u] += sz[v]; if (hson[u] == -1 || sz[v] &gt; sz[hson[u]]) hson[u] = v; &#125; &#125;&#125;void dfs2(int u,int t)&#123; dfn[u] = dfs_cnt++; top[u] = t; R1[dfn[u]] = R[u]; if (!hson[u]) return ; dfs2(hson[u],t); for (int i = head[u]; i; i = E[i].next)&#123; int v = E[i].to; if (v != fa[u] &amp;&amp; v != hson[u]) dfs2(v,v); &#125;&#125;void pushup(int o)&#123; tree[o].minn = min(tree[lc].minn,tree[rc].minn); tree[o].maxx = max(tree[lc].maxx,tree[rc].maxx);&#125;void Modify(int o)&#123; swap(tree[o].minn,tree[o].maxx); tree[o].maxx *= -1; tree[o].minn *= -1;&#125;void pushdown(int o)&#123; if (!tree[o].rev) return ; tree[lc].rev ^= 1; tree[rc].rev ^= 1; //下放反转标记 Modify(lc); Modify(rc); tree[o].rev = 0;&#125;void Build(int o,int l,int r)&#123; tree[o].L = l,tree[o].R = r; tree[o].rev = 0; int m = (l + r) &gt;&gt; 1; if (l == r) tree[o].minn = tree[o].maxx = R1[l]; else &#123; Build(lc,l,m); Build(rc,m+1,r); pushup(o); &#125;&#125;void update(int o,int p,int z)&#123; if (p == tree[o].L &amp;&amp; p == tree[o].R) &#123;tree[o].minn = tree[o].maxx = z;&#125; else &#123; pushdown(o); int ll = tree[o].L,rr = tree[o].R,mid = (ll + rr) &gt;&gt; 1; if (p &lt;= mid) update(lc,p,z); else update(rc,p,z); pushup(o); &#125;&#125;void update2(int o,int l,int r )&#123; int L = tree[o].L,R = tree[o].R; if (L &gt;= l &amp;&amp; R &lt;= r)&#123; tree[o].rev ^= 1; Modify(o); return ; &#125; pushdown(o); int m = (L + R) &gt;&gt; 1; if (l &lt;= m) update2(lc,l,r); if (r &gt; m) update2(rc,l,r); pushup(o);&#125;void Maintain(int u,int v)&#123; int topu = top[u],topv = top[v]; while(topu != topv) &#123; if (dep[topu] &lt; dep[topv]) swap(u,v),swap(topu,topv); update2(1,dfn[topu],dfn[u]); u = fa[topu],topu = top[u]; &#125; if (u == v) return ; if (dep[u] &lt; dep[v]) swap(u,v); update2(1,dfn[v] + 1,dfn[u]);&#125;int query_on_tree(int o,int l,int r)&#123; int L = tree[o].L,R = tree[o].R; if (l &lt;= L &amp;&amp; R &lt;= r) return tree[o].maxx; if (l &gt; R || r &lt; L) return -INT_MAX; pushdown(o); return max(query_on_tree(lc,l,r),query_on_tree(rc,l,r));&#125;int Query_mx(int u,int v)&#123; if (u == v) return 0; int ans = -INT_MAX; int topu = top[u],topv = top[v]; while(topu != topv) &#123; if (dep[topu] &lt; dep[topv]) swap(u,v),swap(topu,topv); ans = max(ans,query_on_tree(1,dfn[topu],dfn[u])); u = fa[topu],topu = top[u]; &#125; if (u == v) return ans; if (dep[u] &lt; dep[v]) swap(u,v); return ans = max(ans,query_on_tree(1,dfn[v]+1,dfn[u]));&#125;signed main(signed argc, char *argv[])&#123; T=read(); while(T--)&#123; Reset(); n = read(); rep(i,1,n-1)&#123;uu[i]=read(),vv[i]=read(),ww[i]=read();addedge(uu[i],vv[i],ww[i]);addedge(vv[i],uu[i],ww[i]);&#125; /* for (int u = 1; u &lt;= n; u++)&#123; for (int i = head[u]; i; i = E[i].next) printf("%d -&gt; %d = %d\n",u,E[i].to,E[i].w); puts(""); &#125; */ dfs1(1,0,1); dfs2(1,1); Build(1,1,n); string op; while(cin &gt;&gt; op)&#123; if (op == "DONE") break; else if (op == "QUERY")&#123; int u=read(),v=read(); printf("%lld\n",Query_mx(u,v)); &#125; else if (op == "CHANGE")&#123; int m=read(),newv=read(); if (dep[uu[m]] &lt; dep[vv[m]]) swap(uu[m],vv[m]); update(1,dfn[uu[m]],newv); &#125; else &#123; int u=read(),v=read(); Maintain(u,v); &#125; &#125; &#125; return 0;&#125;/* Examples: *//*IN131 2 12 3 2QUERY 1 2CHANGE 1 3QUERY 1 2DONE*//*OUT13*/]]></content>
      <categories>
        <category>动态树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「树链剖分 - 学习笔记」]]></title>
    <url>%2F2018%2F06%2F08%2F%E3%80%8C%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8D%2F</url>
    <content type="text"><![CDATA[树链剖分似乎是个很强大的东西 可惜我之前不会啊 所以就mark一下啊 定义树链剖分 简称树剖.对于一般的树上路径/权值的问题,Tarjan的LCA在线性内就可以快速求解. 如果要修改点权或者边权呢? 树链剖分就是用来解决动态修改树上权值并求解的问题的 一般树链剖分更新权值的复杂度为$O(logn)$,统计路径信息的复杂度为$O((logn)^2)$ 内容某些一定要知道的概念 重节点：子树结点数目最多的节点； 轻节点：父亲节点中除了重结点以外的节点； 重边：父亲节点和重节点连成的边； 轻边：父亲节点和轻节点连成的边； 重链：由多条重边连接而成的路径； 轻链：由多条轻边连接而成的路径； 这些东西有一个性质. 1.一条重链在线段树上是一段连续的区间。 2.一个节点的重儿子就是这个节点的子节点中子树最大的点。 所以第一次dfs求出重儿子 第二次通过dfs时间戳(dfn),得出节点新编号,并且将各个重节点连接成重链，轻节点连接成轻链 将重链（其实就是一段区间）用数据结构（一般是树状数组或线段树）来进行维护 为每个节点进行编号，其实就是DFS在执行时的顺序（id数组） 以及当前节点所在链的起点（top数组），还有当前节点在树中的位置（rnk数组）. 1234567891011121314//dfs1void dfs1(int u, int F, int depth) &#123; dep[u] = depth; fa[u] = F; siz[u] = 1; for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != fa[u]) &#123; //如果不是父节点就继续向下找节点 dfs1(v, u, depth + 1); siz[u] += siz[v];//加子结点的sz if ((!hson[u]) || siz[v] &gt; siz[hson[u]]) hson[u] = v;//如果没有重孩子或者此孩子的sz较大则更新hson[u] &#125; &#125;&#125; 12345678910//dfs2void dfs2(int u, int t) &#123; dfn[u] = ++dfs_cnt; rnk[dfs_cnt] = u; top[u] = t;//维护u顶点的节点t if (!hson[u]) return ;//不是重儿子就return dfs2(hson[u], t);//继续向下找重链 for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != hson[u] &amp;&amp; v != fa[u]) dfs2(v, v);//找其他非u为顶点的链 &#125;&#125; LUOGU P3384 树链剖分[模板] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define REP(i,a,b) for(int i=a;i&lt;=b;i++)#define PER(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long long#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1using namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 110000;struct Node &#123; int to, next;&#125; E[MAXN&lt;&lt;1];struct segmentTree &#123; int L, R; int sum, tag;&#125; tree[MAXN&lt;&lt;2];int head[MAXN], siz[MAXN], top[MAXN], hson[MAXN];int dep[MAXN], fa[MAXN], dfn[MAXN], rnk[MAXN];int N, M, R, A[MAXN], cnt = 0, dfs_cnt = 0,mod;inline void adde(int u, int v) &#123; E[++cnt].to = v; E[cnt].next = head[u]; head[u] = cnt;&#125;void dfs1(int u, int F, int depth) &#123; dep[u] = depth; fa[u] = F; siz[u] = 1; for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != fa[u]) &#123; dfs1(v, u, depth + 1); siz[u] += siz[v]; if ((!hson[u]) || siz[v] &gt; siz[hson[u]]) hson[u] = v; &#125; &#125;&#125;void dfs2(int u, int t) &#123; dfn[u] = ++dfs_cnt; rnk[dfs_cnt] = u; top[u] = t; if (!hson[u]) return ; dfs2(hson[u], t); for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != hson[u] &amp;&amp; v != fa[u]) dfs2(v, v); &#125;&#125;void Build(int o, int l, int r) &#123; tree[o].L = l; tree[o].R = r; if (l == r) tree[o].sum = A[rnk[l]]; else &#123; int mid = (l + r) &gt;&gt; 1; Build(lc, l , mid); Build(rc | 1, mid + 1, r); tree[o].sum = tree[lc].sum + tree[rc].sum; &#125;&#125;void pushdown(int o) &#123; tree[lc].sum += (tree[lc].R - tree[lc].L + 1) * tree[o].tag; tree[rc].sum += (tree[rc].R - tree[rc].L + 1) * tree[o].tag; tree[lc].tag += tree[o].tag; tree[rc].tag += tree[o].tag; tree[o].tag = 0;&#125;void update(int o, int x, int y, int z) &#123; if (tree[o].L &gt; y || tree[o].R &lt; x) return ; if (x &lt;= tree[o].L &amp;&amp; tree[o].R &lt;= y) &#123; tree[o].sum += (tree[o].R - tree[o].L + 1) * z; tree[o].tag += z; &#125; else &#123; if (tree[o].tag) pushdown(o); update(lc, x, y, z); update(rc, x, y, z); tree[o].sum = tree[lc].sum + tree[rc].sum; &#125;&#125;int query(int o, int x, int y) &#123; if (x &lt;= tree[o].L &amp;&amp; tree[o].R &lt;= y) return tree[o].sum; if (tree[o].L &gt; y || tree[o].R &lt; x) return 0; if (tree[o].tag) pushdown(o); return query(lc, x, y) + query(rc, x, y);&#125;void update_path(int u, int v, int z) &#123; int tu = top[u], tv = top[v]; while (tu != tv) &#123; if (dep[tu] &lt; dep[tv]) swap(u, v), swap(tu, tv); update(1, dfn[tu], dfn[u], z); u = fa[tu], tu = top[u]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); update(1, dfn[v], dfn[u], z);&#125;int query_path(int u, int v) &#123; int res = 0; int tu = top[u], tv = top[v]; while (tu != tv) &#123; if (dep[tu] &lt; dep[tv]) swap(u, v), swap(tu, tv); res += query(1, dfn[tu], dfn[u]); u = fa[tu], tu = top[u]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); return res + query(1, dfn[v], dfn[u]);&#125;signed main(signed argc, char *argv[]) &#123; N = read(), M = read(), R = read(), mod = read(); REP(i, 1, N) A[i] = read(); REP(i, 2, N) &#123; int u = read(), v = read(); adde(u, v); adde(v, u); &#125; dfs1(R, 0, 1); dfs2(R, R); //REP(i,1,N) printf("%d %d %d %d %d\n",i,fa[i],dfn[i],siz[i],dep[i]); Build(1, 1, N); while (M--) &#123; int opt = read(); switch (opt) &#123; case 1: &#123; int x = read(), y = read(); int z; scanf("%lld", &amp;z); update_path(x, y, z); break; &#125; case 2: &#123; int x = read(), y = read(); printf("%lld\n", query_path(x, y) % mod); break; &#125; case 3: &#123; int x = read(); int z; scanf("%lld", &amp;z); update(1, dfn[x], dfn[x] + siz[x] - 1, z); break; &#125; case 4: &#123; int x = read(); printf("%lld\n", query(1, dfn[x], dfn[x] + siz[x] - 1) % mod); &#125; &#125; &#125; return 0;&#125; POJ-2763 基于边权修改的树剖. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142//my vegetable has exploded. :(#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second// #define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+10;///------------------head------------------#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1int fa[MAXN],hson[MAXN],dep[MAXN],dfn[MAXN],rnk[MAXN],top[MAXN],sz[MAXN],val[MAXN];int head[MAXN],cnt=0,dfs_cnt=0;int n,m,s;struct Edge&#123; int u,v,val; inline void R()&#123; u=read();v=read();val=read(); &#125; Edge(int uu=0,int vv=0,int vval=0):u(uu),v(vv),val(vval)&#123;&#125;&#125;Edges[MAXN];struct E&#123; int to,next;&#125;E[MAXN&lt;&lt;1];struct SegmentTree&#123; int L,R,val;&#125;Tree[MAXN&lt;&lt;2];inline void adde(int u, int v) &#123; E[++cnt].to = v; E[cnt].next = head[u]; head[u] = cnt;&#125;void dfs1(int u, int father, int depth) &#123; dep[u] = depth; fa[u] = father; sz[u] = 1; for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != fa[u]) &#123; dfs1(v, u, dep[u]+1); sz[u] += sz[v]; if (hson[u] == -1 || sz[v] &gt; sz[hson[u]]) hson[u] = v; &#125; &#125;&#125;void dfs2(int u, int t) &#123; dfn[u] = ++dfs_cnt; rnk[dfs_cnt] = u; top[u] = t; if (!hson[u]) return ; dfs2(hson[u], t); for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != hson[u] &amp;&amp; v != fa[u]) dfs2(v, v); &#125;&#125;void pushup(int o)&#123;Tree[o].val = Tree[lc].val + Tree[rc].val;&#125;void build(int l,int r,int o)&#123; Tree[o].L = l; Tree[o].R = r; if (l == r) &#123;Tree[o].val = val[l]; return;&#125; int mid = (l + r) &gt;&gt; 1; build(l,mid,lc); build(mid+1,r,rc); pushup(o);&#125;void Update(int o,int v,int val)&#123; if (Tree[o].L == Tree[o].R) &#123;Tree[o].val = val; return ;&#125; int mid = (Tree[o].L + Tree[o].R) &gt;&gt; 1; if (v &lt;= mid) Update(lc,v,val); else Update(rc,v,val); pushup(o);&#125;int query(int o,int l,int r)&#123; if(Tree[o].L &gt;= l &amp;&amp; Tree[o].R &lt;= r) return Tree[o].val; int mid = (Tree[o].L + Tree[o].R) &gt;&gt; 1; if (r &lt;= mid) return query(lc,l,r); else if (l &gt; mid) return query(rc,l,r); else return query(lc,l,mid)+query(rc,mid+1,r);&#125;int Query(int u,int v)&#123; int tp1 = top[u],tp2 = top[v]; int ret = 0; while(tp1 != tp2)&#123; if (dep[tp1] &lt; dep[tp2]) &#123; swap(u,v); swap(tp1,tp2); &#125; ret += query(1,dfn[tp1],dfn[u]); u = fa[tp1]; tp1 = top[u]; &#125; if(u == v) return ret; if(dep[u] &gt; dep[v]) swap(u,v); ret += query(1,dfn[hson[u]],dfn[v]); return ret;&#125;signed main(signed argc, char *argv[])&#123; n=read(),m=read(),s=read(); rep(i,1,n-1)&#123;Edges[i].R();adde(Edges[i].u,Edges[i].v);adde(Edges[i].v,Edges[i].u);&#125; dfs1(1,0,1); dfs2(1,1); rep(i,1,n-1)&#123; if (dep[Edges[i].u] &lt; dep[Edges[i].v]) swap(Edges[i].u,Edges[i].v); val[dfn[Edges[i].u]] = Edges[i].val; &#125; build(1,dfs_cnt,1); rep(i,1,m)&#123; int op=read(),x,y; if(!op)&#123;x=read();printf("%d\n",Query(s,x));s=x;&#125; else&#123;x=read(),y=read();Update(1,dfn[Edges[x].u],y);&#125; &#125; return 0;&#125;/* Examples: *//*in3 3 11 2 12 3 20 21 2 30 3*//*out13*/ :）karriganasta]]></content>
      <categories>
        <category>动态树</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces」CF-Round485 Div2 复盘]]></title>
    <url>%2F2018%2F05%2F30%2F%E3%80%8CCodeforces%E3%80%8DCF-Round485-Div2-%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[我这种傻逼选手也只能做做Div2练练手了… 链接CF-Round485 Div2 某彩笔选手的Room 算是CF打到现在自己发挥算好的吧..但是为什么才涨了49分啊…不资瓷啊. 以后每次比赛都写一次复盘吧.（有可能我懒不想写 划水记赛前半夜23:35开打的Div2,肝快爆了,ZhangZisu还有GCC314大爷带我飞啊啊啊啊啊. 赛前疯狂打CodeSource(滑稽 尝试着睡着但是没成功,魔爪也没啦,抱着必掉$rating$的心打的比赛. 赛中A 一看哇特么的是 复联3 灭霸1背景诶!傻逼题,手速还是慢啊花了6min. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;string s[7] = &#123;"Reality","Power","Mind","Soul","Space","Time"&#125;;string wd[7] = &#123;"red","purple","yellow","orange","blue","green"&#125;;bool g[7];///------------------head------------------signed main(signed argc, char *argv[])&#123; MM(g,0); int n=read(),ans=0; while(n--)&#123; string s; cin &gt;&gt; s; rep(i,0,5) if (wd[i] == s) g[i] = 1; &#125; rep(i,0,5) ans += (!g[i]); cout &lt;&lt; ans &lt;&lt; endl; rep(i,0,5) if(!g[i]) cout &lt;&lt; s[i] &lt;&lt; endl; return 0;&#125; B. 给出$x$,$y$,求比较$x^y,y^x$的大小. log一下什么的就好了.愚蠢的我忘了换底公式. 只能pow了.我菜爆了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;const double eps = 1e-8;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;double x,y,r;///------------------head------------------signed main(signed argc, char *argv[])&#123; cin &gt;&gt; x &gt;&gt; y; if (x == 2 &amp;&amp; y == 4)&#123;puts("="); return 0;&#125; if (x == 4 &amp;&amp; y == 2)&#123;puts("="); return 0;&#125; if (x &lt; y)&#123; double a1 = x,a2 = pow(y,x/y); printf("%c\n",(a1-a2 &gt; eps) ? '&gt;' : '&lt;'); &#125; else if (x == y) &#123;puts("=");&#125; else &#123; double a1 = x,a2 = pow(y,x/y); printf("%c\n",(a1-a2 &gt; eps) ? '&gt;' : '&lt;'); &#125; return 0;&#125; C. 给定$n,{ s_i} {c_i},1 \leq n \leq 3000$,求三元组$(i,j,k)$满足$s_i &lt; s_j &lt; s_k,i&lt;j&lt;k$ 求出最小的$c_i+c_j+c_k$ 似乎是个DP啊,想了好久的奇怪做法(二分+RMQ) 然后发现是个$O(n^2)$的DP 啊啊啊啊啊 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define INF 1000000000000001LLusing namespace std;const int maxn = 3003;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;int n,a[maxn],b[maxn],f[maxn][4];int d[maxn][100];void RMQ_init(int a[],int n)&#123; for (int i = 1; i &lt;= n; i++) d[i][0] = a[i]; for (int j = 1; (1&lt;&lt;j) &lt;= n; j++) for (int i = 0; i + (1&lt;&lt;j) - 1 &lt;= n; i++) //可以从第0位置开始 d[i][j] = min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]);&#125; int RMQ_query(int l,int r)&#123; int k = 0; while((1&lt;&lt;(k+1)) &lt;= r-l+1) k++; return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(); int ans = 0x3F3F3F3F; for (int i=1;i&lt;=n;i++)a[i]=read(); for (int i=1;i&lt;=n;i++)b[i]=read(); a[0]=0x80000000; memset(f,0x3F,sizeof(f)); f[0][0] = 0; rep(i,1,n) rep(j,1,3) rep(k,0,i-1) &#123; if(a[k] &gt;= a[i]) continue; f[i][j] = min(f[i][j],f[k][j-1]+b[i]); &#125; rep(i,1,n) ans=min(ans,f[i][3]); printf("%d\n",ans&gt;300000001?-1:ans); return 0;&#125; D. 题意: 有$n$个村庄,$m$条边,每条边默认的边权为1,每个村庄有一个货物$x_i$,货物最多有$min(100,k)$种 分别求每个村庄作为主办方(要从其他村庄获取货物),要展览$s$个物品的最小花费？ (每种货物算1个) 思考了很久很久啊..中间一会儿看E一会儿看D并行地写啊.. 发现是个傻逼题. 对于每种货物.选取当前的货物种类$x$,扔到队列里笨法师一遍,记录$F(i,x)$,表示第x种货物搬到村庄$i$的最小花费.这样是$O(nk)$的,那么每次每个村庄在$F(i)$里的$x$,$sort$一下求前$s$个就完事了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;const int maxn = 1e5+10;int n,m,s,k;bool vis[maxn];int f[maxn][101];int b[101],ans;int types[100010];queue&lt;pair&lt;int,int&gt; &gt;q;pair&lt;int,int&gt; pa; vector&lt;int&gt;lt[maxn];///------------------head------------------signed main(signed argc, char *argv[])&#123; MM(f,0x7f); n=read(),m=read(),k=read(),s=read(); rep(i,1,n) types[i]=read(); rep(i,1,m) &#123; int x=read(),y=read(); lt[x].push_back(y); lt[y].push_back(x); &#125; //system("pause"); for (int i = 1; i &lt;= min(100,k); i++)&#123; MM(vis,0); while(!q.empty())q.pop(); for (int j=1;j&lt;=n;j++) if(i==types[j])vis[j]=1,q.push(make_pair(j,0)); while(!q.empty()) &#123; pa = q.front(); q.pop(); f[pa.fi][i] = min(f[pa.fi][i],pa.se); for(int oo = 0; oo &lt; lt[pa.fi].size(); oo++) if(!vis[lt[pa.fi][oo]]) vis[lt[pa.fi][oo]]=1,q.push(make_pair(lt[pa.fi][oo],pa.se+1)); &#125; &#125; for (int i = 1; i &lt;= n; i++)&#123; ans=0; memcpy(b,f[i],sizeof(f[i])); sort(b+1,b+100+1); for(int p=1;p&lt;=s;p++) ans+=b[p]; cout &lt;&lt; ans &lt;&lt; " "; &#125; return 0;&#125; E. 给一个1~N的排列,Petr把两个不同元素交换$3n$次得到一个新的序列,Um_nik把两个不同元素交换$7n+1$次得到一个新的序列.现在给出这个新的序列,求是谁操作了这个序列. 求逆序对就完事了.01:49想到的做法,1发入魂. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;const int maxn = 1e6+10;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;int b[maxn],n;namespace getrev&#123; int a[maxn],c[maxn],ans=0; void x(int l,int r)&#123; int mid=(l+r)/2,i,j,tmp; if(r&gt;l) &#123; x(l,mid); x(mid+1,r); tmp=l; for(i=l,j=mid+1;i&lt;=mid&amp;&amp;j&lt;=r;) &#123; if(a[i]&gt;a[j]) &#123; c[tmp++]=a[j++]; ans+=mid-i+1; &#125; else c[tmp++]=a[i++]; &#125; if(i&lt;=mid) for(;i&lt;=mid;) c[tmp++]=a[i++]; if(j&lt;=r) for(;j&lt;=r;) c[tmp++]=a[j++]; for(i=l;i&lt;=r;i++) a[i]=c[i]; &#125; &#125; int sol(void)&#123; memcpy(a,b,sizeof(b)); x(1,n); return ans; &#125;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(); rep(i,1,n) b[i]=read(); int petr=(n*3) &amp; 1; int cnt=getrev::sol(); cnt=cnt&amp;1; printf("%s\n",cnt==petr?"Petr":"Um_nik"); return 0;&#125; F.(订正) 给出n,给出m个$1\leq x \leq 2^n$的元素,其中某两个元素$a,b$有连边当且仅当$a \&amp;b = 0$ 求联通快的个数. 看上去很不可做！ ckr:我几秒钟就秒掉了 被D爆了啊… 首先$3^n$的暴力是很显然的,但是通不过,考虑优化. ckr:”我们尝试着Gay掉1位” 类似于记忆化的过程,我们在dfs时记录vis[x]表示访问过x. 我们在dfs时枚举$0-n$,如果$(2^i \&amp; x)$,就可以Gay掉. 继续下去$dfs(x^{2^i})$ 如果x在读入种出现了就dfs它的补集. 因为x的补集种所有子集必然与x联通,因此正确性显然. 哇 我特么这都没想到.是被难度吓退了啊. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;const int N = 1&lt;&lt;23;int vis[N],ins[N],ans=0,x,n,m;void dfs(int u)&#123; if(vis[u]) return ;vis[u]=1; rep(i,0,n-1) if((1&lt;&lt;i)&amp;u) dfs((1&lt;&lt;i)^u); if(ins[u]) dfs((1&lt;&lt;n)-1-u);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; MM(ins,0); n=read(),m=read(); while(m--)&#123; x=read(); ins[x]=1; &#125; if(n==1&amp;&amp;ins[1]) return puts("1"),0; rep(i,0,(1&lt;&lt;n)-1)&#123; if(!(vis[i]||!ins[i]))&#123; ++ans; dfs((1&lt;&lt;n)-i-1); &#125; &#125; printf("%d\n",ans); return 0;&#125; 后记 算是第一次打到5题吧.. 之后要坚持啊… ​ karriganasta :P]]></content>
      <categories>
        <category>ELO Record</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈次小生成树]]></title>
    <url>%2F2018%2F05%2F08%2F%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91-%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[次小生成树定义顾名思义,在一个图$G=(V,E)$中如果存在最小生成树$T$，如果有一个生成树$T’ \not= T $且对于$\forall T_x &gt; T’$,则称生成树$T’$为$G$的次小生成树. 算法0枚举原来$T$中每一条边将其删去,每次求一遍MST. 复杂度:$O(n*mlog_2m)$ 显然难以接受. 应该还是挺好写的(但是并不保证严格) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;struct Node&#123; int u,v,c; bool operator &lt; (const Node &amp;b) const &#123; return c &lt; b.c; &#125; bool sel;&#125;a[maxn];int fa[maxn],sell[maxn],cnt = 0,n,m,ans = INT_MAX;void Pre(void)&#123;for(int i = 1; i &lt; maxn; i++) fa[i] = i;&#125;int getf(int x)&#123;return x==fa[x]?x:fa[x]=getf(fa[x]);&#125;inline int read(void)&#123; int x=0,f=1;char c=getchar(); while(!isdigit(c))&#123;f=c=='-'?-1:1;c=getchar();&#125; while(isdigit(c))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';c=getchar();&#125; return x * f;&#125;int main(int argc, char *argv[])&#123; n = read(), m = read(); for (int i = 1; i &lt;= m; i++) a[i].u = read(),a[i].v = read(),a[i].c = read(),a[i].sel = 1; Pre(); sort(a+1,a+m+1); int ltotal = 0; for (int i = 1; i &lt;= m; i++) &#123; if (ltotal == n - 1) break; int fax = getf(a[i].u),fay = getf(a[i].v); if (fax == fay) continue; fa[fax] = fay; ++ltotal; sell[++cnt] = i; &#125; for (int i = 1; i &lt;= cnt; i++) &#123; Pre(); int ret = 0; a[sell[i]].sel = 0; int lt = 0; for (int j = 1; j &lt;= m; j++) &#123; if (!a[j].sel) continue; if (lt == n - 1) break; int fax = getf(a[j].u),fay = getf(a[j].v); if (fax == fay) continue; fa[fax] = fay; ++lt; ret += a[j].c; &#125; if (lt == n - 1) ans = min(ans,ret); a[sell[i]].sel = 1; &#125; printf("%d\n",ans); return 0;&#125; （还能接受的）算法倍增LCA（似乎ST表也可以） + MST 定理:如果图G的边的个数E和个点的个数N不满足关系E + 1 = N,那么存在边(u,v) 属于 T 和(x, y)不属于T满足T \ (u, v) U (x, y)是图的一颗次小生成树. 根据这个定理,记录下原最小生成树中的边, 然后枚举它的邻边并尝试添入并删去环中（如果有）最长的边,取权值的最小值即可. 置于怎么求最小生成树中$X \ to \ Y$的最短距离,可以树形dp或者LCA. 辣鸡的我（拉拉板子）写了个倍增,跑的还行吧… LUOGU模板传送 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int SIZE = 1e5+10;vector&lt;int&gt;a[SIZE];int f[SIZE],fa[25][SIZE],dep[SIZE];int d[2][25][SIZE],n,m,ret,ans = LLONG_MAX,mx;bool used[SIZE &lt;&lt; 2],vis[SIZE];struct Edge&#123; int from,to,val; bool operator &lt; (const Edge y)&#123; return val &lt; y.val; &#125;&#125;e[SIZE&lt;&lt;2];inline int read(void) &#123; int x = 0,f = 1; char c = getchar(); while(!isdigit(c)) &#123; f = c == '-' ? -1 : 1; c = getchar(); &#125; while(isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * f;&#125;int F(int x)&#123;return x==f[x]?x:f[x]=F(f[x]);&#125; void kruskal() &#123; sort(e,e+m); int Lfs=n-1; for(int i=1; i&lt;=n; ++i) f[i]=i; for(int i=0; i&lt;m &amp;&amp; Lfs; ++i) &#123; int x=F(e[i].from),y=F(e[i].to); if(x!=y) &#123; f[x]=y;ret+=e[i].val;used[i]=1; --Lfs;mx=max(mx,e[i].val); &#125; &#125;&#125;void dfs(int x) &#123; vis[x]=true; for(int i=1; i&lt;=23; ++i) &#123; fa[i][x]=fa[i-1][fa[i-1][x]]; int t1=d[0][i-1][x], t2=d[0][i-1][fa[i-1][x]]; d[0][i][x]=max(t1 ,t2); d[1][i][x]=max(d[1][i-1][x] , d[1][i-1][fa[i-1][x]]); if(t1!=t2) d[1][i][x]=max(d[1][i][x] , min(t1 , t2)); &#125; for(int i=0; i&lt;a[x].size(); ++i) &#123; int t=e[a[x][i]].to+e[a[x][i]].from-x; if(vis[t]) continue; dep[t]=dep[x]+1; fa[0][t]=x; d[0][0][t]=e[a[x][i]].val; dfs(t); &#125;&#125;int lca(int u,int v) &#123; if(dep[u]&lt;dep[v]) swap(u,v); if(dep[u]!=dep[v]) &#123; for(int i=23,h=dep[u]-dep[v]; i&gt;=0; --i) if(h&amp;(1&lt;&lt;i)) u=fa[i][u]; &#125; if(u == v) return u; for(int i=23; i&gt;=0; --i) if(fa[i][u]!=fa[i][v]) u=fa[i][u] , v=fa[i][v]; return fa[0][u];&#125;int get(int u,int v,int c) &#123; int fht=lca(u,v); int m1=-1,m2=-1; for(int i=23,h1=dep[u]-dep[fht],h2=dep[v]-dep[fht]; i&gt;=0; --i) &#123; if(h1&amp;(1&lt;&lt;i)) &#123; if(d[0][i][u]&gt;m1) m2=m1,m1=d[0][i][u]; m2=max(m2 , d[1][i][u]); &#125; if(h2&amp;(1&lt;&lt;i)) &#123; if(d[0][i][v]&gt;m1) m2=m1,m1=d[0][i][v]; m2=max(m2 , d[1][i][v]); &#125; &#125; //严格大于的关键,这里若是return没有处理好极其容易被Hack if(m1!=c) return c-m1; if(m2!=-1) return c-m2; return 0; &#125;signed main(signed argc, char *argv[]) &#123; n = read(), m = read(); for(int i=0; i&lt;m; ++i) &#123; int u,v,w; u = read(),v = read(),w = read(); e[i]=(Edge)&#123;u,v,w&#125;; &#125; kruskal(); for(int i=0; i&lt;m; ++i) if(used[i]) &#123; a[e[i].from].push_back(i); a[e[i].to].push_back(i); &#125; dep[1]=1;dfs(1); for(int i=0; i&lt;m; ++i) if(!used[i]) &#123; if(e[i].val-mx&gt;ans) break; int t=get(e[i].from,e[i].to,e[i].val); if(t) ans=min(ans,t); &#125; printf("%lld\n",ret+ans); return 0;&#125; 听说好像有大爷还用LCT来维护这个X到Y的最大值,给跪了啊]]></content>
      <categories>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[资瓷新域名辣！欢迎使用karriganasta.xyz访问]]]></title>
    <url>%2F2018%2F05%2F03%2F%E8%B5%84%E7%93%B7%E6%96%B0%E5%9F%9F%E5%90%8D%E8%BE%A3%EF%BC%81%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8karriganasta-xyz%E8%AE%BF%E9%97%AE-md%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2018酱油记]]></title>
    <url>%2F2018%2F04%2F26%2FZJOI2018%E9%85%B1%E6%B2%B9%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[上次的游记好像忘了写了就当一起补上吧qwq 课件在这 Series 1 Series 2 ZJOI Day 1 Statement &amp; Solution ZJOI Day 2 Statement &amp; Solution ZJOI 2018 @ 衢州 2018.3.18-2018.3.21Day 0撞上体育中考好气哦不能搭大巴去啦,滚回杭州搞了一上午拿了30分满分.嗯资瓷啊. 下午就赶着火车飞到衢州去啦 到了宾馆卧槽还有电脑啊这么高端,然后似乎因为人数是奇数个,而且我又是最后一个到的.所以我一个人占了一个大床?!所以说到的迟还有福利?惊了. 晚上模板题敲敲人生大有希望. 睡觉前看了几集番,舒服. Day 1上午rxd大爷神级讲题,挑的都是CF我不根本不敢开的题,在线了一个小时左右就掉线了,我好菜啊. 中午衢州二中伙食怎么这么辣啊… 下午HEZ的陈嘉乐和陆宇暄网格图还挺有意思的.资瓷一波.但是感觉思考时间太少了啊啊啊. 晚上pogemo. Day 2上午绍一季雨田讲CF水题 结果不太听得懂,场内有个小哥好骚啊几乎每次都要上去 浪 切题. 真的是大到不行. 下午lych_cys梁大讲课!资瓷!JOIsc什么的太大了.后半程是真的听不动了. 晚上敲裸题+pogemo. PA查房真的神出鬼没 Day 3啊人生第一场省选(还是非正式选手).别爆零就行. 开场看T1. 花一个半小时撸出大暴力.诶!好像可以拿20分! 似乎再在20分基础上搞一下点点度数可以拿30分!又花了一个小时写那个10分. 看T2,数据结构题啊没信仰的,那个十分好像看起来挺好吃的. next_permutation()半小时写掉10分 看T3似乎是结论题… 暴力找规律两小时毫无卵用. 最后绝望之中srand(19260817) gg wp 赛后好像评测出锅了! 有人把我的编号占了! 所以全机房好像就我一个不知道自己几分! qnmd! 听说30分（20+10+0） ZJOI 2018 @ 衢州 2018.4.24-2018.4.26Day 0省选前机房好像都在切题啊,十分慌张,大爷们要进队了啊. (似乎没看到汪大和梁大) 下午似乎在爆Stupid OJ训练压行?! 罗大压行真的凶啊. 两点四十分PA来机房叫人啦. 出校门坐大巴车1H30min到酒店. 哇这次三人间! 一个大床加两个小床!其实是可以睡四个的,但是为了防止我们晚上玩♂游戏,所以就没有四人一间啦. 插口这么多我带个屁插线板啊 环境超好的!资瓷!枕头贼舒服!就是网络真的不稳健. 晚上po魔禁 Day 1上午学车cbh神仙讲题,好高端啊.不是很听的懂.姿势水平不够啊. 余姚中学午饭资瓷!小卖部居然被我们五分钟找到,震惊! 中午想找个篮球打但是找不到啊,余姚中学都没人把球藏灌木丛里的吗?震惊! 下午毛老师mjy来啦! 果然dls妹子就是好看 题目还挺友善的,不是开场就是毒瘤题,资瓷! 有道题好像刷出了ZJOCh的梗（ZJOI群里刷的）. 吐槽:有个小哥一直把那种蓝塑料凳子倒扣在自己头上然后站着撸代码,好大爷啊可就是挡着我看屏幕了. 毛老师后面的题有些不是很懂啊.. 晚上pogemo Day 2上午果然还是陈嘉乐和陆宇暄大爷的毒瘤讲题. 资瓷一波. 听不动啊集训队胡策是给人做的吗… 几乎全程掉线. 下午miaom讲课啊!资瓷!miaom讲课一直笑着帅死了啊! 可能还是听不太懂啊.QAQ 高校宣讲（撕b大会）好多人没来听啊,ckr和pc都走了.感觉第一次来省选开开眼界也好啊. （顺便下个决心） 果然D起来了,我看着浙大说自己计算机和软件应用都是A+而清北都没有. 结果我一翻手机看ACM-ICPC2018的Ranklist. 呀Zhejiang University似乎都倒数了.. 感觉没有对比就没有伤害啊… 中科大看上去挺高端的. THU和PKU讲的真的走心. 杭电的教练逗死我了他居然拿出了“包分配妹子”的杀器!震惊! 晚饭去万达吔麦,次了好多东西. skylee提议去游戏厅但是觉得玩娃娃机明天会WA WA机啊. 于是没去. 晚上不是很想po但还是po了一会儿. 睡得还算早吧,顺便理了下东西. 安. Day 3比上次感觉EZ一点啊,不过可能对我这种弱鸡还是暴力分写写. T1上来感觉不可做,写了个O(n!)的暴力居然花了一个小时!震惊!我菜死了! $N = 10$没过啊,难过!我常数这么挫的? 出来似乎连暴力也写错了?! GCC314暴力和boom手算结果一样?! 药丸.祈祷$N = 5$的时候我是对的啊.QAQ T2可能写了个假算法……不知道为什么感觉上午毫无码力啊. (我怎么感觉我好像提交文件时候出锅了) UPD : 似乎真的出锅了. 凉凉 T3算几弃坑.rand()一发完事. 要爆蛋啦Day2! 滚回去提高姿势水平! ZJOI2019再战! ​ Edited By karriganasta ​ 2018.04.26 ​]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「模板」常用板子]]></title>
    <url>%2F2018%2F04%2F12%2F%E3%80%8C%E6%A8%A1%E6%9D%BF%E3%80%8D%E5%B8%B8%E7%94%A8%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[终于是感觉东西多了要腾个地方出来挂板子了 To be continued… 顺便置顶一波 板子全家桶 字符串 AC Automaton非指针 AC Automaton kmp Trie 数学 CRT Extended Euclid FFT递归 FFT迭代 NTT模费马质数 NTT任意模 多项式求逆 SG函数 矩阵乘法&amp;快速幂 数论函数线筛 线筛乘法逆元 图论 LCA MST-Kruskal SPFA 数据结构 Scapegoat替罪羊树 并查集 Splay区间反转文艺平衡树 Treap 线段树区间操作 树状数组FenwickTree 杂 Fast IO 1 Fast IO 2 快速幂 三分法 三维偏序CDQ分治]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HR(HackerRank)」斯波题切题记]]></title>
    <url>%2F2018%2F04%2F10%2F%E3%80%8CHR-HackerRank-%E3%80%8D%E6%96%AF%E6%B3%A2%E9%A2%98%E5%88%87%E9%A2%98%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[引言切了一波斯波题hjq素质不能更差随便玩玩,还是有点收获的吧.. K Candy StoreLinks there:HR-K Candy Store 大意:有N个人,分不同的K种糖果,各个糖果可以选无数个,求方案数. solution:典型的插板法.答案为$C(n+m-1,n-1)$ 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int mod = 1e9; int T,n,m,C[5003][5003];inline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;signed main(signed argc, char *argv[])&#123; for (int i = 0; i &lt;= 5000; i++) for (int j = 0; j &lt;= i; j++) &#123; if (i == j || i == 0) C[i][j] = 1; else C[i][j] = (C[i-1][j-1]+C[i-1][j]) % mod; &#125; T = read(); while(T--) &#123; int n = read(), m = read(); printf("%lld\n",C[n+m-1][n-1]); &#125; return 0;&#125; Special MultipleLinks there:HR-Special Multiple 大意:给出一个N,求最小的只由0,9组成的数字串使得其为给定N的倍数.$N \leq 500$ solution: 考虑01串二进制的转换,[1,2,3,4] $-&gt;$ [1,10,11,100]当我们把右边乘9即可得到0-9串. 逐位构造即可. 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longlong long binar(long long n) &#123; if (n == 1) return 1LL; if (n &amp; 1) return 1LL * 10*binar(n/2)+1; else return 1LL * 10*binar(n/2);&#125;signed main(signed argc, char *argv[]) &#123; int t; cin&gt;&gt;t; while(t--) &#123; long long n,a=1,b=9; cin&gt;&gt;n; while(b % n) &#123; a++; b = binar(a); b *= 9; &#125; cout&lt;&lt;b&lt;&lt;endl; &#125; return 0;&#125; 感觉和SOJ上马三的二进制数一题很像.而且似乎加个高精就可以A掉. 当时本蒟蒻做这题还用的dp哈哈. Matrix RacingLinks there:HR-Matrix Racing 大意:给出一个$N \times M$的矩阵,求从左上角$(1,1)$到右下角$(N,M)$的方案数 变相的杨辉三角. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int mod = 1e9+7; int T,n,m,jc[2000010];int quickpow(int m,int n)&#123; int b = 1; while(n) &#123; if (n &amp; 1) b = b * m % mod; n /= 2; m = m * m % mod; &#125; return b;&#125;int C(int n,int r)&#123; int i1 = quickpow(jc[n-r],mod-2); int i2 = quickpow(jc[r],mod-2); int ret = 1LL * i1 * i2 % mod * jc[n] % mod; return ret;&#125;inline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;signed main(signed argc, char *argv[])&#123; jc[0] = 1; for (int i = 1; i &lt;= 2000004; i++) jc[i] = 1LL * jc[i-1] * i % mod; T = read(); while(T--) &#123; int n = read(), m = read(); printf("%lld\n",C(n+m-2,n-1)); &#125; return 0;&#125; 剩下的好像都挺傻逼的就不写题面了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Sherlock和约数#include&lt;bits/stdc++.h&gt;using namespace std;int t,n;inline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;int main(int argc, char *argv[])&#123; t = read(); while(t--) &#123; n = read(); int ans = 0; for (int i = 1; i &lt;= sqrt(n+0.5); i++) if (!(n % i)) &#123;if(!(i%2))++ans; if(i*i == n) continue; if(!((n/i)%2)) ++ans;&#125; printf("%d\n",ans); &#125; return 0;&#125;//Diwali Lights#include&lt;bits/stdc++.h&gt;const int mod = 1e5;const int maxn = 1e4;using namespace std;int T,n;inline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;int main(int argc, char *argv[])&#123; int T = read(); while(T--) &#123; int n = read(),prod = 1; for (int i = 0; i &lt; n; i++) prod *= 2,prod %= mod; prod = ((prod-1) % mod + mod) % mod; printf("%d\n",prod); &#125; return 0;&#125;//Summing N Series#include&lt;bits/stdc++.h&gt;using namespace std;int T;long long n;const int mod = 1e9+7;int main(int argc, char *argv[])&#123; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; n; n %= mod; n = n * n % mod; cout &lt;&lt; n &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>HackerRank</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[奇技淫巧] bitset大法吼啊]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-bitset%E5%A4%A7%E6%B3%95%E5%90%BC%E5%95%8A%2F</url>
    <content type="text"><![CDATA[前言bitset不止一次听大爷们安利过了… 似乎 挺厉害的.因为bool数组在用的时候只能够用一个byte但是byte有8个bit,0/1只要1个就够了.. 所以浪费了7个bit. Reference: bitset/zh-cpp-reference bitset/cppcontainer hfq is so toxic.! 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#include&lt;bitset&gt;using namespace std;int main(int argc, char *argv[])&#123; //正常的构造 bitset&lt;8&gt;a(42); //[0,0,1,0,1,0,1,0] cout &lt;&lt; a &lt;&lt; endl; bitset&lt;70&gt;b(LLONG_MAX); cout &lt;&lt; b &lt;&lt; endl; //字符串string构造 string bit_s = "110010"; bitset&lt;8&gt;c(bit_s); cout &lt;&lt; c &lt;&lt; endl; // bitset&lt;sz&gt;b(bit_string,x,(y)); bitset&lt;8&gt;d(bit_s,2); //字符串的第 x+1(下标为x)个及之后的甩进bitset. cout &lt;&lt; d &lt;&lt; endl; bitset&lt;8&gt;e(bit_s,0,3); //字符串的第 x+1(下标为x) 及共y个甩进bitset. cout &lt;&lt; e &lt;&lt; endl; // string的自定义构造0,1串 string bit_as = "HHHJJJHHJH"; bitset&lt;10&gt;f(bit_as,0,bit_as.size(),'H','J'); //把H设为0，J设为1,如果出现了其他的字符就返回错误 cout &lt;&lt; f &lt;&lt; endl; return 0;&#125; Atcoder Grand Contest AGC 020 C Median SumAGC 020C 水题(我还是不会做) 用bitset维护一个类似背包的东西.. 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int n,ret = 0;bitset&lt;4000010&gt;f;inline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x*f;&#125;int main(int argc, char *argv[])&#123; n = read(); f[0] = 1; while(n--) &#123; int x = read(); f = f|(f&lt;&lt;x); ret += x; &#125; int i; for (i = (ret+1)/2; !f[i]; i++); cout &lt;&lt; i; return 0;&#125;]]></content>
      <categories>
        <category>bitset</category>
      </categories>
      <tags>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Treap/Splay/Scapegoat 学习笔记&板子]]></title>
    <url>%2F2018%2F03%2F28%2FTreap-Splay-Scapegoat-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[Treap/Splay/Scapegoat板子 全指针 毕竟指针好写好调（虽然占多了点M Treap(LUOGU P3369/BZOJ 3224可食用)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// m 操作有m个// 1 x 插入元素x// 2 x 删除元素x。如果成功，输入1，否则输出0// 3 k 输出值x的“名次”，即比x小的结点个数加1// 4 x 第k小元素。k=1为最小元素// 5 x prefix of x// 6 x suffix of x// ... to be continued ...#include&lt;bits/stdc++.h&gt;using namespace std;struct Node &#123; Node *ch[2]; // 左右子树 int r; // 随机优先级 int v; // 值 int s; // 结点总数 Node(int v = 0):v(v) &#123; ch[0] = ch[1] = NULL; r = rand(); s = 1; &#125; int cmp(int x) const &#123; if (x == v) return -1; return x &lt; v ? 0 : 1; &#125; void maintain() &#123; s = 1; if(ch[0] != NULL) s += ch[0]-&gt;s; if(ch[1] != NULL) s += ch[1]-&gt;s; &#125;&#125;;void rotate(Node* &amp;o, int d) &#123; Node* k = o-&gt;ch[d^1]; o-&gt;ch[d^1] = k-&gt;ch[d]; k-&gt;ch[d] = o; o-&gt;maintain(); k-&gt;maintain(); o = k;&#125;void insert(Node* &amp;o, int x) &#123; if(o == NULL) o = new Node(x); else &#123; int d = (x &lt; o-&gt;v ? 0 : 1); insert(o-&gt;ch[d], x); if(o-&gt;ch[d]-&gt;r &gt; o-&gt;r) rotate(o, d^1); &#125; o-&gt;maintain();&#125;Node* find(Node* o, int x) &#123; if(o == NULL) return NULL; if(x == o-&gt;v) return o; return x &lt; o-&gt;v ? find(o-&gt;ch[0], x) : find(o-&gt;ch[1], x);&#125;void remove(Node* &amp;o, int x) &#123; int d = o-&gt;cmp(x); if(d == -1) &#123; Node* u = o; if(o-&gt;ch[0] != NULL &amp;&amp; o-&gt;ch[1] != NULL) &#123; int d2 = (o-&gt;ch[0]-&gt;r &gt; o-&gt;ch[1]-&gt;r ? 1 : 0); rotate(o, d2); remove(o-&gt;ch[d2], x); &#125; else &#123; if(o-&gt;ch[0] == NULL) o = o-&gt;ch[1]; else o = o-&gt;ch[0]; delete u; &#125; &#125; else remove(o-&gt;ch[d], x); if(o != NULL) o-&gt;maintain();&#125;int kth(Node* o, int k) &#123; if(o == NULL || k &lt;= 0 || k &gt; o-&gt;s) return 0; int s = (o-&gt;ch[0] == NULL ? 0 : o-&gt;ch[0]-&gt;s); if(k == s+1) return o-&gt;v; else if(k &lt;= s) return kth(o-&gt;ch[0], k); else return kth(o-&gt;ch[1], k-s-1);&#125;int rank(Node* o, int x) &#123; if(o == NULL) return 1; if(x &lt;= o-&gt;v) return rank(o-&gt;ch[0], x); return rank(o-&gt;ch[1], x) + (o-&gt;ch[0] == NULL ? 0 : o-&gt;ch[0]-&gt;s) + 1;&#125;int prefix(Node *o, int k,int c) &#123; if (o == NULL) return c; if (k &gt; o-&gt;v) return prefix(o-&gt;ch[1],k,o-&gt;v); else return prefix(o-&gt;ch[0],k,c);&#125;int suffix(Node *o, int k,int c) &#123; if (o == NULL) return c; if (k &lt; o-&gt;v) return suffix(o-&gt;ch[0],k,o-&gt;v); else return suffix(o-&gt;ch[1],k,c);&#125;const int INF = INT_MAX &gt;&gt; 1;/*void dfs(Node *o)&#123; if (o == NULL) return ; printf("%d\n",o-&gt;v); printf("LC of %d:\n",o-&gt;v);dfs(o-&gt;ch[0]); printf("RC of %d:\n",o-&gt;v); dfs(o-&gt;ch[1]); printf("EO %d!\n\n",o-&gt;v); &#125;*/int main(int argc, char *argv[]) &#123; srand(int(time(NULL))); int m, c, v; Node* root = new Node(INF); scanf("%d", &amp;m); while(m--) &#123; scanf("%d%d", &amp;c, &amp;v); if(c == 1) insert(root, v); else if(c == 2) &#123; Node* o = find(root, v); if(o != NULL) remove(root, v); &#125; else if(c == 3) printf("%d\n", rank(root, v)); else if(c == 4) printf("%d\n", kth(root,v)); else if(c == 5) printf("%d\n",prefix(root,v,0)); else printf("%d\n",suffix(root,v,0)); &#125; return 0;&#125; Splay(LUOGU P3391/BZOJ 3223可食用)(好像叫Spaly的也有 大雾) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5+10; struct Node &#123; Node* ch[2]; int v,s,flip; int cmp(int k) &#123; int d=k-ch[0]-&gt;s; if(d==1) return -1; return d&lt;=0? 0:1; &#125; void maintain() &#123; s=ch[0]-&gt;s+ch[1]-&gt;s+1; &#125; void pushdown() &#123; if(flip) &#123; flip=0; swap(ch[0],ch[1]); ch[0]-&gt;flip^=1; ch[1]-&gt;flip^=1; &#125; &#125;&#125;;Node* null=new Node();void rotate(Node* &amp;o,int d) &#123; Node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o-&gt;maintain(),k-&gt;maintain(); o=k;&#125;void splay(Node* &amp;o,int k) &#123; o-&gt;pushdown(); int d=o-&gt;cmp(k); if(d==1) k-=o-&gt;ch[0]-&gt;s+1; if(d!=-1) &#123; Node* p=o-&gt;ch[d]; p-&gt;pushdown(); int d2=p-&gt;cmp(k); int k2=d2==0? k:k-p-&gt;ch[0]-&gt;s-1; if(d2!=-1) &#123; splay(p-&gt;ch[d2],k2); if(d==d2) rotate(o,d^1); else rotate(o-&gt;ch[d],d); &#125; rotate(o,d^1); &#125;&#125;Node* merge(Node* left,Node* right) &#123; splay(left,left-&gt;s); left-&gt;ch[1]=right,left-&gt;maintain(); return left;&#125;void split(Node* o,int k,Node* &amp;left,Node* &amp;right) &#123; splay(o,k); left=o,right=left-&gt;ch[1],left-&gt;ch[1]=null; left-&gt;maintain();&#125;struct SplaySequence &#123; int n; Node seq[maxn]; Node* root; Node* build(int sz) &#123; if(!sz) return null; Node* l=build(sz/2); Node* o=&amp;seq[++n]; o-&gt;v=n; o-&gt;ch[0]=l; o-&gt;ch[1]=build(sz-sz/2-1); o-&gt;flip=o-&gt;s=0; o-&gt;maintain(); return o; &#125; void init(int sz) &#123; n=null-&gt;s=0; root=build(sz); &#125;&#125; spaly;vector&lt;int&gt; ans;void print(Node* o) &#123; if(o!=null) &#123; o-&gt;pushdown(); print(o-&gt;ch[0]); ans.push_back(o-&gt;v); print(o-&gt;ch[1]); &#125;&#125;int read() &#123; char c=getchar(); while(!isdigit(c)) c=getchar(); int x=0; while(isdigit(c)) &#123; x=x*10+c-'0'; c=getchar(); &#125; return x;&#125;int n,m;int main(int argc, char *argv[]) &#123; n=read(),m=read(); spaly.init(n+1); int l,r; Node *left,*right,*mid; while(m--) &#123; l=read(),r=read(); split(spaly.root,l,left,right); split(right,r-l+1,mid,right); mid-&gt;flip^=1; spaly.root = merge(merge(left,mid),right); &#125; print(spaly.root); for(int i=1; i&lt;ans.size(); i++) printf("%d ",ans[i]-1); return 0;&#125; Scapegoat(LUOGU P3369/BZOJ 3224可食用)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;#include&lt;vector&gt;using namespace std;const double alpha=0.7;struct scapegoat&#123; scapegoat *l,*r; int val,size,cnt; bool deleted; bool is_bad()&#123;return (l-&gt;cnt &gt; alpha*cnt+5 || r-&gt;cnt &gt; alpha*cnt+5);&#125; void maintain()&#123;size=!deleted+l-&gt;size+r-&gt;size; cnt=1+r-&gt;cnt+l-&gt;cnt;&#125;&#125;;scapegoat *null;void dfs(scapegoat *o,vector&lt;scapegoat*&gt; &amp;v)&#123; if(o == null) return; dfs(o-&gt;l,v); if(!o-&gt;deleted) v.push_back(o); dfs(o-&gt;r,v); if(o-&gt;deleted) delete o;&#125;scapegoat *build(vector&lt;scapegoat*&gt; &amp;v,int l,int r)&#123; if(l &gt;= r) return null; int mid = (l+r) &gt;&gt; 1; scapegoat *o = v[mid]; o-&gt;l = build(v,l,mid); o-&gt;r = build(v,mid+1,r); o-&gt;maintain(); return o;&#125;void rebuild(scapegoat* &amp;o)&#123; vector&lt;scapegoat*&gt; v; dfs(o,v); o = build(v,0,v.size());&#125;void insert(int x,scapegoat* &amp;o)&#123; if(o==null) &#123; o=new scapegoat; o-&gt;l=o-&gt;r=null; o-&gt;deleted=false; o-&gt;size=o-&gt;cnt=1; o-&gt;val=x; return; &#125; else &#123; ++o-&gt;size; ++o-&gt;cnt; if(x&gt;=o-&gt;val) insert(x,o-&gt;r); else insert(x,o-&gt;l); if(o-&gt;is_bad())rebuild(o); &#125;&#125;int rank(scapegoat *now,int x) &#123; int ans=1; while(now!=null) &#123; if(now-&gt;val&gt;=x)now=now-&gt;l; else &#123; ans+=now-&gt;l-&gt;size+!now-&gt;deleted; now=now-&gt;r; &#125; &#125; return ans; &#125;int kth(scapegoat *now,int x)&#123; while(now!=null) &#123; if(!now-&gt;deleted &amp;&amp; now-&gt;l-&gt;size+1==x) return now-&gt;val; if(now-&gt;l-&gt;size&gt;=x)now=now-&gt;l; else &#123; x-=now-&gt;l-&gt;size+!now-&gt;deleted; now=now-&gt;r; &#125; &#125;&#125;void erase(scapegoat *o,int rk)&#123; if(!o-&gt;deleted &amp;&amp; rk==o-&gt;l-&gt;size+1) &#123; o-&gt;deleted=1; --o-&gt;size; return; &#125; --o-&gt;size; if(rk&lt;=o-&gt;l-&gt;size+!o-&gt;deleted) erase(o-&gt;l,rk); else erase(o-&gt;r,rk-o-&gt;l-&gt;size-!o-&gt;deleted);&#125;inline void read(int &amp;a)&#123; int negativ = 1; a = 0; char c = getchar(); while(!isdigit(c))&#123;if(c == '-') negativ = -1; c = getchar();&#125; while(isdigit(c)) &#123;a = a*10+c-'0';c = getchar();&#125; a *= negativ;&#125;scapegoat *root;int main(int argc, char *argv[])&#123; null = new scapegoat; root = null; int n; read(n); while(n--) &#123; int op,x; read(op); read(x); if(op==1)insert(x,root); if(op==2)erase(root,rank(root,x)); if(op==3)printf("%d\n",rank(root,x)); if(op==4)printf("%d\n",kth(root,x)); if(op==5)printf("%d\n",kth(root,rank(root,x)-1)); if(op==6)printf("%d\n",kth(root,rank(root,x+1))); &#125; return 0; &#125;]]></content>
      <categories>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Regular Contest arc 091-092 切(W)题(A)记]]></title>
    <url>%2F2018%2F03%2F27%2FAtcoder-Regular-Contest-arc-091-092-%E5%88%87-W-%E9%A2%98-A-%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[概述上午闲着没事就找了点Atcoder的（水）题切切, 顺便过一下博弈和SG函数。 Atcoder Regular Contest 091 C Flip,Flip,and FlipARC 091C 問題文 縦横に無限に広がるマス目があり、そのうちの連続する N 行 M 列の領域のすべてのマスに表裏の区別できるカードが置かれています。 最初はすべてのカードが表を向いています。 以下の操作を、カードが置かれている全てのマスについて 1 度ずつ行います。 そのマスと辺または点で接する 8 つのマスと、そのマスの合計 9 マスについて、カードが存在するなら裏返す。 すべての操作を行った後の各カードの状態は操作を行う順番に依らないことが証明できます。 すべての操作を行った後、裏を向いているカードの枚数を求めてください。 大意 问题陈述有无限长度和宽度的正方形展开，并且可以区分正面和背面的牌被放置在连续的n行和m列中的所有单元中。最初所有牌都面朝桌子。对于放置卡的每个方块执行一次以下操作。如果有8个方格邻接那个正方形和边或者点，并且如果有一张卡，则总共9个方格。您可以证明执行所有操作后每张卡的状态不取决于操作顺序。完成所有操作后，请找到背面的卡片数量。 注意细节特判1,1的情况. 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longinline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;signed main(signed argc, char *argv[])&#123; int n = read(), m = read(); if (n == 1 &amp;&amp; m == 1) printf("1\n"); else if (n == 1) printf("%lld\n",m-2); else if (m == 1) printf("%lld\n",n-2); else printf("%lld\n",n*m-(n+m)*2+4); return 0;&#125; Atcoder Regular Contest 091 D Remainder ReminderARC 091D 問題文高橋君は、N 以下の正の整数の 2 つ組 (a,b) を持っていましたが、忘れてしまいました。 高橋君は、a を b で割ったあまりが K 以上であったことを覚えています。 高橋君が持っていた組としてあるうるものの個数を求めてください。 制約 1≤N≤105 0≤K≤N−1 入力は全て整数である 大意 给出限制$N,K$,求满足 a,b \leq N,令a\equiv x(mod \space b),K\leq x\leq b-1的方案数考虑b的范围为$[K+1,N]$ 直接枚举b,然后算出对应范围下的$x$个数，但是注意xmax后有一部分剩余. 注意细节。（我特么WA了两次啊真彩笔） 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longinline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;signed main(signed argc, char *argv[])&#123; int ans = 0; int N = read(),K = read(); if (K == 0) &#123; N *= N; cout &lt;&lt; N; return 0; &#125; for (int b = K+1; b &lt;= N; b++) &#123; int xmax = (N)/(b); //cout &lt;&lt; xmax &lt;&lt; " # " &lt;&lt; "\n"; ans += xmax * (b-K); ans += max(0LL,(N - b * xmax) - K + 1); //cout &lt;&lt; ans &lt;&lt; endl; &#125; cout &lt;&lt; ans; return 0;&#125; Atcoder Regular Contest 091 F Strange NimARC 091F 問題文高橋君と青木君は、石取りゲームをしています。最初、山が N 個あり、i 個目の山には A**i 個の石があり、整数 K**i が定まっています。 高橋君と青木君は、高橋君から始めて、交互に以下の操作を繰り返します。 山を 1 つ選ぶ。i 個目の山を選び、その山に X 個の石が残っている場合、1 個以上 floor(X⁄K**i) 個以下の任意の個数の石を i 個目の山から取り除く。 先に操作ができなくなったプレイヤーが負けです。両者最善を尽くしたとき、どちらのプレイヤーが勝つか判定してください。 ただし、floor(x) で x 以下の最大の整数を表します。 大意: 给n堆石子，每堆有一开始有ai个和一个常数ki。两个人轮流操作，每个人每轮可以选一堆石子，然后在其中取走1到$\large\frac{a_i}{k_i}$,谁不能操作就算输，问先手必胜还是后手必胜。 SG函数+暴力 不难发现SG函数递推式$SG(x) = SG(x-x/k-1)$ 因为每一次k都是恒等的，考虑直接一步用取模跳到就行，不然T飞。 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 210;string s1 = "Takahashi",s2 = "Aoki";inline int read(void)&#123; int x = 0,f = 1; char ch = cin.get(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = cin.get();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = cin.get();&#125; return x * f;&#125;int main(int argc, char *argv[])&#123; ios::sync_with_stdio(false); int n = read(); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int x = read() , k = read(); while((x%k)) x -= ((x%k-1)/(x/k+1)+1) * (x/k+1); ans ^= x/k; &#125; if (ans) cout &lt;&lt; s1; else cout &lt;&lt; s2; return 0;&#125;]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成函数学习笔记[干货]]]></title>
    <url>%2F2018%2F03%2F09%2F%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B9%B2%E8%B4%A7%2F</url>
    <content type="text"><![CDATA[概论生成函数算是一种既简单又有用的数学方法,一般用来解决组合技术问题,而且是一种最重要的一般性处理方法. 填完坑再划 主要参考资料:&lt;组合数学引论(中科大)&gt; 引论对于一个有限数列或者无限数列 \{ a_0,a_1,a_2,... \}我们用幂级数 A(x) = a_0+a_1x+a_2x^2+...\\\\ =\sum_{i=0}^{\infty}a_ix^i来使之为一个整体，我们相当于用这样的一个我们自己构造出来的函数去研究整个函数的性质。 而不必单个地研究.特别地,我们把$A(x)$称为该序列的生成函数,记为$G{a_n }$. 对于特殊情况比如组合数列 \{ \binom{n}{0}\binom{n}{1},\cdot\cdot\cdot,\binom{n}{n}\}根据上述的定义,令其生成函数为$f_n(x)$,则有 f_n(x)=\binom{n}{0}+\binom{n}{1}x+\cdot\cdot\cdot+\binom{n}{n}x^n由二项式定理不难得到 f_n(x)=(1+x)^n那么就可以对这个玩意进行单独研究了比如我们假设要求 ​ \sum_{i=0}^n\binom{n}{i}实际上就是$x=1$的情况.代入后就是$2^n$. 或者再比如求 \sum_{i=1}^ni\binom{n}{i}\\\\hjq瞬间用组合意义秒掉.%%%%% 这个式子,相当于在$n$个球中选出$i$个并且给之中的一个染色的数量 那么先染一个再选择显然是等价的.所以就是下面的式子了. 用二项式的话用容斥原理不难得到 \sum_{i=1}^ni\binom{n}{i}\\\\ =n \times 2^{n-1}由恒等式 (1+x)^{m+n}=(1+x)^m(1+x)^n\\\\ \longrightarrow\space\binom{m+n}{r} = \sum_{k=0}^r\binom{m}{k}\binom{n}{r-k}好了上面都是玩泥巴~~ 例1丢一个栗子 假设你有一个正常的骰子（六个面的那种），且掷出每个面的概率近似认为相等（$\frac{1}{6}$）. 连续丢出两次,问掷出和为10的概率为多少？ 答:你怕不是个zz吧,这么简单的问题你也敢问？ 好,连续丢出十次,问掷出和为30的概率为多少？ 没话说了吧 解： 用生成函数的思想来，把每一个和看作关于点数(1,2,3,4,5,6)的多项式乘积. 也就是$x+x^2+x^3+x^4+x^5+x^6$. 那么,关于第二个问题,转换为 (x+x^2+x^3+x^4+x^5+x^6)^{10}上述这个式子中,问你$x^{30}$的系数。 还是很难做对不对,考虑化简 (x+x^2+x^3+x^4+x^5+x^6)^{10}\\\\ =(x(1+x+x^2+x^3+x^4+x^5))^{10}\\\\ 发现x=-1是原式因式.\\\\ 一顿大除法.\\\\ \longrightarrow\space =[(x^2+x+1)(x^2-x+1)]^{10}\times x^{10} \times (x+1)^{10}好的我们头皮发麻而且发现这个式子对我们最终计算$x^{30}$的系数没有任何的卵用. 为什么？因为我们不会三项式展开，但是如果不进行因式分解项数肯定会更大我们更不会算！ 考虑反过来,如果把原式写成两个二项式的商也可以. (1+x+x^2+x^3+x^4+x^5)\\\\ =\frac{(1-x^6)}{1-x}\\\\ 那么原来的式子(x+x^2+x^3+x^4+x^5+x^6)^{10}\\\\ =x^{10}(1-x^6)^{10}(1-x)^{-10}\\\\扔上二项式定理\\\\ 又因为10次是偶数次,(1-x^6)写成(x^6-1)，后面的同理\\\\ \rightarrow x^{10}\times\sum_{i=0}^{10}(-1)^i\binom{10}{i}x^{6i}\times\sum_{k=0}^{\infty}\binom{10+k-1}{k}x^k好了把前面的$x^{10}$扔掉后面的构造出i,k满足x的次数为20就行辣. 一共i只可能取0,1,2,3枚举就行. 答案似乎长这个样子 \binom{29}{20}-\binom{10}{1}\binom{23}{14}+\binom{17}{8}\binom{10}{2}-\binom{10}{3}\binom{11}{2}反正我是懒得算答案了. 生成函数的性质生成函数的形式导数定义 \forall A(x)=\sum_{k=0}^{\infty}a_kx^k \in R[[x]]\\\\ 定义DA\equiv\sum_{k=1}^{\infty}ka_kx^{k-1}\\\\ 称作A(x)在R[[x]]上的形式导数.形式导数的运算法则和普通导数差不多. 加法则乘法则都满足的.但是似乎没有对链导法则的定义. 生成函数主要常用性质]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI-2012] 喵星球上的点名 AC自动姬+map]]></title>
    <url>%2F2018%2F03%2F08%2FSCOI-2012-%E5%96%B5%E6%98%9F%E7%90%83%E4%B8%8A%E7%9A%84%E7%82%B9%E5%90%8D-AC%E8%87%AA%E5%8A%A8%E5%A7%AC-map%2F</url>
    <content type="text"><![CDATA[题面BZOJ-2754 分析直接暴力对每个串开个map建AC自动姬. 写起来其实不难的,思维难度也不是很高.主要的技巧在于常数的处理. 看上去空间爆炸但是居然过了!! LUOGU好像加了一组恶心数据卡掉了这种辣鸡做法 好吧其实正解好像要用到主席树可惜我还不会. 菜啊 qwq 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+4;#define RG registerinline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x*f;&#125;int n,m,ans1[maxn],ans2[maxn];vector&lt;int&gt;a[maxn&lt;&lt;1],status[maxn],V,M;bool vis[maxn],mk[maxn];map&lt;int,int&gt;to[maxn];map&lt;int,int&gt;::iterator it;struct Aho_Corasick&#123; int cnt,ans; int fail[maxn],q[maxn]; Aho_Corasick() &#123; cnt = 1; for (RG int i = -1; i &lt;= 1e4; i++) to[0][i] = 1; fail[1] = 0; &#125; void Insert(int id) &#123; int L = read(),nn = 1; for (RG int i = 1; i &lt;= L; i++) &#123; int x = read(); if (!to[nn][x]) to[nn][x]=++cnt; nn = to[nn][x]; &#125; status[nn].push_back(id); &#125; void build_fail() &#123; queue&lt;int&gt;q; q.push(1); while(!q.empty()) &#123; int tmp = q.front(); q.pop(); for (it = to[tmp].begin(); it != to[tmp].end(); it++) &#123; int t1 = it-&gt;first,t2 = it-&gt;second; int k = fail[tmp]; //printf("%d %d %d\n",t1,t2,k); while(!to[k][t1]) k = fail[k]; fail[t2] = to[k][t1]; q.push(t2); &#125; &#125; &#125; void get(int id,int x) &#123; for (RG int i = x; i != 0; i = fail[i]) if (!vis[i]) &#123; vis[i] = 1; V.push_back(i); for (RG int j = 0; j &lt; status[i].size(); j++) &#123; if (!mk[status[i][j]]) &#123; mk[status[i][j]] = 1; M.push_back(status[i][j]); ans1[status[i][j]] ++; ans2[id]++; &#125; &#125; &#125; else break; &#125; void sett(void) &#123; for (RG int i = 0; i &lt; V.size(); i++) vis[V[i]] = 0; for (RG int i = 0; i &lt; M.size(); i++) mk[M[i]] = 0; V.clear(); M.clear(); &#125; void solve(int x) &#123; int nn = 1; for (RG int i = 0; i &lt; a[x].size(); i++) &#123; int t = a[x][i]; while(!to[nn][t]) nn = fail[nn]; nn = to[nn][t]; get(x,nn); &#125; sett(); &#125;&#125;AC;int main(int argc, char *argv[])&#123; n = read(); m = read(); int L,x; for(RG int i=1;i&lt;=n;i++) &#123; L=read(); while(L--)x=read(),a[i].push_back(x); a[i].push_back(-1); L=read(); while(L--)x=read(),a[i].push_back(x); &#125; for(RG int i=1;i&lt;=m;i++) AC.Insert(i); AC.build_fail (); for(RG int i=1;i&lt;=n;i++) AC.solve(i); for(RG int i=1;i&lt;=m;i++)printf("%d\n",ans1[i]); for(RG int i=1;i&lt;=n;i++) &#123; printf("%d",ans2[i]); if (i != n) putchar(' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU-3746] Cyclic Necklace KMP找循环]]></title>
    <url>%2F2018%2F03%2F08%2FHDU-3746-Cyclic-Necklace-KMP%E6%89%BE%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[题面HDU-3746 大意:求出添加尽可能少的字符数量使得原串成为循环串. 比如abca-&gt;abcabc要2个字符. 分析KMP找循环节!fail数组的巧用 比如说题目中这样的串abca的fail数组为[0,0,0,1].也就是说最后一位为1其他均为0. 我们根据fail数组的定义就很容易推出答案 1.如果fail[len]为0,也就是说没有任何的匹配.就是原字符串长度. 2.如果fail[len]不为0,我们用len-fail[len]得到一个循环节.然后如果这个循环节是len的因子.也就是恰好出现了循环.那么不要添加任何的字符,return 0.否则返回该添加的量.也就是循环长度减去存在的残缺循环长度 具体代码说明一切. 代码12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;char s[100010];int fail[100010];int kmp(char *b,int nb)&#123; memset(fail,0,sizeof(fail)); for (int i = 2; i &lt;= nb; i++) &#123; int j = fail[i-1]; while(j != 0 &amp;&amp; b[j+1] != b[i]) j = fail[j]; if (b[j+1] == b[i]) fail[i] = j+1; else fail[i] = 0; &#125; if (fail[nb] == 0) return nb; int t = nb - fail[nb]; if (nb % t == 0) return 0; return (t-nb%t); &#125;int main(int argc, char *argv[])&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%s",s+1); printf("%d\n",kmp(s,strlen(s+1))); &#125; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI-2011|BZOJ-2434] Ahri's Printer 阿狸的打字机 Fenwick树+AC自动姬]]></title>
    <url>%2F2018%2F03%2F08%2FNOI-2011-BZOJ-2434-Ahri-s-Printer-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA-Fenwick%E6%A0%91-AC%E8%87%AA%E5%8A%A8%E5%A7%AC%2F</url>
    <content type="text"><![CDATA[题面BZOJ-2434 分析毒瘤题. 1.先考虑暴力的做法,对于每一个读进来的匹配串都建立一次AC自动d姬. 100%爆炸不加辣.似乎只能拿40分. 2.我们可以考虑出现重复计算的地方.有很大一部分的失配数组其实是没有变化的.但是我们无脑地把它破坏掉再重新建立起来,这部分的损耗很大.考虑优化中间的fail数组,我们在找适配节点的时候是不是只要往上面跳.插入这个节点的父节点就可以啦？做的时候记得大法师一遍. 这样拿70~80分. 3.在2的基础上加一个树状数组就行辣. 100分标算 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;using namespace std;const int SIZE = 1e5+5;inline int read()&#123; int x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x;&#125;int n,m,cnt,T,l[SIZE],r[SIZE],t[200005];int last[SIZE],lastq[SIZE],pos[SIZE],ans[SIZE];char ch[SIZE];struct fail_tree&#123; int to,next,v;&#125;e[SIZE],que[SIZE];inline void add(int x,int val)&#123;for(int i=x;i&lt;=T;i+=i&amp;-i)t[i]+=val;&#125;inline int query(int x)&#123;int sum=0;for(int i=x;i;i-=i&amp;-i)sum+=t[i];return sum;&#125;void insert(int u,int v)&#123;e[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;&#125;struct Aho_Corasick&#123; int cnt; int fa[SIZE],fail[SIZE],next[SIZE][26],q[SIZE]; Aho_Corasick()&#123; cnt=1; for(int i=0;i&lt;26;i++) next[0][i]=1; &#125; void build()&#123; int now=1,id=0; for(int i=0;i&lt;n;i++) if(ch[i]=='P')pos[++id]=now; else if(ch[i]=='B')now=fa[now]; else &#123; if(!next[now][ch[i]-'a']) &#123; next[now][ch[i]-'a']=++cnt; fa[cnt]=now; &#125; now=next[now][ch[i]-'a']; &#125; &#125; void buildfail()&#123; int head=0,tail=1; fail[1]=0;q[0]=1; while(head!=tail) &#123; int now=q[head];head++; for(int i=0;i&lt;26;i++) if(next[now][i]) &#123; int v=next[now][i]; int k=fail[now]; while(!next[k][i])k=fail[k]; fail[v]=next[k][i]; q[tail++]=v; &#125; &#125; &#125; void solve() &#123; int now=1,id=0; add(l[1],1); for(int i=0;ch[i];i++) if(ch[i]=='P') &#123; id++; for(int x=lastq[id];x;x=que[x].next) &#123; int t=pos[que[x].to]; ans[x]=query(r[t])-query(l[t]-1); &#125; &#125; else if(ch[i]=='B')add(l[now],-1),now=fa[now]; else now=next[now][ch[i]-'a'],add(l[now],1);; &#125; &#125;Aho_Corasick;void dfs(int x)&#123; l[x]=++T; for(int i=last[x];i;i=e[i].next) dfs(e[i].to); r[x]=++T; //wtf!&#125;void addedge(int x,int y,int z)&#123; que[z].next = lastq[y]; lastq[y] = z; que[z].to = x;&#125;int main(int argc, char *argv[])&#123; scanf("%s",ch); n=strlen(ch); Aho_Corasick.build(); Aho_Corasick.buildfail(); for(int i=1;i&lt;=Aho_Corasick.cnt;i++) insert(Aho_Corasick.fail[i],i); m=read(); for(int i=1;i&lt;=m;i++) &#123; int x=read(),y=read(); addedge(x,y,i); &#125; dfs(0); Aho_Corasick.solve(); for(int i=1;i&lt;=m;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI-2014] Zoo KMP模拟]]></title>
    <url>%2F2018%2F03%2F08%2FNOI-2014-Zoo-KMP%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[题面BZOJ-3670 分析不考虑题目的限制,只想一般的情况. 先通过对next数组的观察,不难得到$num(i)=num(fail(i))+1$. 考虑再维护一个前缀不与后缀重叠的,带有限制的$num’(i)$, 找一波规律得到 num'(i) = num(fail'(i))+1相当于同时维护了两个失配数组了嘛. 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+5;typedef long long ll;int n;char s[maxn];int fail[maxn],num1[maxn],num2[maxn];const int Mod = 1e9+7;ll kmp(char *b)&#123; ll ans = 1; int nb = strlen(b+1),k = 0,t = 0; for (int i = 2; i &lt;= nb; i++) &#123; while(k &amp;&amp; s[k+1] != s[i]) k = fail[k]; while((t &amp;&amp; s[t+1] != s[i]) || t &gt;= (i&gt;&gt;1)) t = fail[t]; if(s[t+1] == s[i]) num2[i] = num1[++t] + 1; else num2[i] = 0; if(s[k+1] == s[i]) fail[i] = ++k,num1[i] = num1[k] + 1; else num1[i] = fail[i] = 0; ans = (ans * (num2[i]+1)) % Mod; &#125; return ans;&#125; int main(int argc, char *argv[])&#123; scanf("%d",&amp;n); while(n--) &#123; scanf("%s",s+1); printf("%lld\n",kmp(s)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF-578D(Div 1)] LCS AGAIN]]></title>
    <url>%2F2018%2F03%2F08%2FCF-578D-Div-1-LCS-AGAIN%2F</url>
    <content type="text"><![CDATA[题面Codeforces-578D You are given a string S of length n with each character being one of the first m lowercase English letters. Calculate how many different strings T of length n composed from the first m lowercase English letters exist such that the length of LCS (longest common subsequence) between S and T is n - 1. Recall that LCS of two strings S and T is the longest string C such that C both in S and T as a subsequence. Input The first line contains two numbers n and m denoting the length of string S and number of first English lowercase characters forming the character set for strings (1 ≤ n ≤ 100 000, 2 ≤ m ≤ 26). The second line contains string S. Output Print the only line containing the answer. 代码12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;char last,la_last;long long ans = 0,tmp = 0;inline char next()&#123; char c = getchar(); while(!isalpha(c)) c=getchar(); return c;&#125;int main(int argc, char *argv[])&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); ans = 1LL * n * (m-1); char ret = getchar(),last = next(),la_last = -1; for (int i = 2; i &lt;= n; i++) &#123; char ch = next(); if (ch == la_last) tmp++; else tmp = 0; if (ch != last) ans += n*(m-1)-tmp-1; la_last = last; last = ch; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP/Trie树/Aho-Corasick Automaton 学习笔记]]></title>
    <url>%2F2018%2F03%2F08%2FKMP-Trie%E6%A0%91-Aho-Corasick-Automaton-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[继续填坑.本来想把这三个玩意分开来写的,后来发现其实阿次自动姬就可以描述这几个的原理了.那就写一起了. KMP全称叫做 (Knuth-Morris-Pratt).是能够在线性时间内完成字符串匹配的算法. 原理KMP算法不同于一般的暴力匹配算法的地方在于,KMP算法充分利用了每次匹配后的失配信息,不会每一次都从第一个位置匹配,因此我们先介绍一个玩意叫做适配数组fail[i]. 对于fail[i]数组的定义: 模式串中前i个字符作为目标串的最大前后缀对称长度. 这什么定义啊看得我头大. 我们以实际栗子来说明. 假设现在又这样的一个模式串shryshrkrin 根据定义我们推出的fail数组为00001230000 为什么这么定义fail数组呢?在我们匹配字符串的时候，如果之前的匹配失败了，我们直接用fail数组得到下一个合法的前缀即可.而且又可以证明,fail数组和匹配的串没有任何的关系,换言之,得到了fail数组,就是得到了失配信息.与下一个可能合法的字符串的位置. 好我们是不是只要能求出fail数组就可以收工了？ fail的递推方式如下. 如果 fail[i - 1] 不为 0，且第 i 个字符与第 fail[i - 1] + １ 个字符相同，则 fail[i] 即为 fail[i - 1] + 1； 如果 fail[i - 1] 为 0，且第 i 个字符与首个字符相同，则 fail[i] = 1，否则 fail[i] = 0； 如果 fail[i - 1] 不为 0，且第 i 个字符与第 fail[i - 1] + １ 个字符不同，则继续对比第 i 个字符与 fail[fail[i - 1]] + 1 个字符，一直向前找直到匹配或者找到了 0。 板子12345678910111213141516171819202122232425262728int kmp(char *a, char *b) //find b in a&#123; static int fail[MAXN]; int na = strlen(a+1),nb = strlen(b+1); fail[1] = 0; for (int i = 2; i &lt;= nb; i++) &#123; int j = fail[i-1]; while(j != 0 &amp;&amp; b[j+1] != b[i]) j = fail[j]; if (b[j+1] == b[i]) fail[i] = j+1; else fail[i] = 0; &#125; int res = 0; for (int i = 1,j = 0; i &lt;= na; i++) &#123; while(j != 0 &amp;&amp; b[j+1] != a[i]) j = fail[j]; if (a[i] == b[j+1]) j++; if (j == nb) &#123; res ++; j = fail[j]; // j = 0; //如果每个字符只能使用一次,这里的j应该为0 &#125; &#125; return res;&#125; 然后是板子题. POJ-3461 板子题,求第一个串在第二个中的出现次数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344//#include&lt;bits/stdc++.h&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN = 1e6+10;char s1[MAXN],s2[MAXN];int kmp(char *a,char *b)&#123; static int fail[MAXN]; int na = strlen(a+1), nb = strlen(b+1); fail[1] = 0; for (int i = 2; i &lt;= nb; i++) &#123; int j = fail[i-1]; while(j != 0 &amp;&amp; b[j+1] != b[i]) j = fail[j]; if (b[i] == b[j+1]) fail[i] = j+1; else fail[i] = 0; &#125; int res = 0; for (int i = 1,j = 0; i &lt;= na; i++) &#123; while(j != 0 &amp;&amp; b[j+1] != a[i]) j = fail[j]; if (a[i] == b[j+1]) j ++; if (j == nb) &#123; res ++ ; j = fail[j]; &#125; &#125; return res;&#125;int main(int argc, char *argv[])&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",s1+1,s2+1); printf("%d\n",kmp(s2,s1)); &#125; return 0;&#125; LUOGU-3375 还是板子题,求询问串的所有出现位置与next数组. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN = 1e6+10;char s1[MAXN],s2[MAXN];vector &lt;int&gt; v;vector &lt;int&gt;::iterator it;void kmp(char *a,char *b)&#123; static int fail[MAXN]; int na = strlen(a+1), nb = strlen(b+1); fail[1] = 0; for (int i = 2; i &lt;= nb; i++) &#123; int j = fail[i-1]; while(j != 0 &amp;&amp; b[j+1] != b[i]) j = fail[j]; if (b[i] == b[j+1]) fail[i] = j+1; else fail[i] = 0; &#125; int res = 0; for (int i = 1,j = 0; i &lt;= na; i++) &#123; while(j != 0 &amp;&amp; b[j+1] != a[i]) j = fail[j]; if (a[i] == b[j+1]) j ++; if (j == nb) &#123; v.push_back(i-j+1);//这个莫名其妙地自己蒙出来了. j = fail[j]; &#125; &#125; for (it = v.begin(); it != v.end(); it++) cout &lt;&lt; *it &lt;&lt; endl; for (int i = 1; i &lt;= nb; i++) cout &lt;&lt; fail[i] &lt;&lt; " ";&#125;int main(int argc, char *argv[])&#123; v.clear(); scanf("%s%s",s1+1,s2+1); kmp(s1,s2); return 0;&#125; 那么再来一道. 算了看习题整理吧。 Trie树(字典树)其实是个很斯波的东西. 很好写也很好懂. HDU-1251 求询问串为模式串前缀的个数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma GCC optmize("0fuck")#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6+10;char s[11];struct Trie&#123; int tot,trie[maxn][26],sum[maxn]; void settledown(void)&#123;tot=0;memset(sum,0,sizeof(sum));&#125; void insert(char *s,int rt) &#123; int l = strlen(s); for (int i = 0; i &lt; l; i++) &#123; int x = s[i]-'a'; if (trie[rt][x] == 0) trie[rt][x] = ++tot; rt = trie[rt][x]; sum[rt]++; &#125; &#125; int find(char *s,int rt) &#123; int l = strlen(s); for (int i = 0; i &lt; l; i++) &#123; int x = s[i]-'a'; if (!trie[rt][x]) return 0; rt = trie[rt][x]; &#125; return sum[rt]; &#125;&#125;Tr;int main(int argc,char *argv[])&#123; char ch; while(gets(s)) &#123; if (s[0]==NULL) break; Tr.insert(s,0); &#125; while(gets(s)) printf("%d\n",Tr.find(s,0)); return 0;&#125; LUOGU-2580 对字符串查询操作.求询问串作为前缀是否出现,是否第一次出现,是否没出现. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#pragma GCC optmize("0fuck")#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6+10;char s[10];char ss[4][10] = &#123;"WRONG","REPEAT","OK"&#125;;struct Trie&#123; int tot,trie[maxn][26]; bool vis[maxn]; void settledown(void) &#123; tot = 1; memset(vis,1,sizeof(vis)); &#125; void insert(char *s,int rt) &#123; int l = strlen(s+1); for (int i = 1; i &lt;= l; i++) &#123; int x = s[i]-'a'; if (trie[rt][x] == 0) trie[rt][x] = ++tot; rt = trie[rt][x]; &#125; &#125; int find(char *s,int rt) &#123; int l = strlen(s+1); for (int i = 1; i &lt;= l; i++) &#123; int x = s[i]-'a'; if (!trie[rt][x]) return 0; rt = trie[rt][x]; &#125; if (vis[rt]) &#123; vis[rt] = 0; return 2; &#125; else return 1; &#125;&#125;Tr;int main(int argc,char *argv[])&#123; Tr.settledown(); int n,m; scanf("%d",&amp;n); while(n--) &#123; scanf("%s",s+1); Tr.insert(s,1); &#125; scanf("%d",&amp;m); while(m--) &#123; scanf("%s",s+1); printf("%s\n",ss[Tr.find(s,1)]); &#125; return 0;&#125; Aho-Corasick Automaton这玩意才是重点 首先我对于AC自动姬的理解就是 \large AC Automaton=KMP+Trie一样的对于模式串建立字典树，在树上算fail数组，我们把这两个玩意放到一起. Trie只能做前缀不能匹配吧,加了KMP不就行了么! 我觉得有张图挺好的。 这是普通的建立Trie树的过程 然后我们在上面加上fail数组 / 指针就可以了 对于AC自动姬,有两种写法 带指针(我还是偏向于喜欢这么写,感觉挺好理解的) 可食用对象 LUOGU-3808 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#include&lt;queue&gt;using namespace std;const int maxn = 1e6 + 5;int cnt,N;struct node&#123; node *next[26]; node *fail; int sum;&#125;;char key[maxn];node *newnode,*root;char pattern[maxn];void Insert(char *s)&#123; node *p = root; for(int i = 0; s[i]; i++) &#123; int x = s[i] - 'a'; if(p-&gt;next[x] == NULL) &#123; //newnode=(struct node *)malloc(sizeof(struct node)); newnode = new(node); for(int j=0;j&lt;26;j++) newnode-&gt;next[j] = 0; newnode-&gt;sum = 0;newnode-&gt;fail = 0; p-&gt;next[x]=newnode; &#125; p = p-&gt;next[x]; &#125; p-&gt;sum++;&#125;void build_fail_pointer()&#123; queue&lt;node*&gt;q; q.push(root); node *p; node *temp; while(!q.empty()) &#123; temp = q.front(); q.pop(); for(int i = 0; i &lt;= 25; i++) &#123; if(temp-&gt;next[i]) &#123; if(temp == root) temp-&gt;next[i]-&gt;fail = root; else &#123; p = temp-&gt;fail; while(p) &#123; if(p-&gt;next[i]) &#123; temp-&gt;next[i]-&gt;fail = p-&gt;next[i]; break; &#125; p = p-&gt;fail; &#125; if(p == NULL) temp-&gt;next[i]-&gt;fail = root; &#125; q.push(temp-&gt;next[i]); &#125; &#125; &#125;&#125;void ac_automation(char *ch)&#123; node *p = root; int len = strlen(ch); for(int i = 0; i &lt; len; i++) &#123; int x = ch[i] - 'a'; while(!p-&gt;next[x] &amp;&amp; p != root) p = p-&gt;fail; p = p-&gt;next[x]; if(!p) p = root; node *temp = p; while(temp != root) &#123; if(temp-&gt;sum &gt;= 0) &#123; cnt += temp-&gt;sum; temp-&gt;sum = -1; &#125; else break; temp = temp-&gt;fail; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; //root=(struct node *)malloc(sizeof(struct node)); root = new(node); //好像 new(node)更快!? for(int j=0;j&lt;26;j++) root-&gt;next[j] = 0; root-&gt;fail=0; root-&gt;sum=0; scanf("%d",&amp;N); getchar();//get char of newline for(int i = 1; i &lt;= N; i++) &#123; scanf("%s",key); Insert(key); &#125; scanf("%s",pattern); cnt = 0; build_fail_pointer(); ac_automation(pattern); printf("%d\n",cnt); return 0;&#125; 网上拉来一个不用指针的. 蓝甘冰露 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define il inline#define RG register#define N 10010using namespace std; char s[N][55],ss[N*100];int n,times[N];//times记录单词在文本串中出现的次数 struct Trie&#123; int son[N][26],fail[N],root,L,num[N]; int last[N];//只是一个优化，有没有都没关系 void init()&#123; L=1; root=0; memset(son,0,sizeof(son)); memset(num,0,sizeof(num)); memset(last,0,sizeof(last)); memset(fail,0,sizeof(fail)); &#125; il int idx(char c)&#123; return c-'a'; &#125; void insert( char s[],int v )&#123; int len=strlen(s), cur=root; for(int i=0;i&lt;len;i++)&#123; int id=idx(s[i]); if(!son[cur][id]) son[cur][id]=L++; cur=son[cur][id]; &#125; num[cur]=v; //记录单词编号 &#125; void build()&#123; int que[N],hd=0,tl=0; for(int i=0;i&lt;26;i++) if(son[root][i])&#123; que[tl++]=son[root][i]; fail[son[root][i]]=root; &#125; else son[root][i]=root; while(hd&lt;tl)&#123; int cur=que[hd++]; for(int i=0;i&lt;26;i++)&#123; int Son=son[cur][i]; if(Son)&#123; int f=fail[cur]; while(f &amp;&amp; !son[f][i]) f=fail[f]; fail[Son]=son[f][i]; num[Son]=num[fail[Son]];//不用last优化时要加上这一句 que[tl++]=Son; &#125; else son[cur][i]=son[fail[cur]][i]; &#125; //if( num[fail[cur]] )last[cur]=fail[cur]; //else last[cur]=last[fail[cur]]; &#125; &#125; void query( char s[] )&#123; int len=strlen(s),cur=root; for(int i=0;i&lt;len;i++)&#123; int id=idx(s[i]); while(cur &amp;&amp; !son[cur][id]) cur=fail[cur]; if(son[cur][id])&#123; cur=son[cur][id]; int k=cur; while(k) times[ num[k] ]++,k=fail[k]; /*while(k)&#123; if(num[k]) times[num[k]]++; k=last[k]; &#125;*/ &#125; &#125; &#125; &#125;AC; int main()&#123; scanf("%d",&amp;n); AC.init(); for(RG int i = 1;i&lt;=n;i++)&#123; scanf("%s",s[i]); AC.insert(s[i],i); &#125; AC.build(); scanf("%s",ss); AC.query(ss); for( RG int i=1;i&lt;=n;i++ ) printf("%s %d\n",s[i],times[i]); return 0;&#125;]]></content>
      <categories>
        <category>AC自动姬</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[奇技淫巧]算法竞赛常数优化技巧/代码风格总结]]></title>
    <url>%2F2018%2F03%2F01%2F%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[序言这几天被卡常恶心到的挺多的..所以不得不恶补了一波黑科技的卡常技巧，然后代码风格的问题很久就想写了.. 所以就当做个总结吧。 卡常技巧修饰符的运用1.多在非递归函数/过程加inline,好像是说这样编译后调用速度加快.. 2.i++比++i慢 3.算是个玄学的东西叫做register,原理在于把变量存在CPU的寄存器中计算快. 一般有需要的话可以这么写 12#define RG register#define rep(i,a,b) for(RG int i=(a);i&lt;=(b);i++) 但是奇怪的是hjq上次帮我调的时候加了RG反而变慢了1s..鬼畜啊.. 4.常数少用#define 多用const/typedef 5.少用if else 多用三目运算符 计算优化6.循环展开,可以在展开的时候每个写成函数会美观一点. 7.读入优化（我的标准写法差不多这样↓） 1234567inline void read()&#123; int x = 0,f = 1;char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return x * f;&#125; 上面的x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - ‘0’;还是cgc想到的马叉虫写法. 8.abs自己写. 函数调用优化9.某些不开O2时候的函数/STL慢的要死不如自己实现. e.g. isdigit(),isalpha(), max(),min(), queue&lt;&gt;,map&lt;&gt;,priority_queue&lt;&gt;, binary_search(),upper/lower_bound(). etc. 奇怪的等价x10 &lt;=&gt; (x&lt;]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洲阁筛学习总结]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%B4%B2%E9%98%81%E7%AD%9B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[(不知不觉又给自己挖了个坑.) ckr : “我只是在无敌的路上越走越远” 洲阁筛食用方法食用范围大部分的情况差不多这样: 给出一个积性函数$f(x)$满足积性函数的基本性质,$f(1)=1$,如果$gcd(a,b)=1$有$f(ab)=f(a)f(b)$. 那么根据唯一分解定理,就是$x=\prod _{i=1}^np_i^{k_i}$就可以: \large f(x)=\prod f(p_i^{k_i})$In \space particular,p \space\space is\space a\space prime\space number$，而且$f(p^c)$可以快速求出. 一般的题目差不多都这样: $f(x)$是一个数论函数,要求$\sum_{i=1}^nf(i)$,而且你发现,杜教筛完全不能用卷积简化，你被题目的形式深深卡死！ 啊♂ 洲阁筛就出现了。 食用思想主要的核心思想在于:分类 引理：$n$以内的数,最多只有一个大于$\sqrt{n}$的质因数: $Proof:$ ​ 假设原命题不成立,即存在有两个大于$\sqrt{n}$的质因数, ​ 那么不妨设这两个质因数是$n_1,n_2$ 于是有$n_1n_2&gt;n$,但这是不可能的！ ​ $\therefore$假设命题不成立，原命题正确.]]></content>
      <categories>
        <category>洲阁筛</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mobius反演习题整理]]></title>
    <url>%2F2018%2F02%2F27%2FMobius%E5%8F%8D%E6%BC%94%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[题单（这边的是做过的..） 题单在这: https://www.cnblogs.com/darklove/p/7554314.html BZOJ-2440 BZOJ-3994/LUOGU-3327双倍经验 BZOJ-2154 SPOJ-DIVCNT2(谁来帮我卡个常啊最后的点T飞就差一点点啊啊啊啊啊) BZOJ-2301/LUOGU-2522双倍经验 51Nod-1244 51Nod-1239 BZOJ-3944 51Nod-1237 —-（不定期添加全凭造化） 奇技淫巧常用公式整理狄利克雷卷积狄利克雷卷积定义在数论函数上 狄利克雷卷积 定义 狄利克雷卷积：$\displaystyle (f \times g)(n) = \sum_{d|n}f(d)*g(\frac{n}{d})$ 一个例子：$f(x)=2x,g(x)=3x$ 则$(f \times g)(6)=f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)$。 往往省略掉$n$。 狄利克雷卷积定义在数论函数上。 数论函数： 如果一个函数的定义域为正整数，值域为复数，则称此函数为数论函数。常见的数论函数有欧拉函数$\varphi$和莫比乌斯函数$\mu$。 运算律： 结合律 $(f \times g ) \times h= f \times (g \times h)$。 交换律 $f \times g = g \times f$。 加法-狄利克雷卷积分配律 $f \times (g+h) = f\times g + f \times h$。 单位元 单位函数$\epsilon$，使得$f= \epsilon \times f =f \times \epsilon$。单位函数的取值：$n=1$时$\epsilon(n)=1$，$n$取其他值时$\epsilon(n)=0$。 逆元 对于任意数论函数$f$，如果$f(1) \not = 0$，则存在唯一的逆函数$f^{-1}$，使得 $f \times f^{-1} = \epsilon$：对于$n=1$，有：${f^{-1}(1)={\frac {1}{f(1)}}}$对于$n&gt;1$，有：$ {f^{-1}(n)={\frac {-1}{f(1)}}\displaystyle \sum _{d|n,n\neq d}f({\frac {n}{d}})f^{-1}(d)}$ 特殊函数的奆积由:$\sum_{d|n}\varphi(d)=n$再结合狄利克雷卷积的定义: $\varphi*1=n$ 根据Mobius反演的式子: $F(n)=\sum_{d|n}f(d)$ 写成卷积的形式就是: $F = f*1$ 事实上我们甚至可以用狄利克雷卷积的运算法则来证明莫比乌斯反演的正确性 \huge{ \because \mu * 1=\epsilon \\\\ \therefore f*1=F*\mu*1 \\\\\therefore f=F *\mu}更有意思的是我们几乎可以不费吹灰之力，利用狄利克雷卷积运算的交换律,由: \huge f=F*\mu=\mu*F \huge=>f(n)=\sum_{d|n}\mu(\frac{n}{d})F(d) = \sum_{d|n}\mu(d)F(\frac{n}{d})这么快就证完了,,,珂怕. 数论积性函数线性筛法由积性函数的定义,大部分的数论函数如$\mu(x),\varphi(x)$都能在$Euler$线性筛中以$O(n)$的时间得到. 交出板子 1234567891011121314151617181920212223242526272829303132inline void init(void)&#123; //phi[i]为欧拉函数,u[i]为莫比乌斯函数,f[i]为约数个数函数,g[i]为最高质因数的次方数 phi[1] = u[1] = f[1] = 1; for (int i = 2; i &lt; maxn; i++) &#123; if(!vis[i]) &#123; prime[++cnt] = i; u[i] = -1; f[i] = 2; g[i] = 1; phi[i] = i-1; &#125; for(int j = 1;j &lt;= cnt&amp;&amp; i*prime[j] &lt;=maxn; j++) &#123; vis[i*prime[j]]=true; if(i%prime[j]== 0) &#123; u[i*prime[j]]=0; g[i*prime[j]]=g[i]+1; f[i*prime[j]]=f[i]/(g[i]+1)*(g[i]+2); phi[i*prime[j]] = phi[i] * prime[j]; break; &#125; u[i*prime[j]]=-u[i]; g[i*prime[j]]=1; f[i*prime[j]]=f[i]*2; phi[i*prime[j]] = phi[i] * (prime[j]-1); &#125; &#125;&#125; 这个板子应该够用了不然我就吃ckr Mobius反演公式 \huge{ \sum_{x|n}\mu(x)=[n=1]\\\\ \sum_{x|i}f(\frac{i}{x})=\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}f(i)\\\\ \varphi(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})=\sum_{d|n}\frac{\mu(d)n}{d}\\\\ \sum_{d|n}\varphi(d)=n\\\\ }复杂的单题写题解吧.]]></content>
      <categories>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT/NTT学习笔记]]></title>
    <url>%2F2018%2F02%2F25%2FFFT-NTT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[引言史诗级巨坑填完再划 主要参考资料： lych_cys梁大的讲解 MYY的国家集训队论文 Menci’s blog 邓祎明的知乎专栏 学长方尤乐的blog Miskcoo’s blog （和一些奇奇怪怪的东西 预备知识多项式定义（参见初中人教版七年级上课本） 系数表示法将P(X)=a_0+a_1X+a_2X^2+\cdots+a_nX^n的每一个X 前的系数a_i提取出来看作一个n+1维向量 此向量$\vec{a}$就是$P(X)$的系数表示法的向量。 点值表示法对于这个多项式若我们不知道它的系数,我们可以用采样的方式将一组插值节点$(x_0,x_1,\cdot\cdot\cdot,x_n)$代入上式 得到$n+1$个不同的结果$(y_0,y_1,\cdot\cdot\cdot,y_n)$，就可以唯一确定这个多项式. 点值表示法正确性的证明 证明: 假设原命题不成立即存在两个不同的多项式$A(x),B(x)$在$\forall i\in[0,n]$，都有$A(x_i)=B(x_i)$ 那么假设用$A(x_i)-B(x_i) = H(x_i) = 0$,那么$H(x_i)$有$(n+1)$个根,这与$n$次多项式只有$n$个根的代数基本定理相矛盾，矛盾！故假设不成立！ $\therefore$原命题正确性显然. 而$FFT$就是利用了点值和系数表示之间的关系，在快速求点值来表示系数，搭起这两个变换的桥梁. 多项式的乘除法乘法:叫做卷积,也作奆积。形象地可以写成: c_i=\sum_{j=0}^{i}a_j*b_{i-j}用这个公式不难得到一个$O(n^2)$的算法. 除法:就是大除法,小学/初中奥数部分不赘述了. 单位根及其性质 证明一： 由几何意义，这两者表示的向量终点是相反的，左边较右边在单位圆上多转了半圈。 证明二： 由计算的公式： 最后一步由三角恒等变换得到。 FFT(法法塔) 但是这样的操作常数爆炸..FFT本身的常数就很奆.. 观察分组情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//递归爆栈 LUOGU热掉77分 #include&lt;bits/stdc++.h&gt;#define complex COMPLEX//complex关键字也是服了 using namespace std;const int MAXN=2*1e6+10;inline int read()&#123; char c=getchar();int x=0,f=1; while(!isdigit(c))&#123;if(c=='-')f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;const double Pi=acos(-1.0);struct complex&#123; double x,y; complex (double xx=0,double yy=0)&#123;x=xx,y=yy;&#125;&#125;a[MAXN],b[MAXN];complex operator + (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x+b.x , a.y+b.y);&#125;complex operator - (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x-b.x , a.y-b.y);&#125;complex operator * (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);&#125;//不懂的看复数的运算那部分 void FFT(int limit,complex *a,int type)&#123; if(limit==1) return ; complex a1[limit&gt;&gt;1],a2[limit&gt;&gt;1]; for(int i=0;i&lt;=limit;i+=2) a1[i&gt;&gt;1]=a[i],a2[i&gt;&gt;1]=a[i+1]; FFT(limit&gt;&gt;1,a1,type); FFT(limit&gt;&gt;1,a2,type); complex Wn=complex(cos(2.0*Pi/limit) , type*sin(2.0*Pi/limit)),w=complex(1,0); for(int i=0;i&lt;(limit&gt;&gt;1);i++,w=w*Wn)//这里的w相当于公式中的k a[i]=a1[i]+w*a2[i], a[i+(limit&gt;&gt;1)]=a1[i]-w*a2[i];//利用单位根的性质，O(1)得到另一部分 &#125;int main(int argc, char *argv[])&#123; int N=read(),M=read(); for(int i=0;i&lt;=N;i++) a[i].x=read(); for(int i=0;i&lt;=M;i++) b[i].x=read(); int limit=1;while(limit&lt;=N+M) limit&lt;&lt;=1; FFT(limit,a,1); FFT(limit,b,1); for(int i=0;i&lt;=limit;i++) a[i]=a[i]*b[i]; FFT(limit,a,-1); for(int i=0;i&lt;=N+M;i++) printf("%d ",(int)(a[i].x/limit+0.5)); return 0;&#125; 递归爆栈..没话说了. 改迭代 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt; #define complex COMPLEX//complex关键字也是服了 using namespace std;const int MAXN=1e6+10;inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;const double Pi=acos(-1.0);struct complex&#123; double x,y; complex (double xx=0,double yy=0)&#123;x=xx,y=yy;&#125;&#125;a[MAXN],b[MAXN];complex operator + (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x+b.x , a.y+b.y);&#125;complex operator - (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x-b.x , a.y-b.y);&#125;complex operator * (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);&#125;//不懂的看复数的运算那部分 int N,M;int l,r[MAXN];int limit=1;void FFT(complex *A,int type)&#123; for (int i = 0; i &lt; limit; i++) if (i &lt; r[i]) swap(A[i],A[r[i]]); for (int mid = 1; mid &lt; limit; mid&lt;&lt;=1) &#123; complex Wn(cos(Pi/mid),type*sin(Pi/mid)); for (int R = mid&lt;&lt;1,j = 0; j &lt;limit;j+=R) &#123; complex w(1,0); for (int k = 0; k &lt; mid; k++,w=w*Wn) &#123; complex x=A[j+k],y=w*A[j+mid+k]; A[j+k] = x+y; A[j+mid+k] = x-y; &#125; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; int N=read(),M=read(); for(int i=0;i&lt;=N;i++) a[i].x=read(); for(int i=0;i&lt;=M;i++) b[i].x=read(); while(limit&lt;=N+M) limit&lt;&lt;=1,l++; for(int i=0;i&lt;limit;i++) r[i]= ( r[i&gt;&gt;1]&gt;&gt;1 )| ( (i&amp;1)&lt;&lt;(l-1) ) ; FFT(a,1); FFT(b,1); for(int i=0;i&lt;=limit;i++) a[i]=a[i]*b[i]; FFT(a,-1); for(int i=0;i&lt;=N+M;i++) printf("%d ",(int)(a[i].x/limit+0.5)); return 0;&#125; 所以说算是差不多学会了FFT 上道题目 LUOGU-1919 大整数乘法用FFT来跑 其实就是规定了$x=10$的FFT. 注意前导0的处理,具体实现看代码. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define complex COMPLEX using namespace std;const int MAXN=1e6+10;inline int read()&#123; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;c=getchar();&#125; if(c&gt;='0'&amp;&amp;c&lt;='9') return c-'0';&#125;const double Pi=acos(-1.0);struct complex&#123; double x,y; complex (double xx=0,double yy=0)&#123;x=xx,y=yy;&#125;&#125;a[MAXN],b[MAXN];complex operator + (complex a,complex b)&#123; return complex(a.x+b.x , a.y+b.y);&#125;complex operator - (complex a,complex b)&#123; return complex(a.x-b.x , a.y-b.y);&#125;complex operator * (complex a,complex b)&#123; return complex(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);&#125;int N,M;int l,r[MAXN],ans[MAXN];int limit=1;void FFT(complex *A,int type)&#123; for (int i = 0; i &lt; limit; i++) if (i &lt; r[i]) swap(A[i],A[r[i]]); for (int mid = 1; mid &lt; limit; mid&lt;&lt;=1) &#123; complex Wn(cos(Pi/mid),type*sin(Pi/mid)); for (int R = mid&lt;&lt;1,j = 0; j &lt;limit;j+=R) &#123; complex w(1,0); for (int k = 0; k &lt; mid; k++,w=w*Wn) &#123; complex x=A[j+k],y=w*A[j+mid+k]; A[j+k] = x+y; A[j+mid+k] = x-y; &#125; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; int N;scanf("%d",&amp;N); int M = N; M--,N--; for(int i=0;i&lt;=N;i++) a[i].x=read(); for(int i=0;i&lt;=M;i++) b[i].x=read(); while(limit&lt;=N+M) limit&lt;&lt;=1,l++; for(int i=0;i&lt;limit;i++) r[i]= ( r[i&gt;&gt;1]&gt;&gt;1 )| ( (i&amp;1)&lt;&lt;(l-1) ) ; FFT(a,1); FFT(b,1); for(int i=0;i&lt;=limit;i++) a[i]=a[i]*b[i]; FFT(a,-1); int i; for(i=0;i&lt;=N+M;i++) ans[i+100] = (int)(a[i].x/limit+0.5);//向右边平移100位来处理前导0 for (int j=M+N+100; j&gt;=100; j--) while(ans[j] &gt;= 10) ans[j-1] += ans[j]/10,ans[j]%=10; i = 0; while(!ans[i]) i++; for (;i&lt;=M+N+100;i++) printf("%d",ans[i]); return 0;&#125; NTT$NTT$就是快速数论变换,是FFT的虚部变成非浮点而改为Mod一个值的应用. 实部是可以不管的.我们的重点是把虚部转化为其他便于计算的东西. 掌握了关于原根的知识后。就可以得到 W_n^n \equiv g^{P-1}\mod{1}所以这个形式只能满足一部分形如$2^n*p+1$的质数,这种质数因为满足费马小定理$a^p\equiv{1}\mod{p}$ 叫做费马质数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//只能Mod费马质数的NTT#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL a[400010],b[400010],c[400010];int p=1004535809,g=3,n,m,bin[400010]; //p = 2^21*479+1 (Fema Prime)LL pow(LL a,int b,int mod)&#123; LL ans=1; while(b) &#123; if(b&amp;1) ans=ans*a%mod; a=a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;void ntt(LL *a,int n,int op)&#123; for(int i=0;i&lt;n;i++) if(i&lt;bin[i]) swap(a[i],a[bin[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; LL wn=pow((LL)g,op==1?(p-1)/(2*i):p-1-(p-1)/(2*i),p),t,w; for(int j=0;j&lt;n;j+=i&lt;&lt;1) &#123; w=1; for(int k=0;k&lt;i;k++) &#123; t=w*a[i+j+k]%p;w=w*wn%p; a[i+j+k]=(a[j+k]-t+p)%p;a[j+k]=(a[j+k]+t)%p; &#125; &#125; &#125; if(op==-1) &#123; LL inv=pow(n,p-2,p); for(int i=0;i&lt;n;i++) a[i]=a[i]*inv%p; &#125;&#125;int main(int argc, char *argv[])&#123; scanf("%d %d",&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(int i=0;i&lt;=m;i++) scanf("%lld",&amp;b[i]); m+=n;n=1;while(n&lt;=m) n&lt;&lt;=1; for(int i=0;i&lt;n;i++) bin[i]=(bin[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); ntt(a,n,1);ntt(b,n,1); for(int i=0;i&lt;n;i++) c[i]=a[i]*b[i];ntt(c,n,-1); for(int i=0;i&lt;=m;i++) printf("%lld ",c[i]); return 0;&#125; 那么如果不是费马质数 取一个任意的数取模 岂不是要$gg$ 因为MYY在论文中提出三次求Mod再CRT(China Remainder Theorem)的做法 就被称为MTT了(雾 模板题 MTT,LUOGU-4245 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//对于任意Mod的NTT//用MYY的三模法.//%%%%% #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int P=23333333;const int M[]= &#123;998244353,1004535809,469762049&#125;;const int G[]= &#123;3,3,3&#125;;const ll _M=(ll)M[0]*M[1];inline ll Pow(ll a,int b,int p) &#123; ll ret=1; for (; b; b&gt;&gt;=1,a=a*a%p) if (b&amp;1) ret=ret*a%p; return ret;&#125;inline ll mul(ll a,ll b,ll p) &#123; a%=p; b%=p; return ((a*b-(ll)((ll)((long double)a/p*b+1e-3)*p))%p+p)%p;&#125;const int m1=M[0],m2=M[1],m3=M[2];const int inv1=Pow(m1%m2,m2-2,m2),inv2=Pow(m2%m1,m1-2,m1),inv12=Pow(_M%m3,m3-2,m3);inline int CRT(int a1,int a2,int a3) &#123; ll A=(mul((ll)a1*m2%_M,inv2,_M)+mul((ll)a2*m1%_M,inv1,_M))%_M; ll k=((ll)a3+m3-A%m3)*inv12%m3; return (k*(_M%P)+A)%P;&#125;const int N=264000;struct NTT &#123; int P,G; int num,w[2][N]; int R[N]; void Pre(int _P,int _G,int m) &#123; num=m; P=_P;G=_G; int g=Pow(G,(P-1)/num,P); w[1][0]=1; for (int i=1; i&lt;num; i++) w[1][i]=(ll)w[1][i-1]*g%P; w[0][0]=1; for (int i=1; i&lt;num; i++) w[0][i]=w[1][num-i]; int L=0;while (m&gt;&gt;=1) L++; for (int i=1; i&lt;=num; i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1)); &#125; void FFT(int *a,int n,int r) &#123; for (int i=0; i&lt;n; i++) if (i&lt;R[i]) swap(a[i],a[R[i]]); for (int i=1; i&lt;n; i&lt;&lt;=1) for (int j=0; j&lt;n; j+=(i&lt;&lt;1)) for (int k=0; k&lt;i; k++) &#123; int x=a[j+k],y=(ll)a[j+i+k]*w[r][num/(i&lt;&lt;1)*k]%P; a[j+k]=(x+y)%P; a[j+i+k]=(x+P-y)%P; &#125; if (!r) for (int i=0,inv=Pow(n,P-2,P); i&lt;n; i++) a[i]=(ll)a[i]*inv%P; &#125;&#125; ntt[3];int n,m,n1,n2;int a[3][N];int A[N],B[N],C[N],D[N];int main(int argc, char *argv[]) &#123; scanf("%d%d%d",&amp;n1,&amp;n2,&amp;P); for (int i=0; i&lt;=n1; i++) scanf("%d",&amp;A[i]); for (int i=0; i&lt;=n2; i++) scanf("%d",&amp;B[i]); for (m=1; m&lt;=(n1+n2); m&lt;&lt;=1); for (int i=0; i&lt;3; i++) ntt[i].Pre(M[i],G[i],m); for (int i=0; i&lt;3; i++) &#123; memcpy(C,A,sizeof(int)*(m+5)); memcpy(D,B,sizeof(int)*(m+5)); ntt[i].FFT(C,m,1); ntt[i].FFT(D,m,1); for (int j=0; j&lt;m; j++) C[j]=(ll)C[j]*D[j]%ntt[i].P; ntt[i].FFT(C,m,0); for (int j=0; j&lt;m; j++) a[i][j]=C[j]; &#125; for (int i=0; i&lt;=n1+n2; i++) printf("%d ",CRT(a[0][i],a[1][i],a[2][i])); return 0;&#125;]]></content>
      <categories>
        <category>FFT/NTT</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-11525] Permutation 树状数组求kth element+康托展开]]></title>
    <url>%2F2018%2F02%2F22%2FUVa-11525-Permutation-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82kth-element-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[题面传送门: UVa-11525 题目大意:输出1..n的全部排列字典序大小的第\sum_{i=1}^{k} S_i * (K-i)!个 样例12345678910111213141516Sample Input432 1 031 0 042 1 1 041 2 1 0Sample Output3 2 12 1 33 2 4 12 4 3 1 思路康托展开了解一下 X = a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[1]*0!其中a[i]为第i位往右边的数里第几大其实和数位dp一个道理。具体的栗子（摘自cnblog） 如我想知道321是{1,2,3}中第几个大的数可以这样考虑 ：\\\\\ 第一位是3，当第一位的数小于3时，\\\\ 那排列数小于321 如 123、 213 ，小于3的数有1、2 。\\\\ 所以有2*2!个。再看小于第二位2的：小于2的数只有一个就是1 ，\\\\所以有1*1!=1 所以小于321的{1,2,3}排列数有2*2!+1*1!=5个 。\\\\所以321是第6个大的数。 \\\\2*2!+1*1!是康托展开。然后是树状数组（Fenwick树）求第k小 这其实是一个反向枚举构造+二分的过程 具体看代码实现吧。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define maxn 50005using namespace std;#define lowbit(x) (x&amp;-x)int c[maxn], K;void add(int pos)&#123; while(pos&lt;=K)&#123; c[pos]++; pos+=lowbit(pos); &#125;&#125;int query(int pos)&#123; int res=0; while(pos&gt;0)&#123; res+=c[pos]; pos-=lowbit(pos); &#125; return res;&#125;int BS(int num)&#123; int l=0,r=K+1; while(l&lt;r-1)&#123; int mid=(l+r)/2; if(mid-query(mid)&gt;=num) r=mid; else l=mid; &#125; return r;&#125;int main(int argc, char *argv[])&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;K); memset(c,0,sizeof(c)); for(int i=0;i&lt;K;i++) &#123; int t; scanf("%d",&amp;t); t++; int k=BS(t); printf("%d%c",k,(i==K-1)?'\n':' '); add(k); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-12299] RMQ with Shifts 线段树单点修改区间查询]]></title>
    <url>%2F2018%2F02%2F22%2FUVa-12299-RMQ-with-Shifts-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[题面传送门: UVa-12299 题目大意:在传统的RMQ问题上多附加一个shift(x_1,x_2,...,x_n)的操作,使得这些操作的数列轮换一位。 给出的规模是n \leq 100000,q \leq 250000 样例看传送门吧. 思路但是,,输入中操作行的字符串长度小于等于30. 也就是说shift操作里的元素不会很多。 那么就暴力地上吧. 于是第一次写出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1const int maxn = 1e5+10;int n,q,a[maxn],b[maxn];char req;vector&lt;int&gt;r,w;inline void read(int &amp;x)&#123; x=0;char ch=getchar();if(ch=='\n')&#123;x=-2333333;return;&#125;int f=1; while(!isdigit(ch))&#123;if (ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;struct SegmentTree&#123; int lazy[maxn&lt;&lt;2],minv[maxn&lt;&lt;2]; void pushup(int rt)&#123;minv[rt] = min(minv[lc],minv[rc]);&#125; void build(int rt,int l,int r) &#123; if (l == r) &#123; minv[rt] = a[l]; return ; &#125; int m = (l+r) &gt;&gt; 1; build(lc,l,m); build(rc,m+1,r); pushup(rt); &#125; void update(int p,int v,int L,int R,int rt) // LR修改区间 &#123; if (L == R) &#123; minv[rt] = v; return ; &#125; int m = (L+R) &gt;&gt; 1; if(p &lt;= m) update(p,v,L,m,lc); else update(p,v,m+1,R,rc); pushup(rt); &#125; int query(int ql,int qr,int l,int r,int rt) &#123; int ans = INT_MAX,m = (l+r)&gt;&gt;1; if (ql &lt;= l &amp;&amp; qr &gt;= r) return minv[rt]; if (ql &lt;= m) ans = min(ans,query(ql,qr,l,m,lc)); if (qr &gt; m) ans = min(ans,query(ql,qr,m+1,r,rc)); return ans; &#125;&#125;Tree;int main(int argc, char *argv[])&#123; read(n); read(q); for (int i = 1; i &lt;= n; i++) read(a[i]); Tree.build(1,1,n); while(q--) &#123; req = '6'; memcpy(b,a,sizeof(a)); while(!isalpha(req)) req = getchar(); if (req == 'q') &#123; int x,y; read(x),read(y); printf("%d\n",Tree.query(x,y,1,n,1)); &#125; else if (req == 's') &#123; int x; r.clear(); read(x); while(x!=-2333333) &#123; r.push_back(x); read(x); &#125; for (int i = 0; i &lt; r.size(); i++) &#123; //printf("Elements: "); //printf("%d ",r[i]); //puts(""); if (i == r.size()-1) a[r[i]] = b[r[0]],Tree.update(r[i],b[r[0]],1,n,1); else a[r[i]] = b[r[i+1]],Tree.update(r[i],b[r[i+1]],1,n,1); &#125; &#125; &#125; return 0;&#125; 中间字符串处理卡了好久哦.不得不在快读中加判断换行返回-2333333来皮一波. 但是T飞了.. 检查了半天没觉得哪里不对劲,然后尝试着把vector改成了定长数组,把memcpy去掉. 就过了.. 实践证明,memcpy确实慢的可以. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1const int maxn = 1e5+10;int n,q,a[maxn],b[maxn];char req;int r[41],w[41],cnt = 0;inline void read(int &amp;x)&#123; x=0;char ch=getchar();if(ch=='\n')&#123;x=-2333333;return;&#125;int f=1; while(!isdigit(ch))&#123;if (ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;struct SegmentTree&#123; int lazy[maxn&lt;&lt;2],minv[maxn&lt;&lt;2]; void pushup(int rt)&#123;minv[rt] = min(minv[lc],minv[rc]);&#125; void build(int rt,int l,int r) &#123; if (l == r) &#123; minv[rt] = a[l]; return ; &#125; int m = (l+r) &gt;&gt; 1; build(lc,l,m); build(rc,m+1,r); pushup(rt); &#125; void update(int p,int v,int L,int R,int rt) // LR修改区间 &#123; if (L == R) &#123; minv[rt] = v; return ; &#125; int m = (L+R) &gt;&gt; 1; if(p &lt;= m) update(p,v,L,m,lc); else update(p,v,m+1,R,rc); pushup(rt); &#125; int query(int ql,int qr,int l,int r,int rt) &#123; int ans = INT_MAX,m = (l+r)&gt;&gt;1; if (ql &lt;= l &amp;&amp; qr &gt;= r) return minv[rt]; if (ql &lt;= m) ans = min(ans,query(ql,qr,l,m,lc)); if (qr &gt; m) ans = min(ans,query(ql,qr,m+1,r,rc)); return ans; &#125;&#125;Tree;int main(int argc, char *argv[])&#123; read(n); read(q); for (int i = 1; i &lt;= n; i++) read(a[i]); Tree.build(1,1,n); while(q--) &#123; req = '6'; while(!isalpha(req)) req = getchar(); if (req == 'q') &#123; int x,y; read(x),read(y); printf("%d\n",Tree.query(x,y,1,n,1)); &#125; else if (req == 's') &#123; int x; cnt = 0; read(x); while(x!=-2333333) &#123; r[++cnt] = x; w[cnt] = a[x]; read(x); &#125; for (int i = 1; i &lt;= cnt-1; i++) a[r[i]] = w[i+1],Tree.update(r[i],w[i+1],1,n,1); a[r[cnt]] = w[1],Tree.update(r[cnt],w[1],1,n,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-5902] Movie Collection Fenwick树]]></title>
    <url>%2F2018%2F02%2F22%2FLA-5902-Movie-Collection-Fenwick%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题面传送门:LA-5902 题目大意:有n个物品从上到下放置,并且标号1..n,有n次查询,每次查询标号为x的物品现在的位置（0..n,即该物品上面有多少个物品）,同时将该物品取出放到第0号位置。 样例123456789Sample Input23 33 1 15 34 4 5Sample Output2 1 03 0 4 思路还是不难想到的,将1~n件物品重新编号,1~n标为n~1,每次拿出一件物品x,再将其重新编号,如果是第一次拿出就标为n+1…..依次递增,然后将之前的编号删掉,插入新的编号即可，用一个树状数组维护 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2*1e5+10;#define lowbit(x) (x&amp;-x)int T,n,m;int pos[maxn],c[maxn];inline void read(int &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;int sum(int x)&#123; int ret = 0; while(x)&#123;ret+=c[x];x-=lowbit(x);&#125; return ret;&#125;void add(int x,int d)&#123; while(x&lt;=maxn) &#123; c[x]+=d; x+=lowbit(x); &#125;&#125;int main(int argc, char *argv[])&#123; read(T); while(T--) &#123; read(n),read(m); for (int i = 1; i &lt;= n; i++) pos[i] = n + 1 - i; for (int i = 1; i &lt; maxn; i++) c[i] = lowbit(i); int t = n; for (int i = 0; i &lt; m; i++) &#123; int id; read(id); if (i != 0) printf(" "); printf("%d",n-sum(pos[id])); add(pos[id],-1); pos[id] = ++t; &#125; printf("\n"); &#125; return 0;&#125; 一看Rank榜是第一. 窃喜]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-4108] Skyline 线段树/树状数组+二分]]></title>
    <url>%2F2018%2F02%2F22%2FLA-4108-Skyline-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[题面传送门: LA-4108 样例Sample Input135 11 31 10 13 13 20Sample Output14 思路线段树区间更新维护最大值即可 裸题啊 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1#define maxn 100010inline void read(int &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;int ans = 0,n;struct SegmentTree&#123; int lazy[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2]; void Pushup(int rt) &#123; maxv[rt] = max(maxv[lc],maxv[rc]); &#125; void Pushdown(int rt) &#123; lazy[lc] = max(lazy[lc],lazy[rt]); lazy[rc] = max(lazy[rc],lazy[rt]); &#125; void Update(int rt,int l,int r,int x,int y,int v) &#123; if (lazy[rt] &gt; v) return ; if (x &lt;= l &amp;&amp; y &gt;= r &amp;&amp; v &gt;= maxv[rt]) &#123; ans += (r-l+1); maxv[rt] = v; lazy[rt] = v; return ; &#125; if (l == r) return ; Pushdown(rt); int m = (l+r) &gt;&gt; 1; if (x &lt;= m) Update(lc,l,m,x,y,v); if (y &gt; m) Update(rc,m+1,r,x,y,v); Pushup(rt); &#125;&#125;Tree;int main(int argc, char *argv[])&#123; int t,f,g,h; read(t); &#123; while(t--) &#123; ans = 0; memset(Tree.lazy,0,sizeof(Tree.lazy)); memset(Tree.maxv,0,sizeof(Tree.maxv)); read(n); while(n--) &#123; read(f),read(g),read(h); Tree.Update(1,1,maxn,f,g-1,h); &#125; printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-2191] Potentiometers 树状数组]]></title>
    <url>%2F2018%2F02%2F22%2FLA-2191-Potentiometers-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题面传送门:LA-2191 题目大意:基本树状数组的操作，把add(x,d)改成了S(x,d)，把第x位上的变成d. 样例3100100100M 1 1M 1 3S 2 200M 1 2S 3 0M 2 3END1012345678910M 1 10END0Sample OutputCase 1:100300300200Case 2:55 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std; const int MAXN=200000+10; int a[MAXN],c[MAXN],n; inline int lowbit(const int &amp;x)&#123;return x&amp;(-x);&#125; void add(int x,int d) &#123; while(x&lt;=n) &#123; c[x]+=d; x+=lowbit(x); &#125; &#125; long long sum(int L,int R) &#123; int x=R; long long ans=0; while(x&gt;0) &#123; ans+=c[x]; x-=lowbit(x); &#125; return ans; &#125; int main(int argc,char *argv[]) &#123; int kase=1; while(scanf("%d",&amp;n),n) &#123; if(kase!=1) printf("\n"); printf("Case %d:\n",kase++); memset(c,0,sizeof(c)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); add(i,a[i]); &#125; char action[10]; while(scanf("%s",action),strcmp(action,"END")) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); if(action[0]=='S') &#123; add(x,y-a[x]); a[x]=y; &#125; else &#123; printf("%lld\n",sum(x,y)-sum(1,x-1));&#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-4730] Kingdom 并查集+线段树]]></title>
    <url>%2F2018%2F02%2F22%2FLA-4730-Kingdom-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题面传送门:LA-4730 题目大意： There were N cities in an ancient kingdom. In the beginning of the kingdom, all cities were isolated. Kings ordered their subjects to construct roads connecting cities. A lot of roads were built with time. Every road was always constructed along the line segment between two cities. All cities are partitioned into disjoint components of cities by road-connectivity. A connected component of cities was called a state. A state consists of cities and roads connecting them. A historical record tells a time sequence of road constructions in order. A road connecting two citiesA and B doesn’t intersect with other roads at a point except forA and B. Before construction,A and B may have belonged to the same state or different states. After construction,A and B would belong to a same state, i.e., two states would merge into a state if needed. Prof. Kim, a historian, is concerned about the following question: How many states does a horizontal line (corresponding to the latitude of a specific place) pass by at a moment of the past? The figure below shows an example of a configuration of roads at some moment. A circle represents a city and a line segment represents a road between two cities. There are 3 states. A line with y = 4.5 passes by two states with total 8 cities and a line with y = 6.5 passes by one state with 5 cities. （逃 正经： 平面上有n个城市，初始时城市之间没有任何双向道路相连。你的任务是一次执行以下指令。 road A B：在城市A和B之间连一条双向道路，保证这条道路不和其他道路在非端点处相交。 line C：询问一条Y=C的水平线和多少个州相交，以及这些州一共包含多少座城市。 思路看到包含多少城市想到并查集。这里如果单个枚举的话很费时间会T飞 我们就用线段树来维护区间内的城市数量和州的数量。 发现其实这题与x轴上的大小值没有任何关系。 只要考虑y轴坐标的上下最值即可 注意分类讨论。 以及并查集的时候别忘记 路径压缩 线段树update别写炸 就A了 代码3617啊珂怕 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1const int maxn = 1e5+5; int miny[maxn],maxy[maxn],n,m,fa[maxn],d[maxn];int getf(int x)&#123;return x == fa[x] ? x : fa[x] = getf(fa[x]);&#125;inline void read(int &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;struct SegmentTree&#123; int sum1[maxn&lt;&lt;2],sum2[maxn&lt;&lt;2]; int lazy1[maxn&lt;&lt;2],lazy2[maxn&lt;&lt;2]; void Pushup(int rt) &#123; sum1[rt] = sum1[rc] + sum1[lc]; sum2[rt] = sum2[rc] + sum2[lc]; &#125; void Pushdown(int rt) &#123; if (lazy1[rt]) &#123; sum1[lc] += lazy1[rt]; sum2[rc] += lazy1[rt]; lazy1[lc] += lazy1[rt]; lazy1[rc] += lazy1[rt]; lazy1[rt] = 0; &#125; if (lazy2[rt]) &#123; sum1[lc] += lazy2[rt]; sum2[rc] += lazy2[rt]; lazy2[lc] += lazy2[rt]; lazy2[rc] += lazy2[rt]; lazy2[rt] = 0; &#125; &#125; void update(int rt,int l,int r,int L,int R,int x,int f) &#123; if (L &gt; R) return ; if(L &lt;= l &amp;&amp; R &gt;= r) &#123; if(!f) &#123; lazy1[rt] += x; sum1[rt] += x; &#125; else &#123; lazy2[rt] += x; sum2[rt] += x; &#125; return ; &#125; Pushdown(rt); int m = (l+r) &gt;&gt; 1; if (l &lt;= m) update(lc,l,m,L,R,x,f); if (r &gt; m) update(rc,m+1,r,L,R,x,f); Pushup(rt); &#125; int query(int rt,int l,int r,int c) &#123; if (l == r) return rt; Pushdown(rt); int m = (l+r) &gt;&gt; 1; if (c &lt;= m) return query(lc,l,m,c); else Pushup(rt); &#125;&#125;Tree;inline void set_init()&#123; memset(miny,0,sizeof(miny)); memset(maxy,0,sizeof(maxy)); memset(Tree.lazy1,0,sizeof(Tree.lazy1)); memset(Tree.sum1,0,sizeof(Tree.sum1)); memset(Tree.lazy2,0,sizeof(Tree.lazy2)); memset(Tree.sum2,0,sizeof(Tree.sum2)); for (int i = 1; i &lt;= n; i++) fa[i] = i; memset(d,1,sizeof(d));&#125;int main(int argc, char *argv[])&#123; int T,Lim; int x,y;double c; char opt[13]; read(T); while(T--) &#123; Lim = -0x7fffffff; read(n); set_init(); for (int i = 1; i &lt;= n; i++) &#123; int t1,t2; read(t1),read(t2); miny[i] = maxy[i] = t2; Lim = max(Lim,t2); &#125; Lim++; read(m); while(m--) &#123; scanf("%s",&amp;opt); if(opt[0] == 'r') &#123; read(x);read(y); int px = getf(x),py = getf(y); if(px == py) ; else &#123; if (maxy[px] &gt; maxy[py]) swap(px,py); if (miny[py] &gt; maxy[px]) &#123; Tree.update(1, 1, Lim, maxy[px] + 1, miny[py], 1, 0); Tree.update(1, 1, Lim, maxy[px] + 1, miny[py], d[px] + d[py], 1); Tree.update(1, 1, Lim, miny[px] + 1, maxy[px], d[py], 1); Tree.update(1, 1, Lim, miny[py] + 1, maxy[py], d[px], 1); &#125; else if (miny[px] &gt; miny[py]) &#123; Tree.update(1, 1, Lim, miny[px] + 1, maxy[px], -1, 0); Tree.update(1, 1, Lim, miny[py] + 1, miny[px], d[px], 1); Tree.update(1, 1, Lim, maxy[px] + 1, maxy[py], d[px], 1); &#125; else &#123; Tree.update(1, 1, Lim, miny[py] + 1, maxy[px], -1, 0); Tree.update(1, 1, Lim, miny[px] + 1, miny[py], d[py], 1); Tree.update(1, 1, Lim, maxy[px] + 1, maxy[py], d[px], 1); &#125; fa[px] = py; d[py] += d[px]; miny[py] = min(miny[py], miny[px]); maxy[py] = max(maxy[py], maxy[px]); &#125; &#125; else &#123; scanf("%lf",&amp;c); int k = Tree.query(1,1,Lim,(int)(c+1)); printf("%d %d\n",Tree.sum1[k],Tree.sum2[k]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间信息的维护和查询学习笔记]]></title>
    <url>%2F2018%2F02%2F18%2F%E5%8C%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%B4%E6%8A%A4%E5%92%8C%E6%9F%A5%E8%AF%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[终于开始磕高级数据结构了 二叉索引树Binary Index Tree（树状数组）动态的连续和查询问题,有n个元素的数组设计一个数据结构,支持以下两种操作:Add(x,d) 让A[x]增加dQuery(L,R) 计算A[L]+..+A[R]. 首先介绍一个玩意叫做lowbit(x) 对于正整数x我们定义它的二进制最右边的1的值为lowbit(x)在讲BIT之前，我们来先了解一个函数：对于任意正整数x，我们定义lowbit(x)为x的二进制中最右边的1所对应的值，比如，5的二进制是101，那么lowbit(5)= 1；4的二进制是100，那么lowbit(4) = 4；这里用到的是按位运算，请读者自己去查阅关于这点的资料。但为什么呢？计算机里面的整数采用补码表示，-x实际上是x在二进制中按位取反，末位+1后的结果，二者按位取“与”之后，前面全部变成0，之后的lowbit保持不变。 简单的两个操作如下12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int n,m,a[maxn],C[maxn];#define lowbit(x) (x&amp;-x)int sum(int x)&#123; int ret = 0; while(x) &#123; ret += C[x]; x -= lowbit(x); &#125; return ret;&#125;void add(int x,int d)&#123; while(x &lt;= n) &#123; C[x] += d; x += lowbit(x); &#125;&#125;int query(int l,int r)&#123;return (sum(r)-sum(l-1));&#125;int main(int argc, char *argv[])&#123; memset(C,0,sizeof(C)); scanf("%d%d",&amp;n,&amp;m); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d",&amp;x); a[i] = x; add(i,x); &#125; while(m--) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",query(x,y)); &#125; return 0;&#125; 主要是add和sum这两个操作可以用蓝书上两张图记忆 LA-4329 Ping Pong传送门:LA-4329 题目大意:给定一个n个元素的数组，每个元素都有位置和实力两个权值，求三元组(al,ar,ap)的个数,其中要求无论是位置还是实力值都要满足l&lt;p&lt;r. 思路:加法原理，我们只要求出在第i个人当裁判的时候在前后比a[i]小或是比a[i]大的个数，就可以用乘法原理和加法原理计算了。所以问题转化为求这个比a[i]小的c[i]和比a[i]大的d[i]即可.要求动态，这样就可以套上树状数组了。代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;int T,n,a[maxn],C[maxn],D[maxn],bit[maxn];int lowbit(int x)&#123;return (x&amp;-x);&#125;int sum(int x)&#123; int ret = 0; while(x) &#123; ret += bit[x]; x -= lowbit(x); &#125; return ret;&#125;void add(int x,int d)&#123; while(x &lt;= 1e5+10) &#123; bit[x] += d; x += lowbit(x); &#125;&#125;int main(int argc, char *argv[])&#123; scanf("%d",&amp;T); while(T--) &#123; long long ans = 0; memset(bit,0,sizeof(bit)); memset(C,0,sizeof(C)); memset(D,0,sizeof(D)); scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d",&amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; add(a[i],1); C[i] = sum(a[i]-1); &#125; memset(bit,0,sizeof(bit)); for (int i = n; i &gt;= 1; i--) &#123; add(a[i],1); D[i] = sum(a[i]-1); &#125; for (int i = 2; i &lt;= n; i++) ans += C[i] * (n-i-D[i]) + D[i] * (i-1-C[i]); printf("%lld\n",ans); &#125; return 0;&#125; RMQ问题RMQ,即Range Minimum Query,要求给出一个n个元素的数值,能够查询出区间范围内的元素最小值 ST(Sparse Table)表O(nlogn) ~ O(1)利用递推的思想,令d(i,j)表示从i开始,长度为2^j的一段元素中的最小值,那么有这样的递推式d(i,j)= min(d(i,j-1),d(i+2^(j-1),j-1));不难写出这样的代码123456789101112131415161718192021222324252627282930313233343536//RMQ问题 #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+10;int a[maxn];int d[maxn][100]; // d[maxn][maxlog(n)];void RMQ_init(int a[],int n)&#123; for (int i = 1; i &lt;= n; i++) d[i][0] = a[i]; for (int j = 1; (1&lt;&lt;j) &lt;= n; j++) for (int i = 0; i + (1&lt;&lt;j) - 1 &lt;= n; i++) //可以从第0位置开始 d[i][j] = min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]);&#125; int RMQ_query(int l,int r)&#123; int k = 0; while((1&lt;&lt;(k+1)) &lt;= r-l+1) k++; return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]);&#125;int main(int argc, char *argv[])&#123; int n,t,q,x; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d",&amp;a[i]); RMQ_init(a,n); scanf("%d",&amp;q); while(q--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",RMQ_query(l,r)); &#125; return 0;&#125; 笛卡尔树 + LCA + ±RMQO(n) ~ O(1)这是个巨复杂的方法很难写对 挂个链接就跑http://blog.csdn.net/john159151/article/details/19411523 线段树定义假设有编号从1到n的n个点，每个点都存了一些信息，用[L,R]表示下标从L到R的这些点。线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是O(log2(n)). 线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4 * n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。 所以满足用线段树解决的题目必须要能够符合区间加法的原则,保证分成的子区间L,R能够得到正确的统计结果，换言之，要能够满足子区间答案之和为总区间答案的原则。 符合区间加法的例子：数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );最大值——总最大值=max(左区间最大值，右区间最大值) 不符合区间加法的例子：众数——只知道左右区间的众数，没法求总区间的众数01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零 原理线段树本质上是维护下标为1,2,..,n的n个按顺序排列的数的信息，所以，其实是“点树”，是维护n的点的信息. 线段树是将每个区间[L,R]分解成[L,M]和[M+1,R] (其中M=(L+R)/2 这里的除法是整数除法，即对结果下取整)直到 L==R 为止。 开始时是区间[1,n] ,通过递归来逐步分解，假设根的高度为1的话，树的最大高度为 \log_2(n-1)+2线段树对于每个n的分解是唯一的，所以n相同的线段树结构相同，这也是实现可持久化线段树的基础。关于lazy标记思想:线段树的区间修改也是将区间分成子区间，但是要加一个标记，称作懒惰标记。标记的含义：本节点的统计信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。即，如果要给一个区间的所有值都加上1，那么，实际上并没有给这个区间的所有值都加上1，而是打个标记，记下来，这个节点所包含的区间需要加1.打上标记后，要根据标记更新本节点的统计信息，比如，如果本节点维护的是区间和，而本节点包含5个数，那么，打上+1的标记之后，要给本节点维护的和+5。这是向下延迟修改，但是向上显示的信息是修改以后的信息，所以查询的时候可以得到正确的结果。有的标记之间会相互影响，所以比较简单的做法是，每递归到一个区间，首先下推标记（若本节点有标记，就下推标记），然后再打上新的标记，这样仍然每个区间操作的复杂度是O(log2(n))。标记有相对标记和绝对标记之分：相对标记是将区间的所有数+a之类的操作，标记之间可以共存，跟打标记的顺序无关（跟顺序无关才是重点）。所以，可以在区间修改的时候不下推标记，留到查询的时候再下推。注意：如果区间修改时不下推标记，那么PushUp函数中，必须考虑本节点的标记。而如果所有操作都下推标记，那么PushUp函数可以不考虑本节点的标记，因为本节点的标记一定已经被下推了（也就是对本节点无效了）绝对标记是将区间的所有数变成a之类的操作，打标记的顺序直接影响结果，所以这种标记在区间修改的时候必须下推旧标记，不然会出错。注意，有多个标记的时候，标记下推的顺序也很重要，错误的下推顺序可能会导致错误。 具体实现在线段树中 我们可以采用数组构造完全二叉树的方式，使得如果根节点为rt，左儿子就为2 rt,右儿子就为2 rt+1. 但是可以装个bi这么写12#define lc rt&lt;&lt;1 #define rc rt&lt;&lt;1|1 单点修改下面以codevs1080的单点修改求区间和的例子演示具体写法传送门:Codevs-10801234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+7;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1int n,m,a[maxn];struct SegmentTree&#123; int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2]; void Pushup(int rt)&#123;sum[rt] = sum[lc]+sum[rc];&#125; void Pushdown(int rt,int ln,int rn) &#123; if(lazy[rt]) &#123; lazy[lc]+=lazy[rt]; lazy[rc]+=lazy[rt]; sum[lc]+=lazy[rt]*ln; sum[rc]+=lazy[rt]*rn; lazy[rt] = 0; &#125; &#125; void build(int l,int r,int rt) &#123; if (l == r) &#123; sum[rt] = a[l]; return ; &#125; int mid = (l+r) &gt;&gt; 1; build(l,mid,lc); build(mid+1,r,rc); Pushup(rt); &#125; void update(int q,int v,int l,int r,int rt)//A[q] += v; &#123; if (l == r) &#123; sum[rt] += v; return ; &#125; int mid = (l+r) &gt;&gt; 1; if (q &lt;= mid) update(q,v,l,mid,lc); else update(q,v,mid+1,r,rc); Pushup(rt); &#125; int query(int L,int R,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int mid = (l+r) &gt;&gt; 1; Pushdown(rt,mid-l+1,r-mid); int ans = 0; if (L &lt;= mid) ans += query(L,R,l,mid,lc); if (R &gt; mid) ans += query(L,R,mid+1,r,rc); return ans; &#125;&#125;Tree;int main(int argc, char *argv[])&#123; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d",&amp;a[i]); Tree.build(1,n,1); scanf("%d",&amp;m); while(m--) &#123; int opt,x,y; scanf("%d%d%d",&amp;opt,&amp;x,&amp;y); if (opt == 1) Tree.update(x,y,1,n,1); else printf("%d\n",Tree.query(x,y,1,n,1)); &#125; return 0;&#125; 一遍就过了真是神奇 区间修改大致格式差不多长这个样子 123456789101112131415161718192021222324252627282930313233343536void Change(int p, int l, int r, int L, int R)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; 修改点p的状态至它应该成为的状态 p上附加上一个能够影响它整个子树的tag return; &#125; if (p上面有tag) &#123; 将p的两个儿子调整至它们应该成为的状态 清除p上的tag &#125; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) Change(p的左儿子, l, m, L, R); if (R &gt; m) Change(p的右儿子, m + 1, r, L, R); p的状态 = 它左右两个儿子的合并&#125;node Query(int p, int l, int r, int L, int R)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return p的状态 if (p上面有tag) &#123; 将p的两个儿子调整至它们应该成为的状态 清除p上的tag &#125; int m = (l + r) &gt;&gt; 1; if (R &lt;= m) return Query(p的左儿子, l, m, L, R); if (L &gt; m) return Query(p的右儿子, m + 1, r, L, R); return Query(p的左儿子, l, m, L, R) 和 Query(p的右儿子, m + 1, r, L, R) 的结果的合并&#125; 这个玩意撸了好久啊。蓝书问题3.2.4(2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1const int maxn = 1e5+10;int n,m,a[maxn];int _sum,_min = INT_MAX,_max = -INT_MAX;struct SegmentTree&#123; int minv[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2],sum[maxn&lt;&lt;2]; void Pushup(int rt) &#123; sum[rt] = sum[lc]+sum[rc]; minv[rt] = min(minv[lc],minv[rc]); maxv[rt] = max(maxv[lc],maxv[rc]); &#125; void Pushdown(int rt) &#123; if (lazy[rt]) &#123; lazy[lc] += lazy[rt]; lazy[rc] += lazy[rt]; lazy[rt] = 0; &#125; &#125; void Maintain(int rt,int l,int r) &#123; sum[rt] = maxv[rt] = minv[rt] = 0; if (r &gt; l) &#123; sum[rt] = sum[lc] + sum[rc]; minv[rt] = min(minv[lc],minv[rc]); maxv[rt] = max(maxv[lc],maxv[rc]); &#125; minv[rt] += lazy[rt]; maxv[rt] += lazy[rt]; sum[rt] += lazy[rt] * (r-l+1); &#125; void build(int l,int r,int rt) &#123; if(l == r) &#123; minv[rt] = a[l]; maxv[rt] = a[l]; sum[rt] = a[l]; return ; &#125; int mid = (l+r) &gt;&gt; 1; build(l,mid,lc); build(mid+1,r,rc); Pushup(rt); &#125; void update(int l,int r,int v,int L,int R,int rt) &#123; if (l &lt;= L &amp;&amp; r &gt;= R) lazy[rt] += v; else &#123; Pushdown(rt); //?? int mid = (L+R) &gt;&gt; 1; if (l &lt;= mid) update(l,r,v,L,mid,lc); else Maintain(lc,L,mid); if (r &gt; mid) update(l,r,v,mid+1,R,rc); else Maintain(rc,mid+1,R); &#125; Maintain(rt,L,R); &#125; void query(int rt,int l,int r,int L,int R,int ret) &#123; _sum = 0; _min = INT_MAX; _max = -INT_MAX; printf("%d %d %d %d %d %d\n",rt,l,r,L,R,ret); if(l &lt;= L &amp;&amp; r &gt;= R) &#123; _sum += sum[rt] + ret * (R-L+1); _min = min(_min,minv[rt]+ret); _max = max(_max,maxv[rt]+ret); &#125; else &#123; int mid = (L+R) &gt;&gt; 1; if (l &lt;= mid) query(lc,l,r,L,mid,ret + lazy[rt]); if (r &gt; mid) query(rc,l,r,mid+1,R,ret + lazy[rt]); &#125; &#125;&#125;Tree;int main(int argc, char *argv[])&#123; scanf("%d %d",&amp;n,&amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d",&amp;a[i]); Tree.build(1,n,1); while(m--) &#123; int x,a,b,c; scanf("%d",&amp;x); if (x == 1) &#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); Tree.update(a,b,c,1,n,1); &#125; else &#123; scanf("%d %d",&amp;a,&amp;b); Tree.query(1,a,b,1,n,0); printf("Minv: %d Maxv: %d Sumv: %d\n",_min,_max,_sum); &#125; &#125; return 0;&#125; 还有一个写法稍微不一样的板子但是和蓝书上面的两个问题是匹配的挂上来咯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000+ 10;//update_add:把A[L]~A[R]的值全部加v_add//update_set:把A[l]~A[R]的值设为v_set//query:计算子序列的元素和，最小值，最大值int sumv[2*maxn],minv[2*maxn],maxv[2*maxn];int addv[2*maxn], setv[2*maxn];int y11, y2, v_add, v_set;void maintain(int o, int L, int R) &#123; int lc = 2*o, rc = 2*o + 1; sumv[o] = minv[o] = maxv[o] = 0; if(setv[o] &gt;= 0) &#123; sumv[o] = setv[o] * (R-L+1); minv[o] = maxv[o] = setv[o]; &#125; else if(R &gt; L) &#123; sumv[o] = sumv[lc] + sumv[rc]; minv[o] = min(minv[lc], minv[rc]); maxv[o] = max(maxv[lc], maxv[rc]); &#125; minv[o] += addv[o]; maxv[o] += addv[o]; sumv[o] += addv[o] * (R-L+1);&#125;void pushdown(int o) &#123; int lc = 2*o, rc = 2*o+1; if(setv[o] &gt;= 0) &#123; setv[lc] = setv[rc] = setv[o]; addv[lc] = addv[rc] = 0; setv[o] = -1; &#125; if(addv[o] &gt; 0) &#123; addv[lc] += addv[o]; addv[rc] += addv[o]; addv[o] = 0; &#125;&#125;void update_add(int o, int L, int R) &#123; int lc = 2*o, rc = o*2+1; if(y11 &lt;= L &amp;&amp; y2 &gt;= R) &#123; addv[o] += v_add; &#125; else &#123; pushdown(o); int M = L + (R-L)/2; if(y11 &lt;= M) update_add(lc, L, M); else maintain(lc, L, M); if(y2 &gt; M) update_add(rc, M+1, R);else maintain(rc, M+1, R); &#125; maintain(o, L, R);&#125;void update_set(int o, int L, int R) &#123; int lc = 2*o, rc = o*2+1; if(y11 &lt;= L &amp;&amp; y2 &gt;= R) &#123; setv[o] = v_set; addv[o] = 0; &#125; else &#123; pushdown(o); int M = L + (R-L)/2; if(y11 &lt;= M) update_set(lc, L, M); else maintain(lc, L, M); if(y2 &gt; M) update_set(rc, M+1, R); else maintain(rc, M+1, R); &#125; maintain(o, L, R);&#125;int _min, _max, _sum;void query(int o, int L, int R, int add) &#123; if(setv[o] &gt;= 0) &#123; _sum += (add+setv[o]+addv[o]) * (min(R, y2)-max(L, y11)+1); _min = min(_min, setv[o]+addv[o]+add); _max = max(_max, setv[o]+addv[o]+add); &#125; else if(y11 &lt;= L &amp;&amp; y2 &gt;= R) &#123; _sum += sumv[o] + add * (R-L+1); _min = min(_min, minv[o]+add); _max = max(_max, maxv[o]+add); &#125; else &#123; int M = L + (R-L)/2; if(y11 &lt;= M) query(o*2, L, M, add+addv[o]); if(y2 &gt; M) query(o*2+1, M+1, R, add + addv[o]); &#125;&#125;void init() &#123; memset(setv, -1, sizeof setv); memset(addv, 0, sizeof addv); memset(sumv, 0, sizeof sumv); memset(minv, 0, sizeof minv); memset(maxv, 0, sizeof maxv);&#125;int main(int argc, char *argv[])&#123; int n,m; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d",&amp;v_add); y11 = y2 = i; update_add(1,1,n); &#125; scanf("%d",&amp;m); while(m--) &#123; int x,a,b,c; scanf("%d",&amp;x); if (x == 1) &#123; scanf("%d %d %d",&amp;y11,&amp;y2,&amp;c); v_add = c; update_add(1,1,n); &#125; else &#123; _sum = 0; scanf("%d",&amp;y11); y2 = y11; query(1,1,n,0); printf("%d\n",_sum); &#125; &#125; return 0;&#125; 划一下习题. 树状数组: LA-2191LA-5902 线段树+其他技巧UVA-12299UVA-11525LA-4730LA-4108LA-4013]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学专题习题2]]></title>
    <url>%2F2018%2F02%2F16%2F%E6%95%B0%E5%AD%A6%E4%B8%93%E9%A2%98%E4%B9%A0%E9%A2%982%2F</url>
    <content type="text"><![CDATA[题目传送门UVa-11728UVa-10673UVa-11768UVa-10692 Code1234567891011121314151617181920212223242526272829303132333435//UVA-11728#include&lt;bits/stdc++.h&gt;using namespace std;int kase = 0,S;bool check(int n,int m)&#123; int q = sqrt(n+0.5); int ret = 0; for (int i = 1; i &lt;= q; i++) if (n % i == 0) ret += i+n/i; if (q*q == n) ret -= q; return (ret == m);&#125;int main(int argc, char *argv[])&#123; while(scanf("%d",&amp;S) == 1 &amp;&amp; S) &#123; bool flag = 0; if (S == 1) &#123; printf("Case %d: 1\n",++kase); continue; &#125; for (int i = S-1; i &gt;= 1; i--) if (check(i,S)) &#123; flag = 1; printf("Case %d: %d\n",++kase,i); break; &#125; if(!flag) printf("Case %d: %d\n",++kase,-1); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445// UVA-10673#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline void getLL(LL &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-') f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;void ex_gcd(LL a,LL b,LL &amp;X,LL &amp;Y,LL &amp;d)&#123; if (!b)&#123;d=a;X=1;Y=0;&#125; else &#123; ex_gcd(b,a%b,Y,X,d); Y-=(a/b)*X; &#125;&#125;LL T,x,k,a,b,X,Y,d;int main(int argc, char *argv[])&#123; getLL(T); while(T--) &#123; getLL(x);getLL(k); a = floor(double(x)/double(k)); b = ceil(double(x)/double(k)); d = a == b ? a : 1; if (a == b) X = 0,Y = k; else &#123; ex_gcd(a,b,X,Y,d); X *= x, Y *= x; &#125; printf("%lld %lld\n",X,Y); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445//UVA-11768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;void exgcd(ll a,ll b,ll&amp; g,ll&amp; x,ll&amp; y)&#123; if(!b) g=a,x=1,y=0; else exgcd(b,a%b,g,y,x),y-=x*(a/b);&#125;double X1,Y1,X2,Y2;ll solve()&#123; ll x1=(X1+0.05)*10,y1=(Y1+0.05)*10,x2=(X2+0.05)*10,y2=(Y2+0.05)*10; if(x1==x2) &#123; if(x1%10) return 0; if(Y2&lt;Y1) swap(Y1,Y2); return floor(Y2)-ceil(Y1)+1; &#125; if(y1==y2) &#123; if(y1%10) return 0; if(X2&lt;X1) swap(X1,X2); return floor(X2)-ceil(X1)+1; &#125; ll a=(y2-y1)*10,b=(x1-x2)*10,c=y2*x1-y1*x2,g,x,y; exgcd(a,b,g,x,y); if(c%g) return 0; x*=c/g;b=abs(b/g); if(X1&gt;X2) swap(X1,X2); x1=ceil(X1);x2=floor(X2);x-=(x-x1)/b*b; if(x&lt;x1) x+=b; if(x2&lt;x) return 0; return (x2-x)/b+1;&#125;int main(int argc, char *argv[])&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%lf%lf%lf%lf",&amp;X1,&amp;Y1,&amp;X2,&amp;Y2); printf("%lld\n",solve()); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//UVA-10692#include&lt;bits/stdc++.h&gt;const int maxn = 15;int A[maxn], k;int pow_mod(int a, int n, int M) &#123; int ans = 1; while (n) &#123; if (n&amp;1) ans = ans * a % M; a = a * a % M; n /= 2; &#125; return ans;&#125;int euler_phi(int n)&#123; int m = (int)sqrt(n+0.5); int ans = n; for (int i = 2; i &lt;= m; i++) &#123; if (n % i == 0) &#123; ans = ans / i * (i-1); while (n%i==0) n /= i; &#125; &#125; if (n &gt; 1) ans = ans / n * (n - 1); return ans;&#125;int solve (int d, int M) &#123; if (d == k - 1) return A[d]%M; int phi = euler_phi(M); int c = solve (d+1, phi) + phi; return pow_mod(A[d], c, M);&#125;int main (int argc, char *argv[]) &#123; int cas = 1; char str[maxn]; while (scanf("%s", str) == 1 &amp;&amp; strcmp(str, "#")) &#123; int M; sscanf(str, "%d", &amp;M); scanf("%d", &amp;k); for (int i = 0; i &lt; k; i++) scanf("%d", &amp;A[i]); printf("Case #%d: %d\n", cas++, solve(0, M)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学专题习题]]></title>
    <url>%2F2018%2F02%2F15%2F%E6%95%B0%E5%AD%A6%E4%B8%93%E9%A2%98%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目传送门UVa-10237UVa-10883UVa-10943UVa-11038UVa-11076UVa-11388UVa-11889 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546//UVA-10237#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 40;int n, k;ll b[N][N*N],w[N][N*N];void init() &#123; memset(b, 0, sizeof(b)); memset(w, 0, sizeof(w)); b[0][0] = w[1][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; b[i][0] = b[i-1][0]; int l = (i+1)/2 * 2 - 1; for (int j = 1; j &lt;= l &amp;&amp; j &lt;= k; j++) b[i][j] = b[i-1][j] + (ll)(l-j+1) * b[i-1][j-1]; &#125; for (int i = 2; i &lt;= n; i++) &#123; w[i][0] = w[i-1][0]; int l = i/2 * 2; for (int j = 1; j &lt;= l &amp;&amp; j &lt;= k; j++) w[i][j] = w[i-1][j] + (ll)(l-j+1) * w[i-1][j-1]; &#125;&#125;int main (int argc, char *argv[]) &#123; while (scanf("%d%d", &amp;n, &amp;k) == 2 &amp;&amp; n + k) &#123; init(); ll ans = 0; for (int i = 0; i &lt;= k; i++) ans = ans + b[n][i] * w[n][k-i]; printf("%lld\n", ans); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829//UVA-10883#include&lt;bits/stdc++.h&gt;using namespace std;int T,n,kase = 0;double ln[50010],a;void init(void)&#123; ln[0] = ln[1] = 0; for (int i = 2; i &lt;= 50009; i++) ln[i] = ln[i-1]+log(i);&#125;int main(int argc, char *argv[])&#123; init(); cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; n; n--; double summ = 0.0; for (int i = 0; i &lt;= n; i++) &#123; cin &gt;&gt; a; summ += a * exp(ln[n]-ln[n-i]-ln[i]-n*ln[2]); &#125; printf("Case #%d: %.3lf\n",++kase,summ); &#125; return 0;&#125; 12345678910111213141516171819202122//UVA-10943#include&lt;bits/stdc++.h&gt;using namespace std;int N,K;int C[210][210];const int module = 1e6;void in_table(void)&#123; for (int i = 0; i &lt;= 208; i++) for (int j = 0; j &lt;= i; j++) &#123; if (i == j) C[i][j] = 1; else C[i][j] = (C[i-1][j-1]+C[i-1][j])%module; &#125; &#125;int main(int argc, char *argv[])&#123; in_table(); while(scanf("%d %d",&amp;N,&amp;K) == 2 &amp;&amp; N &amp;&amp; K) &#123;printf("%d\n",C[N+K-1][K-1]);&#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132//UVA-11038#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint m,n;int f[13],g[13]; //10^i~10^(i+1)-1int calc(int x)&#123; int ans=1,cnt=1,tmp=0; if (x &lt; 0) return 0; while(x) &#123; int c = x%10; x/=10; if (c) ans+=x*cnt; else ans+=(x-1)*cnt+tmp+1; tmp+=c*cnt; cnt*=10; &#125; return ans;&#125;signed main(signed argc, char *argv[])&#123; f[0] = g[0] = 1; for (int i = 1; i &lt;= 11; i++) f[i] = (9*(i-1))*i+i; for (int i = 1; i &lt;= 11; i++) g[i] = g[i-1]+f[i]; while(scanf("%lld%lld",&amp;n,&amp;m) == 2 &amp;&amp; n &gt;= 0 &amp;&amp; m &gt;= 0) printf("%lld\n",calc(m)-calc(n-1)); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637//UVA-11076#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[13],c[11],d[11];unsigned long long ans,t = 1;unsigned long long op(int x)&#123; unsigned long long ret = 1; int y=x; while(y) ret*=y,y--; return ret;&#125;unsigned long long op1(int x)&#123; unsigned long long ret = 0; while(x) &#123; x--; ret+=pow(10,x); &#125; return ret;&#125;int main(int argc, char *argv[])&#123; while(scanf("%d",&amp;n) == 1 &amp;&amp; n) &#123; memset(c,0,sizeof(c)); for (int i = 1; i &lt;= n; i++) scanf("%d",&amp;a[i]),c[a[i]]++; unsigned long long f = op(n),mul = op1(n); for (int i = 0; i &lt;= 9; i++) f/=(op(c[i])); for (int i = 0; i &lt;= 9; i++) d[i] = f*c[i]/n; ans = 0; for (int i = 0; i &lt;= 9; i++) ans += d[i]*i*mul; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//UVA-11388#include&lt;bits/stdc++.h&gt;using namespace std;int T;#define LL long longlong long gcd(long long x,long long y)&#123; return (y == 0) ? x : gcd(y,x%y);&#125;int main(int argc, char *argv[])&#123; ios::sync_with_stdio(false); long long T,G,L; cin &gt;&gt; T; while(T--) &#123; int flag = 0; cin &gt;&gt; G &gt;&gt; L; if (L % G != 0) &#123; cout &lt;&lt; "-1" &lt;&lt; endl; continue; &#125; else &#123; cout &lt;&lt; G &lt;&lt; " " &lt;&lt; L &lt;&lt; "\n"; continue; &#125; /* long long x = G*L; for (long long i = G; i &lt;= min((LL)sqrt(x),L); i++) &#123; if (x % i == 0) &#123; if (gcd(i,x/i) == G) &#123; printf("%lld %lld\n",i,x/i); flag = 1; break; &#125; &#125; &#125; if (!flag) printf("-1\n");*/ &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132//UVA-11889#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longlong long gcd(long long x,long long y)&#123; return (y == 0) ? x : gcd(y,x%y);&#125;signed main(signed argc, char *argv[])&#123; int A,C,T; ios::sync_with_stdio(false); cin &gt;&gt; T; while(T--) &#123; int flag = 1; cin &gt;&gt; A &gt;&gt; C; for (int i = 1; i &lt;= A; i++) if (i*C % A == 0) &#123; int B = i * C/A; if (gcd(A,B) == i) &#123; printf("%d\n",B); flag = 0; break; &#125; &#125; if (flag) puts("NO SOLUTION"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-3485] Bridge 基于定积分的二分]]></title>
    <url>%2F2018%2F02%2F13%2FLA-3485-Bridge-%E5%9F%BA%E4%BA%8E%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[题面传送门:LA-3485题目大意:给定一个抛物线的左右长度和曲线长，求抛物线的底到顶部的距离。 样例Sample Input220 101 400 40421 2 3 4Sample OutputCase 1:1.00 Case 2:1.60 思路由上一篇的学习笔记中，我们已经说明过对于一个曲线函数f(x)，如果它的导函数为f’(x),那么在a,b这一段上的曲线长度为 \int_a^b\sqrt{1+[f'(x)]^2}dx 为什么是这个样子呢？我们可以把f‘(x)展开写成\\\\\Delta y/\Delta x\\\\ 那么在对于\Delta x 趋近于0的时候,(\Delta x)^2+(\Delta y)^2就相当于一个直角三角形斜边的平方.\\\\ 开根号,就是\sqrt{\frac{(\Delta y)^2}{(\Delta x)^2}+1}\\\\ 也就是\sqrt{[f'(x)]^2+1}这里不免要运用这个去计算区间内的曲线长度。 读题，我们可以发现间隔总数为ceil(B/D).每个间隔宽度为(B/n).每个间隔的绳索长度为(L/n) 我们可以构造一个二次函数,它过0,0且开口向上。 假设w为宽,h为高 那么有a(w/2)^2 = h. 所以a = 4h/(w^2). 下面就是万恶的积分运算了！ 这里积分我算了两次，第一次是自己没用a来去替换w和h算的,算是硬头皮算的，第二次就参考蓝书了。 第一次的计算方法: 经过一番试验。 123456789double w,h = 1.0; cin &gt;&gt; w; while(1) &#123; double ans = w*w/8/h*(log(abs(sqrt(16*h*h/w/w)+4*h/w)) + 4*h/w*sqrt(16*h*h/w/w+1))/2; h += 1.0; cout &lt;&lt; ans &lt;&lt; endl; system("pause"); &#125; 发现随着h的增加这个积分的值也在增加,这是个严格递增积分。就可以用二分求解了！写出这样的代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-8;double D,H,B,L;int T;double F(double w,double h)&#123; double ans = w*w/8/h*(log(fabs(sqrt(16*h*h/w/w)+4*h/w)) + 4*h/w*sqrt(16*h*h/w/w+1))/2; ans *= 2; return ans;&#125;double calc(double L,double w)&#123; double ll = 0.0,rr = H; //while(rr-ll &gt; eps) for (int i=0;i&lt;100;i++) &#123; double mid = (ll+rr)/2; if (F(w,mid) - L &gt; eps) rr = mid; else ll = mid; &#125; return (H-ll);&#125;int main(int argc, char *argv[])&#123; scanf("%d",&amp;T); for (int kase = 1; kase &lt;= T; kase++) &#123; printf("Case %d:\n",kase); scanf("%lf%lf%lf%lf",&amp;D,&amp;H,&amp;B,&amp;L); int n = ceil(B/D); double singleL = L/double(n); double singlew = B/double(n); //printf("##debug n:%d L:%.5lf w %.5lf\n",n,singleL,singlew); printf("%.5lf\n",calc(singleL,singlew)); &#125; return 0;&#125; 兴致勃勃地对样例，发现是正确的！！！ 激动啊,自己造了几个凑好的数据发现都没有问题。 然后扔到OJ上就WA了,不管怎么调精度都是WA。 于是就考虑到这个方法可能存在误差。只不过很小很小但是在精度以内，会影响答案。 伤心，看到蓝书写的代换我真的头皮发麻 简化了a后发现其实积分中用t与dt代换x的步骤也省去了。 啊啊啊啊啊啊啊 难受 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-8;double D,H,B,LLL;int T; double f(double a,double x)&#123; double aa = a*a,xx = x*x; return (x*sqrt(aa+xx) + aa*log(fabs(x+sqrt(aa+xx))))/2;&#125;double calc(double w,double h)&#123; double a = 4*h/w/w; double b = 1/(2*a); return 4*a*(f(b,w/2)-f(b,0));&#125;int main(int argc, char *argv[])&#123; scanf("%d",&amp;T); for (int kase = 1; kase &lt;= T; kase++) &#123; if(kase &gt; 1) printf("\n"); printf("Case %d:\n",kase); scanf("%lf%lf%lf%lf",&amp;D,&amp;H,&amp;B,&amp;LLL); int n = ceil(B/D); double L = LLL/double(n); double w = B/double(n); double ll = 0.0,rr = H; while(rr-ll &gt; eps) &#123; double mid = (ll+rr)/2; if (calc(w,mid) - L &gt; eps) rr = mid; else ll = mid; &#125; printf("%.2lf\n",H-ll); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数值算法学习笔记]]></title>
    <url>%2F2018%2F02%2F13%2F%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[非线性方程求根这一部分很大情况下以来与函数本身的单调性，需要掌握一定的数学基础对函数概念要有清晰的认识。可能也要有点求导和积分的知识。还好我会 我会个毛线:) UVa-10341 Solve It!传送门:UVa-10341题目大意:试解一个方程，使得 pe^{-x}+qsin(x)+rcos(x)+stan(x)+tx^2+u =0 \space \space , x \in [0,1].\\\\ 0\leq p,r \leq 20;\\\\ -20\leq q,s,t \leq 0;光凭这个方程我们毫无办法，因为对整个函数求导可以得到. 应用分部求导法则就可以了算是简单的求导 得到 f'(x) = -pe^{-x}+qcos(x)-rsin(x)+2stan(x)sec^2(x)+2tx \\\\眼花缭乱毫无办法,凭借导函数我们看不出任何增减性的变化。 注意到x的边界为0,1。 那么有以下函数在该区间是单减的（严格递减） e^{-x};cos(x);有以下的函数在该区间单增（严格递增） sin(x);tan(x);tx^2;再看一眼题目看到了sin(x),tan(x),tx^2前面的系数都是非正的！那么相当于整个函数为在[0,1]上的减函数。 于是根据介值定理，在某一区间上（这里是[0,1]） ，这个单调递减的函数若满足f(0) &gt;= 0 &gt;= f(1). 则在[0,1]上一定有且仅有一个解. 于是二分就行了。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;using namespace std;const double eps = 1e-7;double p,q,r,s,t,u;double e = pow(double(1.0+1.0/10000),10000);double calc(double x)&#123;return (p*exp(-x)+q*sin(x)+r*cos(x)+s*tan(x)+t*x*x+u);&#125;\\e^x 可以写成exp(-x)!int main(int argc, char *argv[])&#123; while(scanf("%lf%lf%lf%lf%lf%lf",&amp;p,&amp;q,&amp;r,&amp;s,&amp;t,&amp;u) == 6) &#123; double lim0 = calc(0),lim1 = calc(1); if (lim1 &gt; 1e-9 || lim0 &lt; -1e-9) &#123; puts("No solution"); continue; &#125; double l = 0.0,r = 1.0,mid; while(r-l &gt; eps) &#123; mid = (l+r)/2; if (calc(mid) &gt; 0.0) l = mid; else r = mid; &#125; printf("%.4lf\n",l); &#125; return 0;&#125; LA-5009 Error Curves传送门:LA-5009 题目大意:给出n个抛物线（开口向上）或者直线，定义一个总函数f(x) = max{Si(x)}. 求这个总函数在[0,1000]上的最小值。 错误思路:把每个函数在[0,1000]上的最小值求出来最后一遍取最小。这样虽说看上去毫无问题，但是这个思路对于定义就是不正确的f(x)的定义是max(si(x))而不是min,也就是说,我们在处理函数时不能以偏概全,必须在某一区间上硬性规定要取的是函数的最大值,换言之,我们的答案不能保证取到这个答案时f(x)能取到这个最小值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//wrong answer.#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+10;const double eps = 1e-7;int T,n;struct Node&#123; int a,b,c; double ans;&#125;f[maxn]; void calc(Node q)&#123; int x = q.a,y = q.b,z = q.c; if (x == 0) &#123; if (y &lt;= 0) &#123; q.ans = (double)(z); return ; &#125; else &#123; q.ans = (double)(1000*y+z); return ; &#125; &#125; else &#123; double u = (-y)/(2*x); if (u &gt; eps &amp;&amp; 1000 - u &gt; eps) &#123; q.ans = u*u*double(x)+u*double(y)+u*double(z); return ; &#125; if (u &lt; -eps) &#123; q.ans = double(z); return ; &#125; if (u - 1000 &gt; eps) &#123; q.ans = 1000*1000*double(x)+double(y)*1000+double(z); return ; &#125; &#125;&#125;int main(int argc ,char *argv[])&#123; scanf("%d",&amp;T); while(T--) &#123; double ass = 1e8; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d",&amp;f[i].a,&amp;f[i].b,&amp;f[i].c), calc(f[i]), ass = min(ass,f[i].ans), printf("%.4lf\n",ass); &#125; return 0;&#125; 正解:可以证明，对于两条抛物线或者直线，要么是单增单减，要么是开口向上的凹形图像。再用一次数学归纳法,证明从n条线推导到n+1条曲线即可。因为答案呈单峰，三分求解即可。交了两次,第一次eps =1e-7莫名wa掉,第二次eps=1e-9就AC了你敢信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+10;const double eps = 1e-9;int a[maxn],b[maxn],c[maxn],T,n;inline void read(int &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;double calc(double x)&#123; double ans = a[1]*x*x+b[1]*x+c[1]; for (int i = 2; i &lt;= n; i++) ans = max(ans,a[i]*x*x+b[i]*x+c[i]); return ans;&#125;int main(int argc, char *argv[])&#123; read(T); while(T--) &#123; read(n); for (int i = 1; i &lt;= n; i++) read(a[i]),read(b[i]),read(c[i]); double l = 0.0,r = 1000.0; while(r - l &gt; eps) &#123; double m1,m2; m1 = l+(r-l)/3; m2 = r-(r-l)/3; if (calc(m2)-calc(m1) &gt; eps) r = m2; else l = m1; &#125; //printf("%.4lf %.4lf\n",l,r); printf("%.4lf\n",calc(l)); &#125; return 0;&#125; 积分导数技巧虽然积分和导数算是我高数里比较擅长的东西。但是还是要理一下的吧。 导数的定义在可导函数上某一点的瞬时变化率. \lim_{\Delta x\rightarrow0} \frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}基本初等函数导数即求导法则. f(x)=t,f'(x)=0\\\\ f(x)=x^n,f'(x)=nx^{n-1}\\\\ f(x)=sin(x),f'(x)=cos(x)\\\\ f(x)=cos(x),f'(x)=-sin(x)\\\\ f(x)=e^x,f'(x)=e^x\\\\ f(x)=lnx,f'(x)=\frac{1}{x}\\\\ f(x) = tan(x),f'(x)=\frac{1}{cos^2(x)} 乘法则:如果一个函数f(x)=g(x)h(x),那么\\\\ f'(x) = g'(x)h(x)+g(x)h'(x) 商法则：如果一个函数f(x)=\frac{g(x)}{h(x)},那么\\\\ f'(x)=\frac{g'(x)h(x)-g(x)h'(x)}{h^2(x)} 链导法则：如果一个函数f(x)=g(h(x)),那么\\\\ f'(x)=g'(h(x))·h'(x)Mathjax打得我好累 积分的定义难以解释.积分求的是一个函数与x轴围成的面积大小。只可意会不可言传。（逃 这几个算有用的吧。 之前做过的一点习题 贴上来算了 积分和导数的综合运用求曲函数的长度(LA-3485有用) 有一曲线方程\space f(x),且x\in[a,b],令f'(x)为f(x)的导函数,那么该曲线在a,b上的长度为\\\\ \int_a^b\sqrt{1+[f'(x)]^2}dxLA-3485 Bridge传送门:LA-3485 题目大意:给出一个开口向上的抛物线的曲线长和左右区间，求出抛物线顶点的值（最小值）。 不行这题一定要另外写一篇Mark一下,太震撼了. qwq]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-11542] Square]]></title>
    <url>%2F2018%2F02%2F12%2FUVa-11542-Square%2F</url>
    <content type="text"><![CDATA[题面传送门UVa-11542题目大意:给出一个整数集合从中挑出至少一个使得积为完全平方数。 样例Sample Input432 3 536 10 1544 6 10 1532 2 2Sample Output0133 思路高斯消元+xor矩阵先处理出前面500的质数写成m个异或的方程 自上而下求解即可异或的话可以用bitset优化但是，，我不会用啊 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 510;const int maxp = 100;typedef int Matrix[maxn][maxn];bool is_prime[maxn];int prime[maxp],cnt=0;inline void read(int &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;void Euler_Prime(int s)&#123; memset(is_prime,1,sizeof(is_prime)); is_prime[1] = 0; //1 不是质数. for (int i = 2; i &lt;= s; i++) &#123; if (is_prime[i]) prime[cnt++] = i; for (int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= s; j++) &#123; is_prime[prime[j] * i] = 0; if (i % prime[j] == 0) break; &#125; &#125;&#125;Matrix A;int rank(Matrix A, int m, int n) &#123; int i = 0, j = 0, k, r, u; while(i &lt; m &amp;&amp; j &lt; n) &#123; r = i; for(k = i; k &lt; m; k++) if(A[k][j]) &#123; r = k; break; &#125; if(A[r][j]) &#123; if(r != i) for(k = 0; k &lt;= n; k++) swap(A[r][k], A[i][k]); for(u = i+1; u &lt; m; u++) if(A[u][j]) for(k = i; k &lt;= n; k++) A[u][k] ^= A[i][k]; i++; &#125; j++; &#125; return i;&#125;int main(int argc, char *argv[]) &#123; int T; cin &gt;&gt; T; while(T--) &#123; int n, maxp = 0; long long x; cin &gt;&gt; n; memset(A, 0, sizeof(A)); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; for(int j = 0; j &lt; cnt; j++) while(x % prime[j] == 0) &#123; maxp = max(maxp, j); x /= prime[j]; A[j][i] ^= 1; &#125; &#125; int r = rank(A, maxp+1, n); // 只用到了前maxp+1个素数 cout &lt;&lt; (1LL &lt;&lt; (n-r))-1 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-3704] Cellular Automaton 细胞自动机]]></title>
    <url>%2F2018%2F02%2F12%2FLA-3704-Cellular-Automaton-%E7%BB%86%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题面传送门:LA-3704 样例Sample Input5 3 1 11 2 2 1 25 3 1 101 2 2 1 2Sample Output2 2 2 2 12 0 0 2 2 思路既然这里讲的是矩阵的运算 那么一定是要构造一个递推的关系从题面上很难发现有什么规律可言于是我们动手画画发现每次的变化都是上次的有序排列比如样例中的第一组输入输出[1 1 0 0 1] [1] = [2][1 1 1 0 0] [2] = [2][0 1 1 1 0] [2] = [2][0 0 1 1 1] [1] = [2][1 0 0 1 1] [2] = [1]发现了么，左边的矩阵的每下一行都是上一行的元素向右移动一格这样的矩阵 只要保存一行信息即可我们称之为”循环矩阵”.于是原来n^3logk的爆炸事件在这个循环矩阵的优化下降到了n^2logk. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std; #define INF 0x3f3f3f3f const long long N=505; typedef long long ll; typedef struct &#123; ll mat[N]; &#125;Mat; int n,d,m,k; Mat multi(Mat a,Mat b) &#123; Mat c; memset(c.mat, 0, sizeof(c.mat)); for (int i=1; i&lt;=n; i++) &#123; for (int j=1; j&lt;=n; j++) &#123; c.mat[i]+=a.mat[j]*b.mat[(i-j+n)%n+1]; c.mat[i]%=m; &#125; &#125; return c; &#125; Mat qui(Mat a,int b) &#123; Mat c; memset(c.mat, 0, sizeof(c.mat)); c.mat[1]=1; while (b) &#123; if (b&amp;1) &#123; c=multi(c, a); &#125; a=multi(a, a); b&gt;&gt;=1; &#125; return c; &#125; int main(int argc, char *argv[]) &#123; int f[N]; Mat A; while (cin&gt;&gt;n&gt;&gt;m&gt;&gt;d&gt;&gt;k) &#123; memset(f, 0, sizeof(f)); for (int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;f[i]); &#125; memset(A.mat, 0, sizeof(A.mat)); for (int i=1; i&lt;=1; i++) &#123; A.mat[i]=1; for (int j=1; j&lt;=d; j++) &#123; A.mat[(i-1+j)%n+1]=1; A.mat[(i-1-j+n)%n+1]=1; &#125; &#125; A=qui(A, k); ll res[N]; memset(res, 0, sizeof(res)); for (int i=1; i&lt;=n; i++) &#123; for (int j=1; j&lt;=n; j++) &#123; res[i]+=A.mat[(i-j+n)%n+1]*f[j]; res[i]%=m; &#125; &#125; for (int i=1; i&lt;n; i++) &#123; printf("%lld ",res[i]); &#125; printf("%lld\n",res[n]) ; &#125; return 0; &#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-10870] Recurrences(矩阵构造与快速幂)]]></title>
    <url>%2F2018%2F02%2F12%2FUVa-10870-Recurrences-%E7%9F%A9%E9%98%B5%E6%9E%84%E9%80%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[题面传送门:UVa-10870题目大意:给出F(n)的递推式,求出F(n)%m的值。 Consider recurrent functions of the following form:f(n) = a1f(n − 1) + a2f(n − 2) + a3f(n − 3) + . . . + adf(n − d), for n &gt; d,where a1, a2, . . . , ad are arbitrary constants.A famous example is the Fibonacci sequence, defined as: f(1) = 1, f(2) = 1, f(n) = f(n − 1) +f(n − 2). Here d = 2, a1 = 1, a2 = 1. Every such function is completely described by specifying d (which is called the order of recurrence),values of d coefficients: a1, a2, . . . , ad, and values of f(1), f(2), . . . , f(d). You’ll be given these numbers,and two integers n and m. Your program’s job is to compute f(n) modulo m.InputInput file contains several test cases. Each test case begins with three integers: d, n, m, followed bytwo sets of d non-negative integers. The first set contains coefficients: a1, a2, . . . , ad. The second set gives values of f(1), f(2), . . . , f(d).You can assume that: 1 ≤ d ≤ 15, 1 ≤ n ≤ 2^31-1，1 ≤ m ≤ 46340. All numbers in the input will fit in signed 32-bit integer.Input is terminated by line containing three zeroes instead of d, n, m. Two consecutive test casesare separated by a blank line.OutputFor each test case, print the value of f(n)( mod m) on a separate line. It must be a non-negative integer,less than m. 样例Sample Input1 1 100212 10 1001 11 13 2147483647 1234512345678 0 123451 2 30 0 0Sample Output155423 思路很明显是一个构造类的问题，我们如果能够从f(n)递推到f(n+1)就可以使矩阵快速幂了比如当d=5时,不难写出这样的矩阵乘法 \begin{bmatrix} a_1 &a_2&a_3&a_4&a_5\\\\ 1 & 0 &0 &0 &0 \\\\ 0& 1 &0&0&0\\\\ 0& 0& 1 &0 &0\\\\ 0&0 &0 & 1 &0 \end{bmatrix} * \begin{bmatrix} f(n)\\\\ f(n-1)\\\\ f(n-2)\\\\ f(n-3)\\\\ f(n-4)\\\\ \end{bmatrix} = \begin{bmatrix} f(n+1)\\\\ f(n)\\\\ f(n-1)\\\\ f(n-2)\\\\ f(n-3)\\\\ \end{bmatrix}同理d为任意值时都可以写出这样的矩阵乘法。 这样我们就可以定义一个常数矩阵A,在从f(n)递推到f(n+1)乘以A即可,我们已经知道了f(1)到f(d)的值 从f(d)到f(n)一共要乘以A （n-d）次 一个矩阵快速幂即可其中快速幂的复杂度为logn,矩阵的复杂度为d^3(没有优化的话) 因此时间复杂度为 O(d^3log_2n)这便是正解了。qwq 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL d,m,f[26];struct node&#123;LL a[16][16];&#125;;node multi(node x,node y)&#123; node t; memset(t.a,0,sizeof(t.a)); for(int i = 1; i &lt;= d; i++) &#123; for(int j = 1; j &lt;= d; j++) &#123; for(int k = 1; k &lt;= d; k++) t.a[i][j] = (t.a[i][j]+x.a[i][k]*y.a[k][j])%m; &#125; &#125; return t;&#125;LL find(LL n,node sa)&#123; node t; memset(t.a,0,sizeof(t.a)); for(int i=1; i&lt;=d; i++) t.a[i][i]=1; while(n) &#123; if(n&amp;1) t=multi(t,sa); sa=multi(sa,sa); n&gt;&gt;=1; &#125; LL ans=0; for(int i=1;i&lt;=d;i++) ans=(ans+t.a[1][i]*f[i])%m; return ans;&#125;int main(int argc, char *argv[])&#123; LL n; node sa; while(scanf("%lld%lld%lld",&amp;d,&amp;n,&amp;m) == 3 &amp;&amp;d) &#123; memset(sa.a,0,sizeof(sa.a)); for(int i=1; i&lt;=d; i++) scanf("%d",&amp;sa.a[1][i]); for(int i=d; i&gt;=1; i--) scanf("%d",&amp;f[i]); for(int i=2; i&lt;=d; i++) sa.a[i][i-1]=1; if(n&lt;=d) printf("%lld\n",f[d-n+1]%m); else printf("%lld\n",find(n-d,sa)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵和线性方程组学习笔记]]></title>
    <url>%2F2018%2F02%2F10%2F%E7%9F%A9%E9%98%B5%E5%92%8C%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[矩阵方法还是要会的 矩阵矩阵的基本运算矩阵加法最简单了，就是对应数的相加.如果用i,j来表示行和列那么就有 C_{(i,j)} = A_{(i,j)} + B_{(i,j)}减法同理，不作太多的阐述。唯一需要注意事项，当两个矩阵的行和列不相等的时候，求他们的矩阵和或者矩阵差是毫无意义的。只有r1=r2,s1=s2才有加减法的定义。 矩阵乘法（划重点） 稍显复杂，矩阵乘法必须在n行m列和m行p列的两个矩阵中进行运算，否则一样没有意义。 得到一个n行p列的矩阵。 有以下的递推式: C_{i,k} = \sum_{j=1}^nA_{i,j} *B_{j,k}具体细节 根据这个递推式，我们不难得到一个O(n^3)的算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn = 510;const int mod = 1e9+7;struct Matrix&#123; int m[maxn][maxn]; int r, s;&#125;;int N,M,P;Matrix A,B,ans;signed main(signed argc, char *argv[])&#123; scanf("%lld %lld %lld",&amp;N,&amp;P,&amp;M); for (int i = 1; i &lt;= N; i++) for (int j = 1; j &lt;= P; j++) scanf("%lld",&amp;A.m[i][j]); system("pause"); for (int i = 1; i &lt;= P; i++) for (int j = 1; j &lt;= M; j++) scanf("%lld",&amp;B.m[i][j]); for (int i = 1; i &lt;= N; i++) for (int k = 1; k &lt;= P; k++) for (int j = 1; j &lt;= M; j++) &#123; ans.m[i][j] = (ans.m[i][j] + mod) % mod; ans.m[i][j] += (A.m[i][k]%mod)* (B.m[k][j]%mod); ans.m[i][j] = (ans.m[i][j] + mod) % mod; &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) printf("%lld ",(ans.m[i][j]%mod+mod)%mod); printf("\n"); &#125; return 0;&#125; 尽管联赛的要求就是O(n^3) 但是还可以更快 可以试想，当A(i,j)等于0时,那里一整块的结果都是0，不需要继续运算 123456789for (int i = 1; i &lt;= N; i++) for (int k = 1; k &lt;= P; k++) if (A.m[i][k]) for (int j = 1; j &lt;= M; j++) &#123; ans.m[i][j] = (ans.m[i][j] + mod) % mod; ans.m[i][j] += (A.m[i][k]%mod)* (B.m[k][j]%mod); ans.m[i][j] = (ans.m[i][j] + mod) % mod; &#125; 还有神仙操作的可以优化到O(nm)的操作 贴下代码慢慢理解啦。 高斯费马 树上开花 我们 俯身欣赏. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;typedef long long i64;const int P=1e9+7;char rb[8000000],*rp=rb,ob[4000000],*op=ob;int _()&#123; int x=0,f=1; while(*rp&lt;48)*rp++=='-'?f=-1:0; while(*rp&gt;47)x=x*10+*rp++-48; return x*f;&#125;void pr(int x)&#123; x+=(x&gt;&gt;31&amp;P); int ss[15],sp=0; do ss[++sp]=x%10,x/=10;while(x); while(sp)*op++=ss[sp--]+48;&#125;int n,p,m;int a[507][507],b[507][507];i64 c[507][507];int main()&#123; fread(rb,1,sizeof(rb),stdin); n=_(),p=_(),m=_(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=p;++j)a[i][j]=_(); for(int i=1;i&lt;=p;++i) for(int j=1;j&lt;=m;++j)b[i][j]=_(); int m1=m; while(m1&amp;3)++m1; for(int i=1;i&lt;=n;++i)&#123; i64*z=c[i]; for(int k=1;k&lt;=p;++k)&#123; int x=a[i][k],*y=b[k]; for(int j=4;j&lt;=m1;j+=4)&#123; z[j-3]+=i64(x)*y[j-3]; z[j-2]+=i64(x)*y[j-2]; z[j-1]+=i64(x)*y[j-1]; z[j ]+=i64(x)*y[j ]; &#125; if(!(k&amp;7)) for(int j=1;j&lt;=m;++j)z[j]-=(z[j]&gt;&gt;30)*P; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; pr(c[i][j]%P); *op++=32; &#125; *op++=10; &#125; fwrite(ob,1,op-ob,stdout); return 0;&#125; 高斯消元我们假设有这样一个n阶的可逆矩阵，例如 2x+y-z =8(L_1)\\\\-3x-y+2z=-11(L_2)\\\\-2x+y+2z=-3(L_3)这样的一个三元一次方程组写成矩阵的形式为 \begin{bmatrix} 2 & 1 & -1 &| &8 \\\\ -3 & -1 & 2 & | & -11\\\\ -2 & 1 & 2 & | & -3 \end{bmatrix}这个矩阵被称作增广矩阵（AUGMENTED MATRIX）,最后一列事实上不是系数矩阵而是常数。 这个矩阵可以经过这样的处理。 对于每一行要使得Aii≠0且Aji(j&gt;i)均为0,具体操作 1.来到当前行 以上方矩阵为例子，现在要处理第一行。我们先往下面找到绝对值最大的A(i,r),这里找到是-3,于是交换第1行和第2行.（矩阵变成这个样子，就是交换了一二两行） \begin{bmatrix} -3 & -1 & 2 & | & -11\\\\ 2 & 1 & -1 &| &8 \\\\ -2 & 1 & 2 & | & -3 \end{bmatrix}对于L1，L2 将L1 3 +L2 2来加减消元，对于第三行，和第二行一样，直接与现在的L1操作。 将L2、L3的首项消成0后继续操作第二行。 \begin{bmatrix} -3 & -1 & 2 & | & -11\\\\ \space & \frac{1}{3} & \frac{1}{3} & | &\frac{2}{3} \\\\ \space & \frac{5}{3} & \frac{2}{3} & | &\frac{13}{3} \\\\ \end{bmatrix}以此类推最终得到一个三角矩阵。 差不多就长这个样子。（滑稽 \begin{bmatrix} -3 & -1 & 2 & | & -11\\\\ \space & \frac{5}{3} & \frac{2}{3} & | &\frac{13}{3} \\\\ \space & \space & \frac{1}{5} & | &-\frac{1}{5} \\\\ \end{bmatrix}这样其实最后一列已经告诉了我们z=-1。 自下向上迭代即可。 高斯消元代码如下。 1234567891011121314151617181920212223void Gauss_Eli()&#123; int num; for (int i=1;i&lt;n;i++)&#123; num=i; for (int j=i+1;j&lt;=n;j++) if (fabs(A[j][i])&gt;fabs(A[num][i])) num=j; for (int j=1;j&lt;=n;j++) swap(A[i][j],A[num][j]); swap(b[num],b[i]); for (int j=i+1;j&lt;=n;j++)&#123; if (fabs(A[j][i])&lt;=eps) continue; double t=A[j][i]/A[i][i]; for (int k=1;k&lt;=n;k++) A[j][k]-=A[i][k]*t; b[j]-=b[i]*t; &#125; &#125; for (int i=n;i&gt;=1;i--)&#123; ans[i]=b[i]/A[i][i]; for (int j=i;j&gt;=1;j--) b[j]-=A[j][i]*ans[i]; &#125;&#125; 对于异或^方程组可以用bitset优化.1234567891011121314151617181920bitset&lt;250&gt;A[250]; \\常数项b[i]贴在A[i][n+1]中.void Gauss_Eli()&#123; int num; for (int i=1;i&lt;=n;i++)&#123; if (A[i][i]==0)&#123; num=i; for (int j=i+1;j&lt;=n;j++) if (A[j][i]!=0)&#123;num=j;break;&#125; swap(A[num],A[i]); &#125; for (int j=i+1;j&lt;=n;j++) if (A[j][i]!=0) A[j]^=A[i]; &#125; for (int i=n;i&gt;=1;i--)&#123; ans[i]=A[i][n+1]; for (int j=i;j&gt;=1;j--) if (A[j][i]!=0) A[j][n+1]=A[j][n+1]^ans[i]; &#125;&#125; 题目传送门: UVa-10870LA-3704UVa-11542POJ-1222]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-10791 Minimum Sum LCM]]]></title>
    <url>%2F2018%2F02%2F10%2FUVa-10791-Minimum-Sum-LCM%2F</url>
    <content type="text"><![CDATA[题面传送门:UVa-10791题目大意:给出一个数N,要求出至少两个数以上的正整数,使得 LCM(a_1,a_2, ...,a_k) = N 并求出满足条件的最小的{\sum_{i=1}^{k}a_i} 样例Sample Input121050Sample OutputCase 1: 7Case 2: 7Case 3: 6 思路还是应用唯一分解定理,不难发现。对于任何一个质数或者对于一个只有单因子（除去1和它本身）的数，其数列a只包含1和它本身此时答案就为n+1. 对于一个合数n,总有 N = \prod_{i=1}^{k}a_i^{p_i}不难发现,当质因数分解时各个质因数的幂之间的gcd必定为1，这样的损耗代价是最小的。 所以求出各个ai和pi就可以gg了。 注意特判,数据范围内是int但是很可能会在计算过程中溢出。 开个long long比较保险。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;typedef long long LL; using namespace std;bool is_prime[56440]; //sqrt(2^31-1) 约等于 56340 LL prime[56440],pf[56400],cnt = 0,n;LL kase = 0;bool check(LL x)&#123; if (x == 1) return 0; if (x == 2) return 1; for (LL i = 2; i &lt;= sqrt(x+0.5); i++) if (x % i == 0) &#123; while(x % i == 0) x /= i; if (x == 1) return 1; else return 0; &#125; return 1;&#125;void Euler_Prime(LL x)&#123; memset(is_prime,1,sizeof(is_prime)); is_prime[1] = 0; for (LL i = 2; i &lt;= x; i++) &#123; if (is_prime[i]) prime[++cnt] = i; for (LL j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= x; j++) &#123; is_prime[i * prime[j]] = 0; if (i % prime[j] == 0) break; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; Euler_Prime(56439); while(scanf("%lld",&amp;n) == 1 &amp;&amp; n) &#123; LL ans = 0; memset(pf,0,sizeof(pf)); if (n == 1) &#123; printf("Case %lld: 2\n",++kase); continue; &#125; if (check(n)) &#123; printf("Case %lld: %lld\n",++kase,n+1); continue; &#125; for (LL i = 1; i &lt;= cnt; i++) &#123; if (n % prime[i] == 0) &#123; LL ret = 1; while(n % prime[i] == 0) n/=prime[i],ret *= prime[i]; ans += ret; &#125; if (n == 1) break; &#125; printf("Case %lld: %lld\n",++kase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-10375] Choose and divide]]></title>
    <url>%2F2018%2F02%2F10%2FUVa-10375-Choose-and-divide%2F</url>
    <content type="text"><![CDATA[题面传送门:UVa-10375题目大意:给出p,q,r,s,求出C(p,q)/C(r,s)的值,其中p,q,r,s∈[1,10000]；且p &gt;= q,r &gt;= s; 样例Sample Input10 5 14 993 45 84 59145 95 143 92995 487 996 4882000 1000 1999 9999998 4999 9996 4998Sample Output0.12587505606.460551.282230.489962.000003.99960 思路先预处理1W以内的质数集合prime[],然后唯一分解定理,用pf[i]记录每个质数要乘或者除的个数,最后pow一遍即可. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10001;int prime[maxn],cnt = 0,pf[maxn];bool is_prime[maxn];void Euler_Prime(int x)&#123; memset(is_prime,1,sizeof(is_prime)); is_prime[1] = 0; for (int i = 2; i &lt;= x; i++) &#123; if (is_prime[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i *prime[j] &lt;= x; j++) &#123; is_prime[i*prime[j]] = 0; if (i % prime[j] == 0) break; &#125; &#125;&#125;void work(int n,int d)&#123; for (int i = 1; i &lt;= cnt; i++) &#123; while(n % prime[i] == 0) &#123; n /= prime[i]; pf[i] += d; &#125; if (n == 1) break; &#125;&#125;void update(int n,int d)&#123; for (int q = 1; q &lt;= n; q++) work(q,d);&#125;int main(int argc, char *argv[])&#123; Euler_Prime(10000); int p,q,r,s; while(scanf("%d %d %d %d",&amp;p,&amp;q,&amp;r,&amp;s) == 4) &#123; double ans = 1.0; memset(pf,0,sizeof(pf)); update(p,1); update(q,-1);update(p-q,-1); update(r,-1);update(s,1); update(r-s,1); for (int i = 1; i &lt;= cnt; i++) ans *= pow(prime[i],pf[i]); printf("%.5lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa-11582-Fibonacci数列f(a^b)%n的值]]></title>
    <url>%2F2018%2F02%2F09%2FUVa-11582-Fibonacci%E6%95%B0%E5%88%97f-a-b-n%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题面传送门:UVa-11582题目大意:给出long long范围的a,b,n,求出f(a^b) % n的值,其中f(x)为Fibonacci数列的第x项. 样例Sample Input31 1 22 3 100018446744073709551615 18446744073709551615 1000Sample Output121250 思路一开始的思路是利用Fibonacci的通项公式加上二项式定理来求出a^b%n的项但是无奈推公式时推错而且发现a^b%n的值和f(a^b)%n毫无关系.联想到fibonacci数列对一个数n取mod,可以由鸽巢原理证明, 只要连续出现n^2个的mod值,必然会出现循环于是就诞生了做法.先找出最小循环节，在这个循环节中寻找f(a^b)的位置. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000 + 5;typedef unsigned long long ULL;int f[maxn][maxn*6], period[maxn];int pow_mod(ULL a, ULL b, int n) &#123; if(!b) return 1; int k = pow_mod(a, b/2, n); k = k * k % n; if(b % 2) k = k * a % n; return k;&#125;int solve(ULL a, ULL b, int n) &#123; if(a == 0 || n == 1) return 0; int p = pow_mod(a % period[n], b, period[n]); return f[n][p];&#125;int main(int argc,char *argv[]) &#123; ios::sync_with_stdio(false);//取消cin与scanf同步加快速度. for(int n = 2; n &lt;= 1000; n++) &#123; f[n][0] = 0; f[n][1] = 1; for(int i = 2; ; i++) &#123; f[n][i] = (f[n][i-1] + f[n][i-2]) % n; if(f[n][i-1] == 0 &amp;&amp; f[n][i] == 1) &#123; period[n] = i - 1; break; &#125; &#125; &#125; ULL a, b; int n, T; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n; cout &lt;&lt; solve(a, b, n) &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa - 11426] Extreme GCD (II) 二维gcd求和问题]]></title>
    <url>%2F2018%2F02%2F09%2FUVa-11426-Extreme-GCD-II-%E4%BA%8C%E7%BB%B4gcd%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题面传送门:UVa-11426大致意思:输入一个正整数n,要求在时限为10sec内求出 \sum _ { i = 1 } ^ { N - 1 } \sum _ { j = i + 1 } ^ { N } GCD(i,j)保证答案在long long范围内 样例Sample Input101002000000 Sample Output6713015143295493160 思路引理:如果要满足gcd(x,n)=i,其充分必要条件为gcd(x/i,n/i) = 1. 可以肯定的是,如果一个一个地枚举i,j &lt;= n,时间复杂度为O(n^2)必然会T飞我们可以设一个辅助函数 f(n) = gcd(1,n) + gcd(2,n) + …… + gcd(n-1,n);那么答案S(n) = f(2) + f(3) + …… + f(n).得出递推式S(n) - S(n-1) = f(n).∴问题转化为在线性时间内求出f(n)的大小.可以发现,gcd(x,n) 因为 x &lt; n,所以gcd(x,n)一定是n的约数如果能将这些约数分类,继续刚才的套路,再去设一个辅助函数g(n,i)表示gcd(x,n) = i 的x的个数可以发现,f(n)=sigma(i * g(n,i))其中保证i是n的因数由引理,可知道满足条件的x/i有phi(n/i)个∴g(n,i) = phi(n,i). 至此,我们已经可以在sqrt(n) * n的时间内计算出f(n).上述算法的代码如下.1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int maxn = 4000010;LL phi[maxn],f[maxn],S[maxn];void phi_spawn(int x)&#123; memset(phi,0,sizeof(phi)); phi[1] = 1; for (int i = 2; i &lt;= x; i++) if (!phi[i]) &#123; for (int j = i; j &lt;= x; j+=i) &#123; if (!phi[j]) phi[j] = j; phi[j] = phi[j] * (i-1) / i; &#125; &#125;&#125;int calc(int x)&#123; int ret = 0; if (x == 1) return 1; for (int i = 2; i &lt;= sqrt(x+0.5); i++) if (x % i == 0) ret += i*phi[x/i]; return ret; &#125; int main(int argc, char *argv[])&#123; phi_spawn(maxn); memset(f,0,sizeof(f)); for (int i = 1; i &lt;= maxn; i++) f[i] = calc(i); S[2] = f[2]; for (int i = 3; i &lt;= maxn; i++) S[i] = S[i-1] + f[i]; int n; while(scanf("%d",&amp;n) == 1 &amp;&amp; n) printf("%lld\n",S[n]); return 0;&#125; 但是在400W的数据下还是T飞了.还是菜啊. 但尽管如此还是有很多的重复计算，为什么呢？我们在枚举因数的时候，有很多次重复，但是如果枚举因数,计算它的倍数,这样就几乎是一个筛法式的求f[n],对于每个i枚举倍数去更新f(n)这样的算法将会与素数筛法的算法时间复杂度同阶. 正解代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int maxn = 4000010;LL phi[maxn],f[maxn],S[maxn];void phi_spawn(int x)&#123; memset(phi,0,sizeof(phi)); phi[1] = 1; for (int i = 2; i &lt;= x; i++) if (!phi[i]) &#123; for (int j = i; j &lt;= x; j+=i) &#123; if (!phi[j]) phi[j] = j; phi[j] = phi[j] * (i-1) / i; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; phi_spawn(maxn); memset(f,0,sizeof(f)); for (int i = 1; i &lt;= maxn; i++) for (int j = 2*i; j &lt;= maxn; j+=i) f[j] += i * phi[j/i]; S[2] = f[2]; for (int i = 3; i &lt;= maxn; i++) S[i] = S[i-1] + f[i]; int n; while(scanf("%d",&amp;n) == 1 &amp;&amp; n) printf("%lld\n",S[n]); return 0;&#125; edited by karriganasta ❤ 20180209]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论基础]]></title>
    <url>%2F2018%2F02%2F08%2F%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[傻逼选手数论屁也不会 基本概念及代码质数质数也称素数,即恰好包含两个不同因子的整数.（好智障啊）1 不是质数.判断单个数是否为质数.如下. 12345678bool is_prime(int x)&#123; if (x &lt;= 1) return 0; if (x == 2) return 1; for (int i = 2; i &lt;= sqrt(x+0.5); i++) //用Sqrt(x+0.5)防止精度失真 if (x % i == 0) return 0; return 1;&#125; 每次的时间复杂度为 O(sqrt(n)). 但是对于很N个数的质数表单个判断就很无力,因为同一个数的因数会被重复地判断 比如4被2筛去,但6还要再次被筛一遍. 所以就诞生了Euler大师的能保证每个数只被筛到一次的线性筛,能做到O(n). 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;const int Maxn = 1e7+10;bool is_prime[Maxn];int prime[Maxn],cnt = 0;void Euler_Prime(int s)&#123; memset(is_prime,1,sizeof(is_prime)); is_prime[1] = 0; //1 不是质数. for (int i = 2; i &lt;= s; i++) &#123; if (!is_prime[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= s; j++) &#123; is_prime[prime[j] * i] = 0; if (i % prime[j] == 0) break;//确保了每个合数只被他最小的质因数筛去.6啊 &#125; &#125;&#125;int main(int argc, char *argv[])&#123; Euler_Prime(Maxn); int x; scanf("%d",&amp;x); printf("%d\n",is_prime[x]); return 0;&#125; Euclid算法.最简单的是欧氏的辗转相除求最大公约数(gcd)的方法.1234int gcd(int x,int y)&#123; return (y == 0) ? x : gcd(y,x%y);&#125; 会不会爆栈呢?不会,可以证明,gcd的递归层数不超过4.785lgN + 1.6723(紫书P311) 对于任意的x,y,有lcm(x,y) gcd(x,y) = xy; 证明略请自行百度 Extended Euclid算法找出一对整数x,y要求能够使得ax+by = gcd(a,b) 且使得|x| +|y|尽可能的小.123456void ex_gcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)&#123; if(!b)&#123;d = a;x = 1;y = 0;&#125; //如果b = 0，那么就是ax = d，令x = 1,y = 0即可 else &#123;ex_gcd(b,a%b,d,y,x) y-=x*(a/b);&#125; &#125; 欧拉phi φ函数公式如下 \varphi (n) = n\prod_{i=1}^k(1-\frac{1}{p_i})单个欧拉函数可以这样求:123456789101112int euler_phi(int n)&#123; int m = sqrt(n+0.5); int ans = 0; for (int i = 2; i &lt;= m; i++) if (n % i == 0) &#123; ans = ans * (i-1)/i; while(n % i == 0) n /= i; &#125; return ans;&#125; 以Euler的质数筛 可以类比算出欧拉函数,时间复杂度也为O(n).123456789101112void phi_table(int n)&#123; for (int i = 2; i &lt;= n; i++) phi[i] = 0; phi[1] = 1; for (int i = 2; i &lt;= n; i++) if (!phi[i]) for(int j = i; j &lt;= n; j+=i) &#123; if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i-1); &#125;&#125; 中国剩余定理（孙子定理）问题：今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？ 说明白一点就是说，存在一个数x，除以3余2，除以5余三，除以7余二，然后求这个数。上面给出了解法。再明白这个解法的原理之前，需要先知道一下两个定理。 定理1：几个数相加，如果存在一个加数，不能被数a整除，那么它们的和，就不能被整数a整除。 定理2：两数不能整除，若除数扩大（或缩小）了几倍，而被除数不变，则其商和余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。 现给出求解该问题的具体步骤： 1、求出最小公倍数 lcm=357=105 2、求各个数所对应的基础数 （1）105÷3=35 35÷3=11……2 //基础数35 （2）105÷5=21 21÷5=4……1 定理2把1扩大3倍得到3，那么被除数也扩大3倍，得到21 * 3=63//基础数63 3、105÷7=15 15÷7=2……1 定理2把1扩大2倍得到2，那么被除数也扩大2倍，得到15 * 2=30//基础数30 把得到的基础数加和（注意：基础数不一定就是正数） 35+63+30=128 4、减去最小公倍数lcm（在比最小公倍数大的情况下） x=128-105=23 那么满足题意得最小的数就是23了。一共有四个步骤。下面详细解释每一步的原因。 （1）最小公倍数就不用解释了，跳过（记住，这里讨论的都是两两互质的情况） （2）观察求每个数对应的基础数时候的步骤，比如第一个。105÷3=35。显然这个35是除了当前这个数不能整除以外都能够被其他数整除，就是其他数的最小公倍数。相当于找到了最小的开始值，用它去除以3发现正好余2。那么这个基础数就是35。记住35的特征，可以整除其他数但是不能被3整除，并且余数是2。体现的还不够明显，再看下5对应的基础数。21是其他数的最小公倍数，但是不能被5整除，用21除以5得到的余数是1，而要求的数除以5应该是余1的。所以余数被扩大，就得到了相应的基础数63。记住这个数的特征，可以被其他数整除但是被5除应该余三。同理，我们得到了第三个基础数23，那么他的特征就是：可以被其他数整除，但是不能被7整除，并且余数为2。 （3）第三步基础数加和，为什么要这样做呢？利用就是上面提到的定理1。 35+63+30=128。对于3来说，可以把63+30的和看作一个整体，应该他们都可以被3整除。看着上面写出的三个数的特征，运用定理1来说，就是在35的基础上加上一个可以被3整除的倍数，那么得到的结果依然还是满足原先的性质的，就是128除以同样还是余2的。同理，对于5还说，这个数被除之后会剩余3；对于7来说，被除之后剩余2。所以说，我们当前得到的这个数是满足题目要求的一个数。但是这个数是不是最小的，那就不一定了。 （4）应该不能确定是不是最小的数，这个时候就要用到他们的最小公倍数了。最小公倍数顾名思义，一定是一个同时被几个数整除的最小的一个数，所以减去它剩余下来的余数还是符合题意要求的。当然也同样可以运用定理1来解释，只不过是加法变成了减法，道理还是一样的。当然具体要不要剪还是要看和lcm的大小关系的。 稍微的总结一下：就是已知m1,m2,m3是两两互质的正整数，求最小的正整数x，使它被m1,m2,m3除所得的余数分别是c1,c2,c3。孙子定理的思想便是线分别求出被其中数mi整除余1而被两外两个数整除的数Mi(i=1,2,3)，则所求数之一的便是c1M1+c2M2+c3M3。由此我们可以得到n个两两互质数的情况。证明上面已经一步一步给出。 那么，到此为止基本的中国剩余定理的内容我们以及了解了，包括解答方法。那么如何编码呢？按照上面这个思路去编码，其实并不难。一共分为四大步。但是，大多数人的困惑在于如何求取基础数。这里呢，提供两种方法： （1）第一种就是一直递增，直到找到。例如：3的基础数，35是其他数的最小公倍数。那么就从35开始，一直自增，知道余数为2，便停止（利用while循环）。 （2）第二种方法呢就是辗转相除法上得来的。这里的例子体现的不够明显，应当看看去求取乘法逆元的过程，下面讲的内容和乘法逆元有很大的关系，所以还是看看的好。简单举个例子： 假设现在三个数分别是14，3，5，它们两两互质，且要求的数除以5余3。求5对应的基础数。有： 42÷5=8……2 5÷2=2……1 所以1=5 - 2 2=5 - 2 （42- 8 5 ）=-2 42+17 * 5 那么-2 42=-84 17 5=85 -84+85=1 把1扩大3倍变成3，则有-84 * 3=-252也就是5对应的基础数。 第一点： 基础数可以是负数，这个之前点到过。//并且下面的解法就是有这样的。 第二点： 当得到余数为1的时候后面的算式相当于是一个回溯的过程，最后解到-2 * 42。 但是还只不过是余数是1的情况对应的数，再运用定理2我们就得到了-252这个基础数。实际上要是看过乘法逆元，这里实际就是乘法逆元的求解过程，而-2也就是42关于15取模的乘法逆元。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt; #define ll long longusing namespace std;//扩展欧几里得算法 void exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(!b)&#123;d=a;x=1,y=0;&#125; else &#123; exgcd(b,a%b,d,y,x); y-=(a/b)*x; &#125;&#125;//中国剩余定理 ll China(int n,ll *m,ll *a)&#123; ll M=1,d,y,x=0; for(int i=0;i&lt;n;i++) M*=m[i]; for(int i=0;i&lt;n;i++) &#123; ll w=M/m[i]; gcd(m[i],w,d,d,y); x=(x+y*w*a[i])%M; &#125; return (x+M)%M;&#125;ll m[15],a[15];int main(int argc, char *argv[])&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%lld%lld",&amp;m[i],&amp;a[i]); printf("%lld",China(n,m,a));&#125; 题目传送门UVa-11426UVa-11582UVa-10375UVa-10791 Last edited - 2018-02-08 karriganasta ❤]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
