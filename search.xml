<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NOIP2018Ê∏∏ËÆ∞]]></title>
    <url>%2F2018%2F11%2F17%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Áªà‰∫éËÅîËµõËÄÉÂÆåÂï¶ ÂèØËÉΩ‰ªäÂπ¥Âú®Êù≠Â∑ûËÄÉÊúâbuffÂêß ÊÑüËßâËá™Â∑±ËøòÊòØËèúÁöÑÂ∏ÉÊòü ÂÜç‰∏çÂéªÊ∂®ÂßøÂäøÂêÉÊû£ËçØ‰∏∏ ÊàëÊ†°ËøôÊ¨°ËÄÉÁöÑÈÉΩÂæàÁâõÈÄºÂïä Êàë445‰ºº‰πéÂú®ÊàëÊ†°È´ò‰∏ÄÊéírankÂÄí3 Day -1ÊåâÁÖßÊÉØ‰æãËøòÊòØÊôö‰∏äËÄÉËØï ‰ºº‰πéÂèàÊòØzhxwmtÁöÑÈ¢ò ËØ∂Ëøô‰∏™È¢òÁöÑÈöæÂ∫¶ÊÄé‰πàËøô‰πàÊ∏ÖÂ•áÂïä ÊûúÁÑ∂ÊòØ‰ø°ÂøÉÂú∫ Êôö‰∏äÂæóÁü•ÊòéÂ§©ËøòË¶ÅËÄÉËØï ÂøÉÁîü‰∏çÁàΩ (ÂÜçËøá‰∏ÄÂ§©Â∞±ËÅîËµõ‰∫ÜËÄÉ‰∏™üêîÂÑøÂïä) ÁÑ∂ÂêéÂØπÁùÄÊüêË∞∑Â§ç‰π†‰∫ÜÂá†‰∏™ÊùøÂ≠ê Êï≤ÁöÑÊå∫Âø´ Ë∂Ö‰∏çÁü•ÈÅìËá™Â∑±ËØ•Âπ≤Âòõ Day 0‰∏äÂçàËÄÉËØï ÁÑ∂Âêé‰∏âÈÅìCOCIÂéüÈ¢ò ‰∏§‰∏™Â∞èÊó∂ÂÜôÊéâ‰∫ÜT1 T2,T1Â§ßÊ†∑‰æãÁúüÂùë T2Â∞±ÊòØ‰∏Ä‰∏™ÂÄçÂ¢ûÂ∞±Â•Ω‰∫Ü ÁúãÂà∞T3 Âπ≥Èù¢Áü©ÂΩ¢ ÁÑ∂Âêé‰∏≠Â§ÆÊúâ‰∏Ä‰∏™Â¢ûÈïøÁöÑÊ≠£ÊñπÂΩ¢ Ê±ÇÈù¢ÁßØ‰∫§ÁöÑÂíå ÁúüÁ†Å Ê†πÊú¨‰∏çÊÉ≥ÂÜô Â∞±200Âêß ‰∫§‰∫ÜÁÆó‰∫Ü ÁÑ∂ÂêéÂ§ßÂÆ∂‰ºº‰πé‰∏ÄËµ∑Ê¨¢‰πêÂú∞Âú®Ê≥ºÈöîËÜúÂïä Ëë£ÂÖàÁîüÁöÑ2048ÁúüÁ®≥Âïä NBAÁúüÂ•ΩÁúãÂïä S8iGÁúüÁåõÂïä ËÜúËõ§ÁúüÊúâË∂£Âïä ÁÑ∂ÂêéÂçÅ‰∏ÄÁÇπÂçäÊîæ‰∫Ü Âõû‰∫ÜË∂üÂÆ∂Êï¥‰∫Ü‰∏ãË°åÊùé ÂéªÊ•º‰∏ã‰π∞‰∫Ü‰∏™K ÊâìÁÆóÂ§ßÂ∑¥ËΩ¶‰∏äÂêî ÂùêËΩ¶ ÊÉ≥Âº∫Ëø´Ëá™Â∑±Áù°Ëßâ ÂëäËØâËá™Â∑±‰∏çË¶ÅÈ¢ìÂ∫ü Áù°ËßâÊú™Êûú Êêì‰∫Ü‰ºöÂÑøÁÇâÁü≥ Ê†∏ÂºπÁâßÁâõÈÄº ÁÑ∂ÂêéÂ∞±Áù°ÁùÄ‰∫Ü ‰∏≠Èó¥ÈöêÈöêÁ∫¶Á∫¶ËÉΩÂê¨Âà∞Êµ∑ËúáÁöÑÂëêÂñä:‚Äù‰∫îÊùÄ ÊàëÁöÑ ‰∫îÊùÄ ÂïäÂïäÂìàÂìàÂìà‚Äù Â§ßÂÆ∂‰πüÁúüÊòØÂøÉÊÄÅÂ•ΩÂïä ÊàëËøôÁßçËêåÊñ∞Â∞±ÊÖåÁöÑ‰∏ÄÊâπ ‰∏çÁü•‰∏çËßâÂ∞±ÂõûÂà∞ÂùëÂ∑û‰∫Ü ÊúâÁÇπÂ∞èÊÄÄÂøµÂïä Âæ∑ËÉúÁöÑÊî∂Ë¥πÁ´ôÂÖ•Âè£‰æùÁÑ∂Â†µ ÂùëÂ∑ûËøòÊòØÈÇ£‰∏™ÂùëÂ∑ûÂë¢ Ë¢´ÈÄöÁü•ÂÖàÂéªÊä•ÈÅì ‰∫éÊòØË∑üÁùÄÂéª‰∫Ü Â≠¶ÂÜõÁ¥´ÈáëÊ∏Ø ÊúâÈí±Âïä ÂÜç‰∏ÄÊ¨°ÊÑüÂèóÂà∞‰∫ÜÈïá‰∏≠Á°¨‰ª∂ËÆæÊñΩÂíåÊúâÈí±ÁöÑÂ≠¶ËΩ¶ÁöÑÂ∑ÆË∑ù ÂèëÁãóÁâåÂï¶ Ë¢´ÂàÜÂà∞Êú∫ÊàøÂéª‰∫Ü ÊûúÁÑ∂Áª≠ÂëΩÈÄâÊâãÂ∞±ÊòØ‰∏çËÉΩÂíåÂà´‰∫∫‰∏Ä‰∏™Âú∫È¶ÜÂë¢ Â∫ß‰ΩçÂè∑ D1 (‰Ω†‰∏™Â∞èÈÄºÂ¥ΩÂ≠êÂèàÂú®ÊöóÁ§∫Êàë) ÂéªÈÄõ‰∫Ü‰∏ãÂ∞èÂçñÈÉ®ÂíåÊ†°Âõ≠ ÂíñÂï°ÂéÖÈÉΩÊúâ ÁÑ∂ÂêéÂÅ∂ÈÅá‰∫ÜÁéãÊµ©Ôºü ÊôöÈ•≠Âú®Â≠¶ËΩ¶ÂêÉ ÊÄªÂÖ±Â∞±‰∏â‰∏™Ëèú Ê≤°ÂæóÈÄâ Á≥ñÈÜãÈáåËÑä=Á≥ñÈÜãÈù¢Á≤â Â∑ÆËØÑ ÂõûÂà∞ÈÖíÂ∫ó ‰ªñ‰ª¨ÂÖàÂõûÂéªÁöÑ‰∫∫Âõ†‰∏∫PAÊääÊàøÂç°ËêΩÂú®Â§ßÂ∑¥‰∏ä‰∫ÜÊâÄ‰ª•Âú®ÈÇ£ÈáåÁ≠â‰∫ÜËøë‰∏§‰∏™Â∞èÊó∂ Áªù‰∫Ü ÂíåboomÂ§ßÂàÜÂà∞‰∫Ü‰∏Ä‰∏™ÊàøÈó¥Âë¢ Â∑≤ÁªèÊòØ‰∏ÉÁÇπ‰∫Ü ÊÉ≥ÁùÄÁ¨¨‰∫åÂ§©Â∞±ËÅîËµõ‰∫Ü ‰∫éÊòØÂèà‰∏çÊîæÂøÉÂú∞ÂÜôÊùøÂ≠ê ÂÜô‰∫Ü‰∏™Ê†ëÂâñ ÂÜô‰∫ÜÂçä‰∏™Â∞èÊó∂ ÂèàË∞É‰∫ÜÂçÅÂàÜÈíüÊâçÂØπ Ëøô‰∏™ÈÄüÂ∫¶ Âîâ Ê≤°Êïë‰∫Ü Êôö‰∏äÁîµÂ≠ê‰∫ßÂìÅË¢´Êî∂Ëµ∞Âï¶ (ÊâÄ‰ª•ÂÅ∑ÂÅ∑Áúã‰∫Ü‰ºöÂÑøÁîµËßÜ) Day 1Á¨¨‰∏ÄÊ¨°ËÄÉTGÂë¢ È∏°ÂÜª ÂØÜÁ†ÅÊàëËæì‰∫Ü‰∫îÊ¨°ÊâçÂØπ Â∑ÆÁÇπÂ∞±ÂéªÈóÆËÄÅÂ∏àÂØÜÁ†Å‰∏çÂØπ‰∫Ü ‰∏¢‰∫∫ T1 ÂçßÊßΩÂ∑ÆÂàÜ‰∏Ä‰∏ãÂ∞±Ê≤°‰∫Ü 5minÂÜôÂÆå ËøáÂ§ßÊ†∑‰æã ‰∏çÁÆ°‰∫Ü ÊàëÂ±ÖÁÑ∂ÂÖàÂºÄ‰∫ÜT3 ‰∫åÂàÜÁ≠îÊ°à+Ê†ë‰∏äË¥™ÂøÉÔºüÊ†πËäÇÁÇπÂÑøÂ≠êÊùÉÂÄºÂÜÖÊâæÊúÄÂ§ßÂåπÈÖçÊï∞ÔºüÁÑ∂Âêé‰∏çË°åÁöÑÊâæ‰∏Ä‰∏™ÊúÄÂ§ßÁöÑ‰∏¢Áªô‰ªñÁöÑÁà∂‰∫≤ÔºüËøô‰∏™‰ºº‰πéÂèåÊåáÈíàtwo pointersÂ∞±Â•Ω‰∫ÜÂïä 30min ÂÜôÂÆå Ê†∑‰æã1 Ëøá‰∫Ü ËàíÊúç Ê†∑‰æã2 Ëøá‰∫Ü ËàíÊúç Ê†∑‰æã3 26175, ??? ËøôÊÄé‰πàÂÜôÊåÇ??? ÊáµÈÄº.jpg ‰∏ä‰∫Ü‰∏™ÂéïÊâÄÂÜ∑Èùô‰∫Ü‰∏Ä‰∏ã ÊÑüËßâËá™Â∑±‰∏ç‰ºöÊòØË¥™ÂøÉÊúâÈóÆÈ¢ò ‰∫éÊòØÊç¢‰∫Ü‰∏™ÂßøÂäøÂÜôtwo pointers ËøòÊòØ 26175 ÁÑ∂ÂêéÊàëÂ∞±ÁúüÁöÑ‰ª•‰∏∫ÊàëÁöÑË¥™ÂøÉ Ê≤°ÊúâÈóÆÈ¢ò‰∫Ü ËÄå‰∏îÂêéÊù•ÁöÑË∞ÉËØïÈÉΩÊ≤°ÊúâÂéªÊîπËøô‰∏™Ë¥™ÂøÉÁöÑÊú¨Ë¥® ÊàëÁöÑÂèåÊåáÈíàÂèç‰æãÈöè‰æøÊâæ ÊØîÂ¶ÇËøô‰∏™ ÂΩìÂâç‰∫åÂàÜÁöÑÂÄº‰∏∫10 Êúâ 4,7,9 ÊòæÁÑ∂4,7‰∏ÄÁªÑ Êää9‰∏¢‰∏äÂéªÊØîËæÉÂ•Ω ‰ΩÜÊòØÊàëÂèåÊåáÈíàÂ∞±Êää7‰∏¢Áªô‰∫ÜÁà∂‰∫≤ ‰∏çÊÖå ËøòÊúâ‰∏§‰∏™ÂçäÂ∞èÊó∂ ÁúãT2Âéª T2 ËøôËØ•‰∏ç‰ºöÊòØÊûö‰∏æ‰∏§‰∏™ax + by = zÁÑ∂ÂêézÂ∞±ÂèØ‰ª•ÂéªÊéâ exgcdÂïä ÂÆå‰∫ÜÂøò‰∫Ü ÂÜ∑ÈùôÂàÜÊûê‰∏Ä‰∏ãÂ∞±ÊòØ‰∏™ËÉåÂåÖÂòõ.Êú¨Êù•Âä†‰∫Ü‰∏™bitsetÂêéÊù•ÊÉ≥‰∫ÜÊÉ≥ËøòÊòØÁ®≥‰∏ÄÁÇπÂ∞±ÂéªÊéâ‰∫Ü 45minÂÜôÂÆå ‰∏çÁÆ°‰∫Ü ÂõûÂ§¥ÂÜçËØ¥ T3 ÂêÑÁßçÂßøÂäøÊç¢ÁùÄÂÜô Êú™Êûú ÊÄÄÁñë‰∫∫Áîü (‰∏ç‰ºöÊòØËøô‰∏™Ê†∑‰æãÈîô‰∫ÜÂêß) ËøôÁßçÁä∂ÊÄÅ‰∏ÄÁõ¥ÊåÅÁª≠Âà∞ËÄÉËØïÁªìÊùü ‰∫ãÂêéÂíåÂà´‰∫∫‰∫§ÊµÅT3 ÂèëÁé∞ÊàëË¥™ÂøÉÂÅá‰∫Ü Â∫îËØ•ÂÜçÂ•ó‰∫åÂàÜ‰∏Ä‰∏™ÂÄºÂéªÊâæÂêë‰∏ä‰∏¢ÁöÑÊúÄÂ§ßÂÄº ÂõûÈÖíÂ∫óÂèëÁé∞‰∏ÄÂ†Ü‰∫∫ AK ‰∫Ü boomËøô‰∏™Ë¥™ÂøÉÁî®‰∫Ü‰∏™map ÁÑ∂ÂêéÂ∏∏Êï∞Â∞±Â§ßÁöÑ‰∏çË°å 50000 $nlog^3n$ Ë¢´Âç°‰∫Ü ÊÉ®Âïä ÊàëÂèçÊ≠£Â∞±ÁéÑÂ≠¶ÂæóÂàÜ‰∫Ü $100 + 100 +???$ Á•ûÁäá‰∏≠ÂçàÈõÜ‰∏≠D‰∫∫ Âú∫Èù¢ÁîöÊòØÂ£ÆËßÇ ‰∏ãÂçàÂ§ßÂÆ∂ÈÉΩÊ≥ºÁöÑÊå∫ÂºÄÂøÉÁöÑÂïä ÁúãÂà∞ÁéãÂ∞ä‰∫ÜÂë¢ szkÁöéÊúàÊâìÈáéÁúüÂº∫Âïä Êôö‰∏äÂ§ç‰π†‰∫Üfhq-Treap ÂéªÂπ¥D2T3ËÄÉ‰∫Ü‰∏™Âπ≥Ë°°Ê†ë ÊÖåÁöÑ‰∏ÄÊâπ ÂÜô‰∫Ü‰∫åÂçÅÂàÜÈíü ÊúÄÂêéÂèëÁé∞Ëá™Â∑± inline int merge(int x,int y)ÂÜôÊåÇ‰∫Ü Day 2ÂºÄÂú∫ ÂØÜÁ†Å‰∏ÄÊ¨°ÂØπ‰∫Ü ËàíÊúç ‰ªäÂ§©Â∞±Â∞ΩÈáèÊãøÂàÜÂêß ÁúãÈ¢ò T1‰∏ÄÁúº $O(n^2)$ ÂçÅÂàÜÂèØÂÜô T2 ÊòØ‰∏™Êé®ÊüøÂ≠êÁöÑÂ•ΩÈ¢òÂïä ‰ΩÜÊòØËøô‰∏™È¢ò Êé®Âá∫Êù•Â∞±A Êé®‰∏çÂá∫Êù•ÂèØËÉΩÂ∞±Ë¶ÅÊªöÁ≤óÂïä T3 ‰ªÄ‰πàÔºüÂä®ÊÄÅDPÊ®°ÊùøÔºü ‰ªéÊù•Ê≤°ÂÜôËøá ÂÖà‰∏¢ÁùÄ‰∏çÁÆ° ÂºÄÂßãÂÜôT1 ÊâæÁéØÂ∞± $tarjan$ Âêß Êö¥ÂäõÂ∞±ÂÆå‰∫ã‰∫Ü ÁÑ∂ÂêéÊûö‰∏æ‰∏Ä‰∏ãÂà†ÊéâÁöÑËæπ 50minÂÜôÂÆå+Ë∞ÉËØï T2 È¢òÊÑè ÊàëÁêÜËß£‰∫Ü‰∏Ä‰∏™‰∏ñÁ∫™ $n = 2$ ÂóØÂÇªÈÄºÂÆπÊñ• $n = 3$ ÂóØ ÔºüÔºüÔºü Â∞ùËØïÊé®Âπø‰∫Ü‰∏ÄÊ≥¢ Êú™Êûú ÊØîËæÉÂêéÊÇîÁöÑÊòØÊ≤°ÊúâÂéªÂÜô ÈÇ£‰∏™$n,m &lt;= 8$ÁöÑÁä∂Âéã Êé®‰∫Ü‰∏§‰∏™Â∞èÊó∂ ÂèëÁé∞ÂÜôÂá∫Êù•ÂíåÈÇ£‰∏™ÂÆπÊñ•‰∏ç‰∏ÄÊ†∑ ÂøÉÊÄÅÂ¥©‰∫Ü ËøòÊúâ40min ÁÆó‰∫ÜT2 50ptsÂêß ÂéªÊãøT3ÁöÑ40pts ÂÜôÂÆå Ëøá‰∫ÜÁ¨¨‰∏Ä‰∏™Ê†∑‰æã ËøòÊúâÂçÅÂàÜÈíü‰∫Ü Ëµ∂Á¥ßÂéªÊ£ÄÊü•T1 T2 Êñá‰ª∂Âêç ‰∫éÊòØÂ∞±È¢ÑÊúü$100 +50 +40$‰∫Ü Âá∫ËÄÉÂú∫ÂèëÁé∞Â§ßÂÆ∂ÈÉΩËá™Èó≠‰∫Ü ‰ªäÂπ¥Ëøô‰∏™ÈöæÂ∫¶ÊéíÂ∏É ÊéíÁâàÁöÑÁªùÂØπÊòØ‰∏™ÁùøÊô∫ Êù≠Â∑ûÂëÜ‰∫Ü‰∏ÄÂ§©Â∞±ÊªöÂõûÂéªÂ≠¶ÊñáÂåñËØæÂï¶ ÂêéËÆ∞Day1T3 ÊàëÊ¥õË∞∑Êï∞ÊçÆ95pts Â≠¶ÂÜõÂ±±ÂØ®Êï∞ÊçÆ100 Èïá‰∏≠Êï∞ÊçÆ90 Êàë:??? boom:??? Day2T3 ÁàÜÈõ∂ Êö¥ÂäõÂÜôÊåÇ Ê≤°Ë∞Å‰∫Ü ‰∫éÊòØÁé∞Âú®ÁöÑÂàÜÊï∞È¢ÑÊúü $100 + 100 + 95 + 100 + 50 +0$ ËøòÂèØ‰ª•Êõ¥Â•ΩÁöÑÂïä‚Ä¶ lyx_cjz qiqi20021026 yhx12243 skylee03 bestFy _Chenkerui zjd dwt scx zzs boom GCC314 zzrh ÁâõÈÄºÔºÅ Ë¶ÅÊàê‰∏∫Ê∏©ÊüîÁöÑ‰∫∫Âïä]]></content>
      <categories>
        <category>Ê∏∏ËÆ∞</category>
      </categories>
      <tags>
        <tag>Ê∏∏ËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåBZOJ3123 / SDOI2013„Äç Ê£ÆÊûó ‰∏ªÂ∏≠Ê†ë+DSU ON TREE]]></title>
    <url>%2F2018%2F09%2F22%2F%E3%80%8CBZOJ3123-SDOI2013%E3%80%8D-%E6%A3%AE%E6%9E%97-%E4%B8%BB%E5%B8%AD%E6%A0%91-DSU-ON-TREE%2F</url>
    <content type="text"><![CDATA[ÂÜôÊØíÁò§ Â≠¶Â•óË∑Ø . Links there:BZOJ3123 È¢òÊÑèÊúâ‰∏Ä‰∏™ $N$ ÁªìÁÇπÁöÑÊ£ÆÊûó ÊØè‰∏Ä‰∏™ÁªìÁÇπÊúâ‰∏Ä‰∏™ÈùûË¥üÊùÉÂÄº ÂàùÂßãÁöÑÊó∂ÂÄôÊúâ $M$ Êù°Ëæπ. Êúâ $T$ ‰∏™Êìç‰Ωú. ËØ∑ÊîØÊåÅ‰∏ãÈù¢‰∏§‰∏™Êìç‰Ωú Âº∫Âà∂Âú®Á∫ø 1 $Q$ $x$ $y$ $k$ Êü•ËØ¢ÁÇπ $x$ Âà∞ÁÇπ $y$ ‰∏äÁ¨¨ $k$ Â∞èÁöÑÊùÉÂÄº ‰øùËØÅËæìÂÖ•ÂêàÊ≥ï 2 $L$ $x$ $y$ Âú® $x$ Âíå $y$ ‰πãÈó¥ËøûËæπ ËøûÂÆåËæπÂêé‰øùËØÅËøòÊòØÊ£ÆÊûó. $N,M,T \leq 80000$ ÊÄùË∑ØÂÖàÂØπ‰∫éÊâÄÊúâÂá∫Áé∞ÁöÑÂÄºÁ¶ªÊï£Âåñ ÂØπ‰∫éÁ¨¨‰∏Ä‰∏™Êìç‰ΩúËÄÉËôëÂØπÊØè‰∏™ËÅîÈÄöÂùóÂºÄ‰∏Ä‰∏™‰∏ªÂ∏≠Ê†ëÊØèÊ¨°Êñ∞Âä†ÁªìÁÇπÂ∞±ÁªßÊâø$father$ÁöÑ‰ø°ÊÅØ. ÊØèÊ¨°Êü•ËØ¢ÁöÑÊó∂ÂÄôÂú® $x$ $y$ $lca(x,y)$ $fa(lca(x,y))$ ‰∏äË∑ë‰∫åÂàÜ ËøôÊ†∑ÁöÑÂ§çÊùÇÂ∫¶ÊòØ $O(nlog^2n)$ ÁöÑ. ÂØπ‰∫éÁ¨¨‰∫å‰∏™Êìç‰ΩúÊù•ËØ¥ ËøôÁßçÂè™ÊúâËøûËæπÊ≤°ÊúâÊñ≠Ëæπ Áî® $Link CutTree$ ÂèØ‰ª•ÂÅöÂà∞ $nlogn$ ‰ΩÜÊòæÁÑ∂ÁªôËá™Â∑±Âä†Â§ß‰∫Ü‰ª£Á†ÅÂ§çÊùÇÂ∫¶ Êàë‰ª¨ËÄÉËôëÂêØÂèëÂºèÂêàÂπ∂ ËÆ∞ÂΩïÊØè‰∏™ËÅîÈÄöÂùóÁöÑ $fa$ Âíå $size$ ÊØèÊ¨°ËøûËæπÁöÑÊó∂ÂÄôÁî®Âπ∂Êü•ÈõÜÂéªÊü•Âì™‰∏™ËÅîÈÄöÂø´ÁöÑ $size$ Êõ¥Â§ßÁÑ∂ÂêéÊö¥ÂäõÈáçÊñ∞ËÆ°ÁÆó $ST$ Ë°®Âç≥ÂèØ ËøôÊ†∑ÁöÑÂ§çÊùÇÂ∫¶‰πüÊòØ $O(nlog^2n)$ ÁöÑ. ÊÄªÂ§çÊùÇÂ∫¶ $O(nlog^2n)$ ÂèØ‰ª•ÂûÉÂúæÂõûÊî∂‰ΩÜÊ≤°ÂøÖË¶Å. Code(‰∫∫‰∏ë‰ª£Á†ÅÈïø)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//What is broken can be reforged. --Riven#include&lt;bits/stdc++.h&gt;#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define mp make_pair#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;inline char NextChar(void)&#123;char c;for(c=getchar();!isalpha(c);c=getchar()); return c;&#125;const int MAXN = 8e4 + 100;const int MAXNODE = 1e7 + 100;int root[MAXN],lson[MAXNODE],rson[MAXNODE],sz[MAXNODE],n,m,T,fa[MAXN],k=0;int head[MAXN],cnt = 0,cntt = 0,st[MAXN][20],a[MAXN],b[MAXN],sum[MAXN],dep[MAXN],vis[MAXN],nn;vector&lt;int&gt;lt[MAXN];inline void addedge(int u,int v)&#123;lt[u].pb(v);&#125;inline int Getid(int x)&#123;return lower_bound(b+1,b+nn+1,x)-b;&#125;inline int getf(int x)&#123;return x == fa[x] ? x : fa[x] = getf(fa[x]);&#125;queue&lt;int&gt;dustbin;inline int Newnode()&#123; if (dustbin.empty()) return ++cnt; else &#123; int u = dustbin.front(); dustbin.pop(); return u; &#125;&#125;inline void Dec(int u)&#123; lson[u] = rson[u] = sz[u] = 0; dustbin.push(u);&#125;inline void decline(int u,int l,int r)&#123; if (!u) return ; if (l != r) &#123; int mid = (l + r) &gt;&gt; 1; decline(lson[u],l,mid); decline(rson[u],mid+1,r); &#125; Dec(u);&#125;inline void build(int &amp;k,int l,int r) &#123; k = Newnode(); sz[k] = 0; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; build(lson[k],l,mid); build(rson[k],mid+1,r);&#125;inline void ins(int &amp;k,int pre,int l,int r,int x)&#123; k = Newnode(); sz[k] = sz[pre] + 1; lson[k] = lson[pre]; rson[k] = rson[pre]; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) ins(lson[k],lson[pre],l,mid,x); else ins(rson[k],rson[pre],mid+1,r,x);&#125;inline int query(int x,int y,int x1,int y1,int l,int r,int k)&#123; if (l == r) return b[l]; int mid = (l + r) &gt;&gt; 1; int tmp = sz[lson[x]] + sz[lson[y]] - sz[lson[x1]] - sz[lson[y1]]; if (k &lt;= tmp) return query(lson[x],lson[y],lson[x1],lson[y1],l,mid,k); else return query(rson[x],rson[y],rson[x1],rson[y1],mid+1,r,k-tmp);&#125;void dfs(int u,int father,int rt)&#123; ++sum[rt]; st[u][0] = fa[u] = father; dep[u] = dep[father]+1; vis[u] = 1; for (int i = 1; i &lt;= 18; ++i) st[u][i] = st[st[u][i-1]][i-1]; //Dec(root[u]); root[u] = 0; ins(root[u],root[father],1,nn,Getid(a[u])); for (int i = 0; i &lt; lt[u].size(); ++i) &#123; //printf("%lld\n",v); int v = lt[u][i]; if (v == father) continue; dfs(v,u,rt); &#125;&#125;inline int LCA(int x,int y)&#123; if (x == y) return x; if (dep[x] &gt; dep[y]) swap(x,y); for (int i = 18; i &gt;= 0; i--) if (dep[st[y][i]] &gt;= dep[x]) y = st[y][i]; if (x == y) return x; for (int i = 18; i &gt;= 0; i--) &#123; if (st[x][i] != st[y][i]) &#123; x = st[x][i]; y = st[y][i]; &#125; &#125; return st[x][0];&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; // freopen("1.in","r",stdin); // freopen("1.ans","w",stdout); int hjqmy = read(); hjqmy = 1;T = hjqmy; n = read(),m = read(),T = read(); rep(i,1,n) &#123; b[i] = read(); a[i] = b[i]; fa[i] = i; &#125; sort(b+1,b+n+1); nn = unique(b+1,b+n+1)-b-1; //rep(i,1,nn) printf("%lld\n",b[i]); rep(i,1,m) &#123; int x = read(),y = read(); addedge(x,y);addedge(y,x); &#125; build(root[0],1,nn); for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i,0,i),fa[i] = i; //for (int i = 1; i &lt;= n; ++i) printf("%lld ",dep[i]); //for (int x,y;;) x=read(),y=read(),printf("%lld\n",LCA(x,y)); int lastans = 0; while(T--) &#123; char c = NextChar(); if (c == 'Q') &#123; int x = read()^lastans,y = read()^lastans,K = read()^lastans,x1 = LCA(x,y),y1 = st[x1][0]; printf("%lld\n",lastans = query(root[x],root[y],root[x1],root[y1],1,nn,K)); &#125; else &#123; int x = read()^lastans,y = read()^lastans; addedge(x,y); addedge(y,x); int fax = getf(x),fay = getf(y); if (sum[fax] &gt; sum[fay]) swap(x,y),swap(fax,fay); dfs(x,y,fay); &#125; &#125; return 0;&#125;/* Examples: *//**//**/]]></content>
      <categories>
        <category>‰∏ªÂ∏≠Ê†ë</category>
        <category>DSUÂêØÂèëÂºèÂêàÂπ∂</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåBZOJ5311 / CF321E„Äç Ë¥ûÈ±º WQS‰∫åÂàÜ+ÂÜ≥Á≠ñÂçïË∞É‰ºòÂåñ DP]]></title>
    <url>%2F2018%2F09%2F22%2F%E3%80%8CBZOJ5311-CF321E%E3%80%8D-%E8%B4%9E%E9%B1%BC-WQS%E4%BA%8C%E5%88%86-%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E4%BC%98%E5%8C%96-DP%2F</url>
    <content type="text"><![CDATA[ÂΩìÂÜ≥Á≠ñÂçïË∞É‰∏éWQS‰∫åÂàÜÁªìÂêà. Links there:CF321E bzoj5311 È¢òÊÑèÁªô $n$ Êù°Ë¥ûÈ±º‰∏éÊØèÂØπË¥ûÈ±º‰πãÈó¥ÁöÑÊÄ®Ê∞îÂÄº Ê±ÇÂàÜÊàê $K$ ÊÆµ,ÊØèÊÆµÁöÑÊÄ®Ê∞îÂÄº‰πãÂíåÁöÑÊúÄÂ∞èÂÄº. $1 \leq n \leq 4000, 1 \leq k \leq min(n,800)$ ÊÄùË∑ØÂÖàÊÉ≥Êú¥Á¥†ÁöÑ $dp$.‰∏çÈöæÊÉ≥Âà∞Ëøô‰∏™ $O(n^2k)$ ÁöÑËΩ¨Áßª f(i,k) = min{(f[j][k-1] + calc(j,i))}ÂÖ∂‰∏≠ $calc(i,j)$ Âà©Áî®ÂâçÁºÄÂíåÂÅö‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü.ÊòæÁÑ∂Ë∑ë‰∏çËøáÂéª. Á±ª‰ºº $JSOI2011 Lemon$ ,ÂÅáËÆæÊúâ $k &lt; j \leq i$ ,Êàë‰ª¨ÂèëÁé∞Â¶ÇÊûúÊúâ $j$ Âú®Êüê‰∏™Êó∂ÂàªÊØî $k$ ‰ºòÁßÄÈÇ£‰πàÂÆÉÊ∞∏ËøúÊØî $k$ ‰ºòÁßÄ.Âõ†‰∏∫$f[j] + calc(j,i) &gt; f[k] + calc(k,i)$ , $f[j] - f[k] &gt; calc(k,i) - calc(j,i) &gt; 0$ ‰ΩÜÊòØ‰∏çËÉΩÊñúÁéá‰ºòÂåñ Âõ†‰∏∫Âè≥ËæπÁöÑÂºèÂ≠êÂú®Êç¢‰∫ÜÂÜ≥Á≠ñÁÇπ‰πãÂêé Âπ∂‰∏ç‰∏ÄÂÆöÂçïË∞É. Êêû‰∏Ä‰∏™ÂçïË∞ÉÈòüÂàó ÂèàÊòØÁ±ª‰ºº $JSOI2011 Lemon$ ,‰øùËØÅÊõ¥‰ºòÁßÄÁöÑÁ≠îÊ°àÂá∫Áé∞ÁöÑÊó∂Èó¥ÂçïË∞É ÊØèÊ¨°‰∫åÂàÜÂéªÊâæ. ÁÑ∂ÂêéÊàë‰ª¨ÊàêÂäü‰ºòÂåñÂà∞‰∫Ü $O(nlognk)$ ÂèëÁé∞ËøòÊòØËøá‰∏çÂéª ‰∏∫‰ªÄ‰πàÂë¢ ËØªÂÖ•Â§™Â§ß‰∫Ü ÂÜçËÄÉËôë‰∏Ä‰∏™‰ºòÂåñ ËßÇÂØüÂà∞ËøôÈáåÁöÑÈôêÂà∂ÊòØÊÅ∞Â•Ω $K$ ÊÆµ Áî® $WQS$ ‰∫åÂàÜÁöÑÂ•óË∑Ø ÊØèÊ¨°ÈÄâ‰∏ÄÊÆµÁöÑÊó∂ÂÄôÂä†‰∏Ä‰∏™ÊÄ®Ê∞îÂÄº ËÆ∞ÂΩïÊúÄÂêéÈÄâ‰∫ÜÂá†ÊÆµ. ÂèëÁé∞Â¶ÇÊûúËøô‰∏™ÈôÑÂä†ÊÄ®Ê∞îÂÄºË∂äÂ∞èÁöÑËØùÂØπ‰∫éÂõ∫ÂÆöÁöÑ $i$ ÊÄªÊÆµÊï∞Ë∂äÂ§ß. ÁÑ∂ÂêéÁ≠îÊ°àËøòÂéüÂΩ±ÂìçÂ∞±ÂèØ‰ª•‰∫Ü. Ê≥®ÊÑè‰∫åÂàÜÁöÑËæπÁïå ËøôÁé©ÊÑè‰∏çÊòØ‰∏ÄËà¨ÁöÑÂùë Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//Keep pluggin',this is your only outlet.#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#define rep(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;inline char gc()&#123; static char buf[1&lt;&lt;16],*S,*T; if(S==T)&#123;T=(S=buf)+fread(buf,1,1&lt;&lt;16,stdin);if(T==S) return EOF;&#125; return *S++;&#125;inline int read(void)&#123; int x=0,f=1;char ch=gc(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=gc();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=gc();&#125; return x * f;&#125;const int MAXN = 4e3 + 100;int n,a[MAXN][MAXN],m,pre[MAXN][MAXN];int f[MAXN],c[MAXN],q[MAXN];inline int calc(int x,int y)&#123; return f[x] + ((pre[y][y] - pre[x][y] - pre[y][x] + pre[x][x]) &gt;&gt; 1);&#125;inline int isbetter(int x,int y,int t)&#123; int w1 = calc(x,t),w2 = calc(y,t); if (w1 &gt; w2) return 1; if (w2 &gt; w1) return 0; return (c[x] &gt;= c[y]);&#125;inline int Tim(int x,int y)&#123; //the pos decision x is better than y int l = y + 1,r = n,mid; while(l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (isbetter(x,y,mid)) r = mid - 1; else l = mid + 1; &#125; return r + 1; // +1 is the valid place.&#125;inline int isok(int mid)&#123; int head = 1,tail = 1; q[head] = 0; for (int i = 1; i &lt;= n; ++i) &#123; while(head &lt; tail &amp;&amp; isbetter(q[head],q[head+1],i)) ++head; f[i] = calc(q[head],i) + mid; c[i] = c[q[head]] + 1; while(head &lt; tail &amp;&amp; Tim(q[tail-1],q[tail]) &gt; Tim(q[tail],i)) --tail; q[++tail] = i; &#125; return c[n] &lt;= m;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n = read(),m = read(); int ans = 0; rep(i,1,n) rep(j,1,n) &#123; a[i][j] = read(); pre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1] + a[i][j]; //prefix sum &#125; int L = 0,R = pre[n][n] &gt;&gt; 1; while(L &lt;= R) &#123; // printf("%lld %lld\n",L,R); int mid = (L+R) &gt;&gt; 1; // printf("%lld\n",mid); if (isok(mid)) &#123;ans = f[n] - mid * m; R = mid - 1;&#125; else L = mid + 1; &#125; printf("%d\n",ans); return 0;&#125;/* Examples: *//**//**/]]></content>
      <categories>
        <category>WQS‰∫åÂàÜ</category>
        <category>DP-ÂÜ≥Á≠ñÂçïË∞É‰ºòÂåñDP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåBZOJ4709 / JSOI2011„Äç Êü†Ê™¨ ÂÜ≥Á≠ñÂçïË∞É‰ºòÂåñDP]]></title>
    <url>%2F2018%2F09%2F22%2F%E3%80%8CBZOJ4709-JSOI2011%E3%80%8D-%E6%9F%A0%E6%AA%AC-%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E4%BC%98%E5%8C%96DP%2F</url>
    <content type="text"><![CDATA[ÂèëÁé∞Ëá™Â∑±ÂØπ $DP$ ‰ºòÂåñ‰∏ÄÊó†ÊâÄÁü•. Links there:BZOJ-4709 È¢òÊÑèÊúâ $N$ ‰∏™Ë¥ùÂ£≥,ÊØè‰∏™Ë¥ùÂ£≥ÊúâÈ¢úËâ≤ $s_i$ ÂèØ‰ª•ÂèñËã•Âπ≤ÊÆµÁöÑË¥ùÂ£≥Âπ∂ÊØèÊ¨°ÊåáÂÆö‰∏Ä‰∏™È¢úËâ≤ $x$ ,ÂÆö‰πâÂú®ÊØè‰∏™ÈÄâÊã©ÁöÑÂå∫Èó¥ÂÜÖÂØπÁ≠îÊ°àÁöÑË¥°ÁåÆ‰∏∫ $x \times t[x]^2$ ,ÂÖ∂‰∏≠ $t[x]$ ‰∏∫Âú®Ëøô‰∏ÄÊÆµ‰∏≠È¢úËâ≤ $x$ ÁöÑÂá∫Áé∞Ê¨°Êï∞ ÊÄùË∑ØÂÖàË¶ÅÊÉ≥‰∏Ä‰∏™ÁªìËÆ∫: ÂÅáËÆæÊØèÊ¨°ÂèñÁöÑÂå∫Èó¥‰∏∫ $[L,R]$ ÈÇ£‰πàÂøÖÂÆöÊúâ $s_L = s_R$ ,‰πüÂ∞±ÊòØ‰∏§Á´ØÈ¢úËâ≤Áõ∏Âêå.ËøôÊ†∑Âèñ‰∏ÄÂÆöÊòØÊúÄ‰ºòÁöÑ. Â¶ÇÊûú‰∏§Á´ØÈ¢úËâ≤‰∏ç‰∏ÄÊ†∑ÁöÑËØù ÈÇ£‰πàËøô‰∏ÄÁÇπÂèØ‰ª•ÂΩíÂà∞Â∑¶ËæπÊàñËÄÖÂΩíÂà∞Âè≥Ëæπ ËÄå‰∏îÂØπÂçïÂçïËøô‰∏ÄÊÆµÁöÑÁ≠îÊ°àÊ≤°ÊúâÂΩ±Âìç ÊâÄ‰ª•Ê≠£Á°ÆÊÄßÊòæÁÑ∂ ËøôÊ†∑ÊâæÁöÑ‰∏ÄÂÆöÊúÄÂ§ß ÈÇ£‰πàËÆ∞ÂΩï $c[i]$ ‰∏∫È¢úËâ≤ $s_i$ ‰ªéÂºÄÂßãÂá∫Áé∞Âà∞Áé∞Âú®ÁöÑÊ¨°Êï∞ ÊòæÁÑ∂ÊúâËΩ¨Áßª f[i] =max(f[j-1],a[i] *{(s[i]-s[j]+1)}^2)ËøôÊ†∑ÁöÑÂ§çÊùÇÂ∫¶ÊòØ $O(n^2)$ ÁöÑ. ËÄÉËôë‰ºòÂåñ ÊòæÁÑ∂‰∏çËÉΩÊñúÁéá‰ºòÂåñ Âõ†‰∏∫ÂØπ‰∫é $i&lt;j$ , $i$ ÁöÑÂÜ≥Á≠ñ‰ºöÂΩ±ÂìçÂà∞ $j$ ÁöÑÂÜ≥Á≠ñ ËßÇÂØüËΩ¨ÁßªÊñπÁ®ã ÂèëÁé∞Â¶ÇÊûúËØ¥Êúâ $k &lt; j \leq i$ ÂÅáÂ¶Ç $k$ ÁöÑËΩ¨ÁßªË¶ÅÊØî $j$ ‰ºòÁßÄ,ÈÇ£‰πàÂú®ÂêéÈù¢ÁöÑËΩ¨Áßª‰∏≠ $j$ ÊòØ‰∏ÄÂÆöÁî®‰∏çÂà∞ÁöÑ Âõ†‰∏∫Âπ≥Êñπ‰ºöË∂äÊù•Ë∂äÂ§ß Âõ†Ê≠§ÂèØ‰ª•ÂØπÊØè‰∏Ä‰∏™È¢úËâ≤ÂºÄ‰∏Ä‰∏™Ê†à ÊØèÊ¨°ÂèëÁé∞Ê†àÈ°∂ÁöÑÊ≤°Êúâ‰∏ãÈù¢ÈÇ£‰∏™ËΩ¨Áßª‰ºòÁßÄÂ∞±Êää‰ªñÂºπÊéâ. ÁÑ∂Âêé‰Ω†Â∞±ÂèëÁé∞‰Ω†WA‰∫Ü Âõ†‰∏∫Ëøô‰πàÂÅöÂè™ËÉΩ‰øùËØÅË¢´ÂºπÊéâÁöÑ‰∏çÂÜçÊúâÁî® ‰ΩÜÊàë‰ª¨Ê±ÇÁöÑÊòØÊúÄÂ§ßÂÄº Êó†Ê≥ï‰øùËØÅÊ†àÈ°∂ÁöÑ‰∏ÄÂÆöÊúÄ‰ºòÁßÄ ÊØîÂ¶ÇÂá∫Áé∞Ê†à‰∏≠Á¨¨‰∏â‰∏™Êõ¥‰ºòÁßÄÁöÑÊÉÖÂÜµ. ÈÇ£‰πàÊàë‰ª¨Â∞±Ë¶Å‰ªéÂÖ•Ê†àÊó∂Èó¥Êù•ÊÉ≥ ‰ªçÁÑ∂ÂÅáËÆæ $k &lt; j \leq i$ ,Êàë‰ª¨ÂÅáÂÆö $k$ ËΩ¨ÁßªÂú® $k_1$ ‰ºò‰∫é $i$ ,$j$ Âú® $j_1$ ‰ºò‰∫é $i$ Â¶ÇÊûúÊúâ $k_1 &lt; j_1$ ‰ºöÂèëÁîü‰ªÄ‰πàÂë¢. ‰ªîÁªÜÊ®°Êãü‰πãÂêéÊàë‰ª¨ÂèëÁé∞ Ê†à‰∏≠Á¨¨‰∏Ä‰∏™ÂÖÉÁ¥†ÊØîÁ¨¨‰∫å‰∏™‰ºòÁßÄ,ËÄå‰∏ãÈù¢ËøòÊúâ‰∏Ä‰∏™Êõ¥‰ºòÁßÄÁöÑ $k_1$ Êàë‰ª¨Ê≤°ÊääÂÆÉÂèñÂá∫Êù•. ËøôÂ∞±ÊòØ‰∏áÊÅ∂‰πãÊ∫ê Âõ†Ê≠§ÈÅáÂà∞ $k_1 &lt; j_1$ ÁöÑÊÉÖÂÜµ Â∞±ÂºπÂá∫ ‰øùËØÅÊ†àÂÜÖÂÖÉÁ¥†ÊØî‰∏ä‰∏Ä‰∏™ÂÖÉÁ¥†Êõ¥‰ºòÁöÑÊó∂Èó¥‰πüÊòØÂçïË∞ÉÁöÑ Âõ†Ê≠§‰∫åÂàÜÂéªÊâæËøô‰∏™ ‚ÄúÊõ¥‰ºòÊó∂Èó¥‚Äù Â∞±Ë°åÂï¶. Â§çÊùÇÂ∫¶$O(nlogn)$ ÂèØ‰ª•ÊêûËøáÂéª. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Keep pluggin',this is your only outlet.#include&lt;bits/stdc++.h&gt;#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define mp make_pair#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int quickmul(int x,int y,int mod)&#123;return (x*y-(int)((long double)x/mod*y)*mod+mod)%mod;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5 + 100;vector&lt;int&gt;sta[MAXN];int n,col[MAXN],a[MAXN],f[MAXN],c[MAXN];inline int Calc(int x,int y) &#123; return f[x-1] + (c[y]-c[x]+1) * (c[y]-c[x]+1) * a[y];&#125;inline int Tim(int x,int y) &#123; int l = 1,r = n,mid,cur = (c[y] - c[x]); while(l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if (f[x-1] + (mid + cur) * (mid + cur) * a[x] &lt; f[y-1] + mid * mid * a[y]) l = mid + 1; else r = mid; &#125; return r;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n = read(); rep(i,1,n) a[i] = read(); for (int i = 1; i &lt;= n; ++i) &#123; c[i] = ++col[a[i]]; while((signed)sta[a[i]].size()&gt;=2 &amp;&amp; Tim(sta[a[i]][(signed)sta[a[i]].size()-2],i) &lt; Tim(sta[a[i]][(signed)sta[a[i]].size()-1],i)) sta[a[i]].pop_back(); sta[a[i]].push_back(i); while((signed)sta[a[i]].size()&gt;=2 &amp;&amp; Calc(sta[a[i]][(signed)sta[a[i]].size()-2],i) &gt; Calc(sta[a[i]][(signed)sta[a[i]].size()-1],i)) sta[a[i]].pop_back(); f[i] = Calc(sta[a[i]][sta[a[i]].size()-1],i); for (int j = 0; j &lt; sta[a[i]].size()-1; ++j) f[i] = max(f[i],Calc(sta[a[i]][j],i)); //printf("%lld\n",f[i]); &#125; printf("%lld\n",f[n]); return 0;&#125;/* Examples: *//**//**/]]></content>
      <categories>
        <category>DP-ÂÜ≥Á≠ñÂçïË∞É‰ºòÂåñDP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåBZOJ3622 „ÄçÂ∑≤ÁªèÊ≤°Êúâ‰ªÄ‰πàÂ•ΩÂÆ≥ÊÄïÁöÑ‰∫Ü ÂÆπÊñ• DP]]></title>
    <url>%2F2018%2F09%2F22%2F%E3%80%8CBZOJ3622-%E3%80%8D%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86-%E5%AE%B9%E6%96%A5-DP%2F</url>
    <content type="text"><![CDATA[Links there:BZOJ3622 È¢òÊÑèÊúâ $N$ ‰∏™ËçØÂíåÁ≥ñ ÊØè‰∏™ËçØÂíåÁ≥ñÈÉΩÊúâËá™Â∑±ÁöÑËÉΩÈáè ‰ªñ‰ª¨‰πãÈó¥ÂèØ‰ª•‰∏§‰∏§ÈÖçÂØπ Ê±ÇÁ≥ñÁöÑËÉΩÈáèÊØîËçØÁöÑËÉΩÈáèÂ§ßÁöÑÈÖçÂØπÊï∞ÊØîËçØÁöÑËÉΩÈáèÊØîÁ≥ñÁöÑËÉΩÈáèÂ§ßÁöÑÁªÑÊï∞ÊÅ∞Â•ΩÂ§ö $K$ ÁöÑÊñπÊ°àÊï∞. ÊÄùË∑ØÂéüÈ¢òÊÑèÂç≥Á≥ñÁöÑËÉΩÈáèÊØîËçØÁöÑËÉΩÈáèÂ§ßÁöÑÁªÑÊï∞ÊÅ∞Â•Ω‰∏∫ $\frac{N+K}{2}$ ÁªÑÁöÑÊñπÊ°àÊï∞. ÂÖàÊéí‰∏™Â∫è ÂÜçÂÆπÊñ•‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü $f[i][j]$ Ë°®Á§∫ÈÄâÊã©Ââç $i$ ‰∏™Áâ©ÂìÅ ÁªÑÊï∞Ëá≥Â∞ë‰∏∫ $j$ ÁöÑÊñπÊ°à. $f[i][j] = \sum f[i-1][j] + f[i-1][j-1] * (k -j+1)$ Ê≥®ÊÑèÊúÄÂêéÁªüËÆ°Á≠îÊ°àÁöÑÊó∂ÂÄô ÈÇ£‰∫õÂâ©‰∏ãÁöÑ $n - i$ ÊòØÂèØ‰ª•ÈöèÊÑèÊéíÂàóÁöÑË¶Å‰πò‰∏äÈò∂‰πò. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//Keep pluggin',this is your only outlet.#include&lt;bits/stdc++.h&gt;#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define mp make_pair#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int quickmul(int x,int y,int mod)&#123;return (x*y-(int)((long double)x/mod*y)*mod+mod)%mod;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int Mod = 1e9 + 9;const int MAXN = 2e3 + 100;int f[MAXN][MAXN],k,n,a[MAXN],b[MAXN],fac[MAXN],inv[MAXN];inline void pre(void)&#123; fac[0] = inv[0] = 1; for (int i = 1; i &lt; MAXN; ++i) fac[i] = fac[i-1] * i % Mod; inv[MAXN-1] = getinv(fac[MAXN-1],Mod); for (int i = MAXN-2; i &gt;= 1; --i) inv[i] = inv[i+1] * (i + 1) % Mod;&#125;inline int C(int n,int m)&#123; if (m &gt; n) return 0; return fac[n] * inv[n - m] % Mod * inv[m] % Mod;&#125;inline void upd(int &amp;x,int y)&#123;x = (x + y) % Mod;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; //freopen("3622.in","r",stdin); //freopen("3622.out","w",stdout); pre(); //printf("%lld\n",C(6,2)); n = read(),k = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= n; ++i) b[i] = read(); sort(a+1,a+n+1); sort(b+1,b+n+1); f[0][0] = 1; for (int i = 1,k = 0; i &lt;= n; ++i) &#123; while(k &lt; n &amp;&amp; b[k+1] &lt; a[i]) ++k; for (int j = 1; j &lt;= i; ++j) &#123; upd(f[i][j],f[i-1][j]); upd(f[i][j],f[i-1][j-1] * (max(0LL,k - j + 1)) % Mod); &#125; f[i][0] = f[i-1][0]; &#125; int nk = (n + k) &gt;&gt; 1,ans = 0; for (int i = nk,d = 1; i &lt;= n; ++i,d = Mod - d) upd(ans,f[n][i] * d % Mod * C(i,nk) % Mod * fac[n-i] % Mod);//printf("%lld\n",ans); printf("%lld\n",ans); return 0;&#125;/* Examples: *//**//**/]]></content>
      <categories>
        <category>DP-ÂÆπÊñ•DP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåBZOJ3065„Äç Â∏¶ÊèíÂÖ•Âå∫Èó¥KÂ∞èÂÄº ÊõøÁΩ™ÁæäÊ†ëÂ•ó‰∏ªÂ∏≠Ê†ë]]></title>
    <url>%2F2018%2F09%2F22%2F%E3%80%8CBZOJ3065%E3%80%8D-%E5%B8%A6%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4K%E5%B0%8F%E5%80%BC-%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91%E5%A5%97%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Áúü-ÊØíÁò§È¢ò Links there:BZOJ3065 È¢òÊÑèÂ¶ÇÈ¢ò,Âº∫Âà∂Âú®Á∫ø,Â∏¶‰øÆÊîπ,Â∏¶ÊèíÂÖ•ÁöÑÂå∫Èó¥ $k‚Äã$ Â∞èÂÄºÁöÑÊü•ËØ¢ ÊÄùË∑Ø‰∏çÂ∏¶ÊèíÂÖ•ÊòØÂèØ‰ª•Â∏¶‰øÆ‰∏ªÂ∏≠Ê†ëÁõ¥Êé•ÂÅöÁöÑ ‰∏çÂ∏¶ÊèíÂÖ•ÁöÑÂè≥ËΩ¨ BZOJ1901 Ëøô‰∏™ÊèíÂÖ•ÁöÑÊìç‰ΩúÂçÅÂàÜÁöÑ‰ª§‰∫∫ÊÅ∂ÂøÉ Êàë‰ª¨Ë¶ÅÂ§öÁª¥Êä§‰∏Ä‰∏™Âå∫Èó¥È°∫Â∫èÁöÑ‰ø°ÊÅØ‰∫Ü ËÑëÊµ∑ÈáåÂõûÈ°æ‰∏Ä‰∏ãÂ≠¶ËøáÁöÑÊØíÁò§ÁöÑÊï∞ÊçÆÁªìÊûÑ ‰ºº‰πéÂè™ÊúâÂπ≥Ë°°Ê†ëËÉΩÊêûËøô‰∏™‰∏úË•ø‰∫Ü ÊâÄ‰ª•Êàë‰ª¨Áî®ÊõøÁΩ™ÁæäÊ†ëÂ•ó‰∏ªÂ∏≠Ê†ë! Treap?Splay?ÊèíÂÖ•ÁöÑÊó∂ÂÄôË¶ÅrotateÂ§™ÈöæÂÜô! Êàë‰ª¨Áî®Êö¥ÂäõÈáçÊûÑÁöÑScapegoat! ‰∏çÁî®ÊóãËΩ¨ ÊÄùÁª¥ÊØîËæÉÁÆÄÂçï ÂÆûÁé∞ÈöæÂ∫¶‰Ωé ‰ª£Á†ÅÈáèÂ∞è ÁªùÂØπÊòØÈùûÂèØÊåÅ‰πÖÂåñÂπ≥Ë°°Ê†ëÁöÑÈ¶ñÈÄâÂïä ÊØèÊ¨°Êö¥ÂäõÈáçÊûÑÁöÑÊó∂Èó¥ÊòØ $O(nlog^2n)$ ÊØè‰∏™ÁÇπÊúüÊúõÈáçÊûÑÊ¨°Êï∞ÊòØ‰∏•Ê†ºÂ∞è‰∫é $logn$ Ê¨°ÁöÑÊâÄ‰ª•ÊÄªÂ§çÊùÇÂ∫¶Â∞è‰∫éÁ≠â‰∫é $O(nlog^3n)$ ÂÜçËÄÉËôë‰∏Ä‰∏ãËØ¢ÈóÆ ËøôÈáåÊòØË¶ÅÊääÊØè‰∏™ÁªìÁÇπÂØπÂ∫îÂå∫Èó¥ÁöÑËäÇÁÇπ‰Ωú‰∏∫‰∏Ä‰∏™ÂêëÈáèÊãâÂá∫Êù• ÂØπ‰∫éÂêëÈáèË∑ë‰∫åÂàÜ. ‰∫åÂàÜÂ§çÊùÇÂ∫¶ $logn$ ÊØèÊ¨°ËØ¢ÈóÆÂØªÊâæÂ§çÊùÇÂ∫¶ $logn$ ÊâÄ‰ª•ËØ¢ÈóÆÁöÑÂ§çÊùÇÂ∫¶‰∏∫ $O(qlog^2n)$ ËøòÊúâÊ≤°Êúâ‰ºòÂåñÁöÑ‰ΩôÂú∞Âë¢ ? Á≠îÊ°àÊòØËÇØÂÆöÁöÑ ÂØπ‰∫é $N$ ‰∏™ÊùÉÂÄºÂå∫ÂüüÁõ∏ÂêåÁöÑ‰∏ªÂ∏≠Ê†ëÂêàÂπ∂ÂèØ‰ª•ÂÅöÂà∞ $O(nlogn)$ ÊØèÊ¨°Êö¥ÂäõÈáçÊûÑÁöÑÂ§çÊùÇÂ∫¶ÂèØ‰ª•ÈÄöËøáÊùÉÂÄºÁ∫øÊÆµÊ†ëÁöÑÂêàÂπ∂ÂÅöÂà∞ $O(nlog^2n)$ ËøôÊ†∑ÊúÄÂêéÁöÑÂ§çÊùÇÂ∫¶ÊòØ $O((n+q) \times log^2n)$ ÁöÑ‰ΩÜÊòØÂõ†‰∏∫Êö¥ÂäõÈáçÊûÑÁöÑÊ¨°Êï∞ÂÆûÈôÖ‰∏äÂπ∂‰∏çÂ§ö Âõ†Ê≠§Ëøô‰∏™‰ºòÂåñÂÆûË¥®‰∏ä‰πü‰∏çÊòéÊòæ Ê≥®ÊÑèÂûÉÂúæÂõûÊî∂! ÂûÉÂúæÂõûÊî∂‰∏ÄÂÆö‰∏çË¶ÅÂÜôÊåÇ! (ËøôÂ∞±ÊòØÊàëË∞É‰∏Ä‰∏™‰∏äÂçàÁöÑÁêÜÁî±) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//What is broken can be reforged.#include&lt;bits/stdc++.h&gt;#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define mp make_pair#define se secondusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int N = 1e7 + 100,m =70000,M = 1e5 + 100;int c[N][2],lson[M],rson[M],rt[M],sz[N],pool[N + 5],rub = 0,q[M],a[M],p[M],headpq;int n,root = 0,headp,headq,trtot = 0,lastans = 0;inline char NextChar(void)&#123;char c = getchar(); while(!isalpha(c)) c = getchar(); return c;&#125;const double xs = 0.75;int Newnode()&#123; if (!rub) return ++trtot; else return pool[rub--];&#125;void Recycle(int &amp;k)&#123; if (rub &gt; N) --rub; pool[++rub] = k; if (c[k][0]) Recycle(c[k][0]); if (c[k][1]) Recycle(c[k][1]); sz[k] = 0; k = 0;&#125;void dfs(int &amp;u) &#123; Recycle(rt[u]); if (lson[u]) dfs(lson[u]); p[++headp] = u; if (rson[u]) dfs(rson[u]);&#125;void ins(int &amp;k,int l,int r,int x,int y)&#123; if (!k) k=Newnode(); if (l==r)&#123; sz[k]+=y; return; &#125; int mid=(l+r)&gt;&gt;1; if (x&lt;=mid) ins(c[k][0],l,mid,x,y); else ins(c[k][1],mid+1,r,x,y); sz[k]=sz[c[k][0]]+sz[c[k][1]]; if (!sz[k]) Recycle(k);&#125;void build(int &amp;k,int l,int r)&#123; if (l&gt;r) return; if (l==r)&#123; k=p[l]; ins(rt[k],0,m,a[k],1); return; &#125; int i,mid=(l+r)&gt;&gt;1; k=p[mid]; build(lson[k],l,mid-1); build(rson[k],mid+1,r); for (i=l; i&lt;=r; i++) ins(rt[k],0,m,a[p[i]],1);&#125;void rebuild(int &amp;k)&#123; headp=0; dfs(k); build(k,1,headp);&#125;bool add(int &amp;k,int x,int y)&#123; if (!k)&#123; k=++n; ins(rt[k],0,m,y,1); a[k]=y; return 0; &#125; ins(rt[k],0,m,y,1); int tmp=sz[rt[lson[k]]]; bool bo; if (tmp&gt;=x) bo=add(lson[k],x,y); else bo=add(rson[k],x-tmp-1 ,y); if (sz[rt[k]]*0.75&gt;max(sz[rt[lson[k]]],sz[rt[rson[k]]]))&#123; if (bo) if (tmp&gt;=x) rebuild(lson[k]); else rebuild(rson[k]); return 0; &#125; else return 1;&#125;inline void getid(int k,int l,int r)&#123; if (l == 1 &amp;&amp; r == sz[rt[k]]) &#123;p[++headp] = rt[k]; return ;&#125; int t = sz[rt[lson[k]]] + 1; if (l &lt;= t &amp;&amp; r &gt;= t) q[++headq] = a[k]; if (r &lt; t) getid(lson[k],l,r); else if (l &gt; t) getid(rson[k],l-t,r-t); else &#123; if (l &lt; t) getid(lson[k],l,t-1); if (r &gt; t) getid(rson[k],1,r-t); &#125;&#125;int solve(int x,int y,int rst)&#123; headp=0; headq=0; getid(root,x,y); rst--; int l=0,r=m,mid,i,tmp; while (l&lt;r)&#123; mid=(l+r)&gt;&gt;1; tmp=0; for (i = 1; i&lt;=headp; i++) tmp+=sz[c[p[i]][0]]; for (i = 1; i&lt;=headq; i++) if (l &lt;= q[i] &amp;&amp; q[i]&lt;=mid) tmp++; if (tmp&gt;rst)&#123; for (i=1; i&lt;=headp; i++) p[i]=c[p[i]][0]; r=mid; &#125; else&#123; for (i=1; i&lt;=headp; i++) p[i]=c[p[i]][1]; l=mid+1;rst-=tmp; &#125; &#125; return l;&#125;int Modify(int k,int x,int y)&#123; ins(rt[k],0,m,y,1); int t = sz[rt[lson[k]]] + 1,ret; if (x == t) &#123;ret = a[k]; a[k] = y;&#125; else if (x &lt; t) ret = Modify(lson[k],x,y); else ret = Modify(rson[k],x-t,y); ins(rt[k],0,m,ret,-1); return ret;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n = read(); rep(i,1,n) a[i] = read(),p[i] = i; build(root,1,n); int op = read(); while(op--) &#123; char c = NextChar(); int x = read()^lastans,y = read()^lastans; //printf("%lld %lld\n",x,y); if (c == 'I') &#123;if (add(root,x-1,y)) rebuild(root);&#125; else if (c == 'Q') &#123; int z = read()^lastans; lastans = solve(x,y,z); printf("%d\n",lastans); &#125; else Modify(root,x,y); &#125; return 0;&#125;/* Examples: *//**//**/]]></content>
      <categories>
        <category>ÂµåÂ•óÊï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåCF739E„Äç Gosha is hunting WQS‰∫åÂàÜ‰ºòÂåñdp]]></title>
    <url>%2F2018%2F09%2F17%2F%E3%80%8CCF739E%E3%80%8D-Gosha-is-hunting-WQS%E4%BA%8C%E5%88%86%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[Links there:CF739E ÂÜô‰∫Ü‰∏™ $O(n^3)$ÁöÑÊ¶ÇÁéáËΩ¨Áßª $dp$ Ë¢´ÂäùÈÄÄ‰∫Ü‰∏ç‰ºö‰ºòÂåñ Âè™ËÉΩÂéªË°•ÂßøÂäø È¢òÊÑèÊúâ $N$ ‰∏™ÊÄ™Áâ©,‰Ω†Êúâ $a$ ‰∏™ $Pokeball$ Âíå $b$ ‰∏™ $Ultraball$. ÁªôÂá∫ÊØè‰∏™ÊÄ™Áâ©ÂàÜÂà´Ë¢´ $Pokeball$ ÂíåË¢´ $Ultraball$ ÊçïËé∑ÁöÑÊ¶ÇÁéá Ê±ÇÊúÄÂ§ßËÉΩÊçïËé∑‰∏™Êï∞ÁöÑÊúüÊúõ. ÊÄùË∑Ø‰∏äÊù•Êä±ÁùÄ $codeforces $ Ë∑ëÁöÑÂ∑®Âø´ÁöÑÂøÉÊÄÅÂÜô‰∫Ü‰∏ÄÂèë $O(n^3)$ Áî® $f(i,j,k)$ Ë°®Á§∫ Ââç $i$ ‰∏™ÊÄ™Áâ©Áî® $j$ ‰∏™ $Pokeball$, $k$ ‰∏™ $Ultraball$ ÁöÑÊúÄÂ§ßÊúüÊúõ. Ëøô‰∏™ËΩ¨ÁßªÊòæÁÑ∂,ËÆ®ËÆ∫‰∏Ä‰∏ãÊØè‰∏™ÊÄ™Áâ© ‰∏çÁî®ÁêÉ / Áî®Pokeball / Áî®Ultraball / ÈÉΩÁî® Â§ßÊ¶ÇÂÜôÂá∫Êù•ËøôÊ†∑Â≠ê 123456789101112for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= a; ++j) for (int k = 0; k &lt;= b; ++k)&#123; int lst = (i &amp; 1) ? 0 : 1; upd(f[lst^1][j][k],f[lst][j][k]); if (j &gt;= 1) upd(f[lst^1][j][k],f[lst][j-1][k] + p[i]); if (k &gt;= 1) upd(f[lst^1][j][k],f[lst][j][k-1] + u[i]); if (j &gt;= 1 &amp;&amp; k &gt;= 1) upd(f[lst^1][j][k],f[lst][j-1][k-1] + 1.0 - (1.0 - p[i]) * (1.0 - u[i])); if (i == n) upd(ans,f[lst^1][j][k]); &#125; &#125; ÁÑ∂Âêé‰Ω†Â∞±ÂèëÁé∞‰Ω† $T$ È£û‰∫Ü. Áî® $WQS$ ‰∫åÂàÜÁöÑÊÄùÊÉ≥ ÂéüÈóÆÈ¢òÊòæÁÑ∂ÂøÖÈ°ªÊää $a,b$ ÂèñÂÖâ. ÊâÄ‰ª•ËøôÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™Êúâ2‰∏™ÈôêÂà∂ÁöÑÂèñ $K$ ‰∏™Áâ©ÂìÅÁöÑÈóÆÈ¢ò Âõ∫ÂÆö $f(i,a,k)$ ÁöÑ $i,a$ ÁöÑÊó∂ÂÄô , ÂèëÁé∞ $f(i,a,k)$ ÊòØÂÖ≥‰∫é $k$ ÁöÑÂá∏ÂáΩÊï∞. ËøôÊòØÊòæÁÑ∂ÁöÑÂØπ‰∫éÂõ∫ÂÆöÁöÑ $i$ ,‰Ω†ÊâîÁöÑÁêÉÁöÑ‰∏™Êï∞Ë∂äÂ§öÁöÑËØùÊî∂ÁõäË∂äÂ∑Æ. Á±ª‰ººÁöÑ , Âõ∫ÂÆö $f(i,j,b)$ ÁöÑ $i,b$ ÁöÑÊó∂ÂÄô , ÂèëÁé∞ $f(i,j,b)$ ÊòØÂÖ≥‰∫é $j$ ÁöÑÂá∏ÂáΩÊï∞. ÈÇ£‰πà‰∏çÂ¶ÇÁªôÊØè‰∏™ÁêÉÂä†‰∏§‰∏™ÈôêÂà∂ $cost1 \space cost2$ Ë°®Á§∫ÊØè‰∏™Á±ªÂûãÁöÑÁêÉÈ¢ùÂ§ñÁöÑ‰ª£‰ª∑. ‰∫åÂàÜÂ•ó‰∫åÂàÜ,ÊúÄÂêéÊääËøô‰∏ÄÈÉ®ÂàÜÂΩ±ÂìçËøòÂéüÂ∞±ÊòØÁ≠îÊ°à. Âõ†‰∏∫ $cost1 \space cost2$ ÁöÑËåÉÂõ¥Âú® $[0,1]$ ‰πãÈó¥ ÊâÄ‰ª•‰∫åÂàÜÁöÑÊ¨°Êï∞ÂæàÂ∞ë (Áúã‰Ω† eps) Âá†‰πéÂ∞±ÊòØ $O(n\times x^2)$ ,$x$ ‰∏∫‰∫åÂàÜÂ∏∏Êï∞ ÂèØÂ∞è‰∫Ü. Ë∑ëÁöÑËøòÁúüÊòØÂø´Âë¢. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//Keep pluggin',this is your only outlet.#include&lt;bits/stdc++.h&gt;#pragma GCC optimize("Ofast")#pragma GCC optimize("unroll-loops")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define mp make_pair#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int quickmul(int x,int y,int mod)&#123;return (x*y-(int)((long double)x/mod*y)*mod+mod)%mod;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;double f[2010];double p[2010],u[2010],pu[2010];int numa[2010],numb[2010];int a,b,n;inline void upd(double &amp;x,double y) &#123;x = max(x,y);&#125;const double eps = 1e-10;inline void Calc(double c1,double c2)&#123; f[0] = 0.0; numa[0] = numb[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = f[i-1] ; numb[i] = numb[i-1]; numa[i] = numa[i-1]; if (f[i-1] + p[i] - c1 &gt; f[i]) &#123; f[i] = f[i-1] + p[i] - c1; numa[i] = numa[i-1] + 1; numb[i] = numb[i-1]; &#125; if (f[i-1] + u[i] - c2 &gt; f[i]) &#123; f[i] = f[i-1] + u[i] - c2; numa[i] = numa[i-1]; numb[i] = numb[i-1] + 1; &#125; if (f[i-1] + pu[i] - (c1 + c2) &gt; f[i]) &#123; f[i] = f[i-1] + pu[i] - (c1 + c2); numa[i] = numa[i-1] + 1; numb[i] = numb[i-1] + 1; &#125; &#125;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n = read(),a = read(),b = read(); rep(i,1,n) scanf("%lf",&amp;p[i]); rep(i,1,n) scanf("%lf",&amp;u[i]); rep(i,1,n) pu[i] = 1.0 - (1.0 - p[i]) * (1.0 - u[i]); //O(n^3) dp // double ans = 1e-10; // for (int i = 1; i &lt;= n; ++i) &#123; // for (int j = 0; j &lt;= min(i,a); ++j) // for (int k = 0; k &lt;= b; ++k)&#123; // int lst = (i &amp; 1) ? 0 : 1; // upd(f[lst^1][j][k],f[lst][j][k]); // if (j &gt;= 1) upd(f[lst^1][j][k],f[lst][j-1][k] + p[i]); // if (k &gt;= 1) upd(f[lst^1][j][k],f[lst][j][k-1] + u[i]); // if (j &gt;= 1 &amp;&amp; k &gt;= 1) // upd(f[lst^1][j][k],f[lst][j-1][k-1] + 1.0 - (1.0 - p[i]) * (1.0 - u[i])); // if (i == n) upd(ans,f[lst^1][j][k]); // &#125; // &#125; double L = 0,R = 1,L1,R1; while(R - L &gt; eps) &#123; double mid1 = (L + R) / 2; L1 = 0,R1 = 1; while(R1 - L1 &gt; eps)&#123; double mid2 = (L1 + R1) / 2; Calc(mid1,mid2); if (numb[n] &gt; b) L1 = mid2; else R1 = mid2; &#125; Calc(mid1,R1); if (numa[n] &gt; a) L = mid1; else R = mid1; &#125; Calc(R,R1); double ans = f[n] + a * R + b * R1; printf("%.10lf\n",ans); return 0;&#125;/* Examples: *//**//**/ ÂèëÁé∞Ëá™Â∑±‰∏Ä‰∏áÂπ¥Ê≤°Êõ¥blog‰∫Ü.‰πãÂâçÁöÑÈ¢ò‰ºöÈôÜÈôÜÁª≠Áª≠Ë°•‰∏äÊù•Âêß.]]></content>
      <categories>
        <category>WQS‰∫åÂàÜ</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WQS‰∫åÂàÜ-Â≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2018%2F09%2F17%2FWQS%E4%BA%8C%E5%88%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Êç¢Âá†ÁßçÁß∞Âëº:ÊñúÁéáÂá∏‰ºòÂåñ Â∏¶ÊùÉ‰∫åÂàÜ ËøôÂá†‰∏™Êú¨Ë¥®‰∏äÂÖ∂ÂÆûÂπ∂Ê≤°Êúâ‰ªÄ‰πàÂå∫Âà´Âë¢. Ëß£ÂÜ≥ÈóÆÈ¢òÁöÑËåÉÁï¥Áªô‰∏Ä‰∏™ÈÄâÁâ©ÂìÅÁöÑÈôêÂà∂Êù°‰ª∂,Âú® $N$ ‰∏™Áâ©ÂìÅÈáåË¶ÅÊ±ÇÊÅ∞Â•ΩÈÄâ $K$ ‰∏™,ËÆ©‰Ω†ÊúÄÂ§ßÂåñ/ÊúÄÂ∞èÂåñÊùÉÂÄº. ‰∏îÂΩìÈÄâÊã©Áâ©ÂìÅÁöÑÊï∞ÈáèË∂äÂ§öÁöÑÊó∂ÂÄôÊùÉÂÄºË∂äÂ§ß/Ë∂äÂ∞è. ÂàÜÊûêÊôÆÈÄöÁöÑDPÂèØ‰ª•Âú®$O(nk*C)$ÁöÑÊó∂Èó¥ÂÜÖËß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò,ÂÖ∂‰∏≠ $C$ ÊòØËΩ¨ÁßªÁöÑÂ§çÊùÇÂ∫¶. ‰ΩÜÊòØË¶ÅÊòØÁ¢∞‰∏äÁã¨ÁïôÁöÑÂá∫È¢ò‰∫∫Âë¢. Ëøô‰∏™ $K$ ÁöÑÈôêÂà∂ÂçÅÂàÜÁöÑ‰ª§‰∫∫Â§¥Â§ß, ‰∏çÂ¶Ç‰∏çËÄÉËôëËøô‰∏™Áé©ÊÑè.‰πüÂ∞±ÊòØÂéªÊéâÁâ©ÂìÅ‰∏™Êï∞ÈôêÂà∂ $K$ . Êàë‰ª¨‰ª§Âèñ‰∏Ä‰∏™Áâ©ÂìÅÁöÑÈôÑÂä†ÊùÉÂÄº‰∏∫ $Cost$ ÈÇ£‰πàÊ†πÊçÆËß£ÂÜ≥ÈóÆÈ¢òÁöÑËåÉÁï¥ÈáåÈù¢ÁöÑÊÄßË¥®. ÂÅáËÆæÊàë‰ª¨ $Cost$ Ë∂äÂ§ß Êàë‰ª¨ÈÄâÊã©ÁöÑÁâ©ÂìÅ‰∏™Êï∞Èöè‰πãÂáèÂ∞ë/Â¢ûÂ§ß, ÊùÉÂÄº‰πüÈöè‰πãÂáèÂ∞ë/Â¢ûÂ§ß ÈÇ£‰πàÊàë‰ª¨Âú®ËΩ¨Áßª $DP$ ÁöÑÊó∂ÂÄôÂèØ‰ª•ËÄÉËôëËÆ∞ÂΩï‰∏ãÂèñÁâ©ÂìÅÁöÑ‰∏™Êï∞ Ê†πÊçÆÊòØÂê¶Â§ß‰∫é $K$ Êù•Ë∞ÉÊï¥ÊùÉÂÄº. ÊúÄÂêéÊãøÁ≠îÊ°àÂáèÊéâ $Cost$ ÁöÑÂΩ±ÂìçÂ∞±ÊòØÁ≠îÊ°à. ËøôÊ†∑ÁöÑÂ§çÊùÇÂ∫¶Â∞Ü $K$ Ëøô‰∏ÄÁª¥Áº©Êàê‰∫Ü $logCost$.ÂØπ‰∫é $K$ ÊØîËæÉÂ∞èÁöÑÊù•ËØ¥ ÂèØËÉΩ‰ºòÂåñÊïàÊûúÂπ∂‰∏çÊòéÊòæ. ÁÆóÊòØ‰∏™ÈªëÁßëÊäÄÂêß ‰ªäÂ§©‰πüÊòØÂÅ∂Â∞îÈÅáÂà∞‰∫ÜÊâçÂ≠¶‰∫ÜÂ≠¶Âë¢ Ê†óÂ≠êËßÅÊñ∞ÁöÑpostÂêß.]]></content>
      <categories>
        <category>WQS‰∫åÂàÜ</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FWT-FMTÂ≠êÈõÜÂèòÊç¢Âç∑ÁßØÂ≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2018%2F08%2F16%2FFWT-FMT%E5%AD%90%E9%9B%86%E5%8F%98%E6%8D%A2%E5%8D%B7%E7%A7%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Áªà‰∫éË¢´ËÆ∫ÊñáÈ¢òÂäùÈÄÄ‰πãÂêéÊù•Ë°•Ëøô‰∏™Âùë‰∫Ü ÂºïË®ÄË¢´HAOI2015Êåâ‰ΩçÊàñÂäùÈÄÄ ÊªöÂõûÂéªË°•vfkÁöÑËÆ∫Êñá so happy ÂèÇËßÅ2015ÂõΩÂÆ∂ÈòüËÆ∫Êñá„ÄäÈõÜÂêàÂπÇÁ∫ßÊï∞ÁöÑÊÄßË¥®‰∏éÂ∫îÁî®ÂèäÂÖ∂Âø´ÈÄüÁÆóÊ≥ï„Äã ÈõÜÂêàÂπÇÁ∫ßÊï∞ÂºïÂÖ•‰πãÂâçÂØπ‰∫éÊúâÂÖ≥ÈõÜÂêàÁöÑËÆ°Êï∞ÈóÆÈ¢ò ,‰∏ÄËà¨ÁöÑÂ∏∏ËßÑÊÄùË∑ØÊòØÁî® $f_S$ ÂéªË°®Á§∫ÊñπÊ°àÊï∞ÁÑ∂ÂêéÂéªÈÄíÊé®. ÁÑ∂ËÄåËøô‰∏™Êó∂ÂÄô‰Ω†Áúã‰∏ÄÁúºÈ¢òÈù¢ ÊÑèËØÜÂà∞Ëá™Â∑± $O(4^n)$ ÁîöËá≥ËøûÊö¥ÂäõÈÉΩ‰∏çÂ¶Ç Ôºà‰∏çÂØπ ËøôÂ∞±ÊòØÊö¥ÂäõÔºâ ‰∫éÊòØÊàë‰ª¨ÈúÄË¶Å‰∏Ä‰∏™‰∏úË•øÊù•‰ºòÂåñÈÄíÊé®ËΩ¨Áßª ËøòÊòØÁî®Êï∞ÂàóÁöÑÁêÜËÆ∫Êù•Á±ªÊØî.‰πãÂâçÂ§öÈ°πÂºèÁöÑ‰∏Ä‰∫õÁêÜËÆ∫ÊòØ‰∏çÊòØÂú®ÈõÜÂêà‰∏≠‰πüÂèØ‰ª•‰ΩøÁî®Âë¢? Êàë‰ª¨ÊõæÁªèÂØπ‰∫é‰∏Ä‰∏™Êï∞Âàó $f0,f_1‚Ä¶$ Áî®‰∏Ä‰∏™ÁîüÊàêÂáΩÊï∞Êù•ÊèèËø∞ Âç≥ $f(x) = \sum { k=0 } ^ { inf } f_k\times x^k$ Â∑¶ËæπÊòØ‰∏•Ê†ºÁöÑÊï∞ÂàóÈÄíÊé® Âè≥ËæπÊòØ‰ºòÁæéÁöÑÂ§öÈ°πÂºè ÊúâÊàêÂ•óÁöÑÂ∑•ÂÖ∑(ÊùøÂ≠ê)ÂéªËß£ÂÜ≥. ‰ΩÜÊòØÈõÜÂêàÁöÑÂ§ÑÁêÜÊÄé‰πàÂäû? ÂºïÂÖ•ÈõÜÂêàÂπÇÁ∫ßÊï∞ÁöÑÊ¶ÇÂøµ ÂÆö‰πâ‰ª§ $f‚Äã$ ÊòØÂÆö‰πâÂüüÂú®ÈõÜÂêà $U‚Äã$ ‰ª•ÂÜÖ,Êò†Â∞ÑÂà∞ $F‚Äã$ ÁöÑ‰∏Ä‰∏™ÈõÜÂêàÂπÇÁ∫ßÊï∞ , ÂØπ‰∫éÊØè‰∏Ä‰∏™ÂÆö‰πâÂüü‰∏≠ÁöÑ $S,S \in U‚Äã$,ËÆæ $f_S‚Äã$ ‰∏∫ËØ• $S‚Äã$ Â∏¶ÂÖ•ÂáΩÊï∞‰∏≠ÊâÄÂæóÂà∞ÁöÑÂÄº. ÁªìËÆ∫ Á°ÆÂÆö‰∫ÜÊØè‰∏Ä‰∏™ $S$ ÊâÄÂØπÂ∫îÁöÑ $f_S$ , $f$ ‰πüÂèØ‰ª•Èöè‰πãÁ°ÆÂÆö‰∏îÂîØ‰∏Ä. Êàë‰ª¨Áî®Á±ª‰ººÁîüÊàêÂáΩÊï∞ÁöÑÂÆö‰πâÊñπÂºèÁöÑÂºèÂ≠êÊù•ÂÆö‰πâ $f$ . $f = \sum _ { S \in U } f_S \times x ^ { S } $ ËøôÈáåÁöÑ $ f_S $ Âπ∂ÈùûÁ≥ªÊï∞ ËÄåÊòØ‰∏Ä‰∏™ $U$ ÁöÑÂ≠êÈõÜÊâÄÂØπÂ∫îÁöÑ‰∏Ä‰∏™ÁÇπÂÄº. ÊàëËøòÊòØ‰∏æËÆ∫Êñá‰∏äÁöÑ‰æãÂ≠êÂêß„ÄÇ„ÄÇ„ÄÇ $U={ 1,2 } , f(x) = 5x^{ \varnothing }$$+ 8x^ { { 1 } }$ $+$ $13x^ { { 1,2}}$ ÂàôËøô‰∏™ÈõÜÂêàÂπÇÁ∫ßÊï∞Èáå,$f({ 1,2 } ) = 13$,$f(\varnothing) = 5,f( { 1}) = 8$ ËÄÉËôëËøô‰∏™Áé©ÊÑèÁöÑËøêÁÆó. Âä†ÂáèÊ≥ïÊòæÁÑ∂Á≥ªÊï∞Áõ∏Âä†Áõ∏ÂáèÂç≥ÂèØ.‰ΩÜÊòØ‰πòÊ≥ïÂë¢ÔºüÊàë‰ª¨ÂØπ‰∫éÈõÜÂêàÁöÑËøêÁÆóÂèñÂπ∂Âèñ‰∫§ ÂæóÂà∞ÁöÑ‰ºº‰πéÂπ∂‰∏çÁõ∏ÂêåÂïä ÂºïÂá∫Â≠êÈõÜÂèòÊç¢ÈõÜÂêàÂç∑ÁßØ FMT(Fast Mobius Transform)Âø´ÈÄüËé´ÊØî‰πåÊñØÂèòÊç¢ÂèñÈõÜÂêàËøêÁÆó $L \subseteq U,R \subseteq U$Ôºå$L * R = L \cup R$ $f(x) = \sum { S \subseteq L} f_S x^S ,g(x) = \sum { S \subseteq R}g_S x^S$ ÂÆÉ‰ª¨ÁöÑÂç∑ÁßØ‰∏∫ $h(x) = \sum { L \subseteq U} \sum { R\subseteq U}f_Lg_R(L \cup R = S)$ BruteforceÊö¥ÂäõÊûö‰∏æÈõÜÂêà Â§çÊùÇÂ∫¶ $O(3^N)$ ÁæéÊªãÊªã Divide &amp; ConquerËÄÉËôëÂàÜÊ≤ª‰πò ÂØπ‰∫éÁé∞ÊúâÁöÑÈõÜÂêà $U = \ { 1,2,3,4,‚Ä¶n}$ ËÄÉËôë $ n $ ÂçïÁã¨ÊèêÂá∫Êù• ÂàÜÁ±ª. Áé∞Âú®ËÆ∞Âè∑ $F_1(x)$ Ë°®Á§∫Áé∞ÊúâÁöÑÈõÜÂêà‰∏≠‰∏çÂåÖÂê´ $n$ ÁöÑ $F_2(x)$ Ë°®Á§∫Áé∞ÊúâÁöÑÈõÜÂêà‰∏≠ÂåÖÂê´ $n$ ‰ΩÜÊòØË¶ÅÈô§ÂéªÁöÑ $f * g = (F_1+ { x_nF_2})(G_1+x_nG_2)$ ÁÑ∂ÂêéÂ±ïÂºÄÂàÜÊ≤ªÁÆóÂ∞±ÂèØ‰ª•‰∫Ü. $T(n) = T(n-1)+O(2^N)$ Áî±‰∏ªÂÆöÁêÜ $T(n) = O(N\times2^N)$ ÊçÆÁÇ∏È∏°Â∞èÂºüÂ£∞Áß∞ ÂàÜÊ≤ª‰πòÂæÄÂæÄË∑ëÁöÑÊØî$FMT$Âø´ ‰ΩÜ‰πüÂπ∂‰∏çÁü•ÈÅìÊòØ‰∏∫‰ªÄ‰πà‚Ä¶ Fast Mobius TransformËØÅÊòéÁúãËÆ∫Êñá ËøôÈáåÂè™ËÆ≤ÁªìËÆ∫ ÂÆö‰πâ‰∏Ä‰∏™ÂπÇÁ∫ßÊï∞ÁöÑËé´ÊØî‰πåÊñØÂèòÊç¢‰∏∫ $FS = \sum { T \subseteq S}f_T$ ÂèçËøáÊù• Êàë‰ª¨ÂÆö‰πâ $F$ ÁöÑËé´ÊØî‰πåÊñØÂèçÊºî‰∏∫ $f$ Êé®‰∏™ÂÆπÊñ•Èîô‰ΩçÁõ∏Âáè $fS = \sum { T \subseteq S} { (-1)^ { |S-T|}F_T}$ Êàë‰ª¨ÁÆóÂç∑ÁßØÁöÑÊó∂ÂÄô $h(x) = \sum { L \subseteq U} \sum { R\subseteq U}f_Lg_R(L \cup R = S)$ ‰∏§ËæπÂêåÊó∂ÂèçÊºî.ÊúÄÂêéÂèØ‰ª•ÂæóÂà∞ $H = F * G$ Âç≥ ÂèçÊºîÂêé‰æùÁÑ∂ÊàêÁ´ã ÊúÄÂêé‰∏§ËæπÂèçÊºîÂç≥ÂèØ . ËøôÊ†∑Êàë‰ª¨ÁÆóÂèë $ f,g$ ÁöÑÂç∑ÁßØ Âè™Ë¶ÅÂÖàËé´ÊØî‰πåÊñØÂèòÊç¢ ÁÑ∂ÂêéÁõ∏‰πò‰πãÂêé ÂÜçËé´ÊØî‰πåÊñØÂèçÊºî Â∞±ÂèØ‰ª•Âï¶ Â§çÊùÇÂ∫¶$O(N \times 2^N)$ Ê®°Êùø StupidOJ471234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p) &#123; int b=1;while(n) &#123; if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p) &#123; return quickpow(x,p-2,p);&#125;inline int read(void) &#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch)) &#123; f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch)) &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 2e6+100;int n,a[MAXN],b[MAXN],l = 0;void fmt(int a[],int len,int type) &#123; //type = -1 ÂèçÊºî for (int i = 0; i &lt; len; ++i) for (int j = 0; j &lt; (1 &lt;&lt; len) - 1; ++j) a[j] += type * a[(1&lt;&lt;i)^j] * (j &gt;&gt; i &amp; 1);&#125;///------------------head------------------signed main(signed argc, char *argv[]) &#123; n = read(); for (int i = 1; i &lt;= n; i = i &lt;&lt; 1, ++l); rep(i,0,n-1) a[i] = read(); rep(i,0,n-1) b[i] = read(); fmt(a,l,1); fmt(b,l,1); rep(i,0,n-1) a[i] = a[i] * b[i]; fmt(a,l,-1); rep(i,0,n-1) printf("%lld ",a[i]); return 0;&#125;/* Examples: *//**//**/ Fast Walsh-Hadamard TransformÊú¨Ë¥®‰∏äÂ∞±ÊòØÊØè‰∏Ä‰ΩçÂè™ÂèØËÉΩÊòØ $1,0$ ÁöÑÂ§öÈ°πÂºè ÊáíÂæóËØÅÊòéÊ≠£Á°ÆÊÄß‰∫Ü ‰ΩÜÊòØËøôÊòØÁ°ÆÂÆûÂ≠òÂú®ÁöÑ $FWT(A+B) = FWT(A) +FWT(B)$ $FWT(A \oplus B) = FWT(A) \times FWT(B)$ 12345678910111213141516171819202122void fwt_and(int *a,int type) &#123; for (int i = 2; i &lt;= n; i &lt;&lt;= 1) for (int p = (i &gt;&gt; 1) , j = 0; j &lt; n; j += i) for (int k = j; k &lt; j + p; ++k) a[k+p] += a[k] * type;&#125;void fwt_or(int *a,int type) &#123; for (int i = 2; i &lt;= n; i &lt;&lt;= 1) for (int p = (i &gt;&gt; 1), j = 0; j &lt; n; j += i) for (int k = j; k &lt; j + p; ++k) a[k] += a[k+p] * type;&#125;void fwt_xor(int *a,int type) &#123; //modÊÑè‰πâ‰∏ã for (int i = 2; i &lt;= n; i &lt;&lt;= 1) for (int p = (i &gt;&gt; 1), j = 0; j &lt; n; j += i) for (int k = j; k &lt; j + p; ++k) &#123; int x = (a[k] + a[k+p]),y = (a[k]-a[k+p]); a[k] = x; a[k+p] = y; &#125; int inv = getinv(quickpow(2,n,Mod),Mod); if (type == -1) for (int i = 0; i &lt; n; ++i) a[i] = a[i] * inv % Mod;&#125;]]></content>
      <categories>
        <category>FWT,FMT</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„Äåhihocoder1596„ÄçBeautiful Sequences]]></title>
    <url>%2F2018%2F08%2F16%2F%E3%80%8Chihocoder1596%E3%80%8DBeautiful-Sequences%2F</url>
    <content type="text"><![CDATA[Links there:hihocoder-1596 È¢òÊÑèÂØπ‰∫é‰∏Ä‰∏™Ê≠£Êï¥Êï∞Âàó $ a[1], ‚Ä¶ , a[n] (n ‚â• 3) $ÔºåÂ¶ÇÊûúÂØπ‰∫éÊâÄÊúâ $2 ‚â§ i ‚â§ n - 1$ ÔºåÈÉΩÊúâ $a[i-1] + a[i+1] ‚â• 2 √ó a[i]$ ÔºåÂàôÁß∞Ëøô‰∏™Êï∞ÂàóÊòØÁæé‰∏ΩÁöÑ„ÄÇ Áé∞Âú®Êúâ‰∏Ä‰∏™Ê≠£Êï¥Êï∞Âàó $b[1], ‚Ä¶, b[n]$ ÔºåËØ∑ËÆ°ÁÆó:Â∞Ü $b$ Êï∞ÂàóÂùáÂåÄÈöèÊú∫Êâì‰π±‰πãÂêéÔºåÂæóÂà∞ÁöÑÊï∞ÂàóÊòØÁæé‰∏ΩÁöÑÊ¶ÇÁéá $P$„ÄÇ ‰Ω†Âè™ÈúÄË¶ÅËæìÂá∫ $(P √ó (n!)) $ $ mod \space 1000000007$ Âç≥ÂèØ„ÄÇÔºàÊòæÁÑ∂ $P √ó (n!)$ ‰∏ÄÂÆöÊòØ‰∏™Êï¥Êï∞Ôºâ ÊÄùË∑ØÂ∞Ü${ a_i}$ËΩ¨Âåñ‰∏∫Áª¥Êä§‰∏Ä‰∏™Âá∏ÂáΩÊï∞ÁöÑÂõæÂÉè Áî®$f[i][j][k][t]$ Ë°®Á§∫ÂΩìÂâçÁ¨¨ $i$ ‰∏™,Â∑¶Á´ØÁÇπÊúÄÂ§ßÂÄºÂíåÊ¨°Â§ßÂÄº‰∏∫ $a[i],a[j]$ ,Âè≥Á´ØÁÇπÊúÄÂ§ßÂÄº‰∏∫ $a[k]$ , Ê¨°Â§ßÂÄº $a[t]$ ÁöÑÊñπÊ°à.Áî±‰∫éÂ∑≤ÁªèÊéíËøáÂ∫è,Êñ∞Âä†ËøõÊù•ÁöÑ $Â•ë$ ‰∏ÄÂÆöÊØîÂΩìÂâçÂ∑¶Âè≥Á´ØÁÇπÁöÑÈÉΩË¶ÅÂ§ß. ÈÇ£‰πàÊúâ‰∏§ÁßçÊÉÖÂÜµ,Ë¶Å‰πàÂú®Â∑¶ËæπÊàêÁ´ã Ë¶Å‰πàÂú®Âè≥ËæπÊàêÁ´ã. f[i][j][k][t] =>f[i+1][i][k][t] \space (a[i+1] + a[j]\geq 2 \times a[i]) \\\\ f[i][j][k][t] =>f[i][j][i+1][k] \space (a[i+1] + a[t] \geq 2 \times a[k])ËøôÁ¨¨‰∫å‰∏™ÊüøÂ≠êÊúâ‰∏ÄÁÇπÂ•áÊÄ™ ‰ΩÜÊòØÂõ†‰∏∫Â∑¶ËæπÁ´ØÁÇπÂÖ∂ÂÆûÊòØÂíåÂè≥ËæπÁ´ØÁÇπÁ≠â‰ª∑ÁöÑ. ÊâÄ‰ª•ÂèØ‰ª•Â∞Ü‰∏äÈù¢Á¨¨‰∫å‰∏™ÂÜôÊàêËøôÊ†∑ f[i][j][k][t] =>f[i+1][k][i][j] \space (a[i+1] + a[t] \geq 2 \times a[k])Ê≥®ÊÑèÁªÜËäÇÂ∞ÜÊâÄÊúâÊúÄÂ∞èÁöÑËÆ°Êï∞ ÁÑ∂ÂêéÁ≠îÊ°àÂéª‰πòÂÆÉÁöÑÈò∂‰πò. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int n,b[61],f[61][61][61][61],ans = 1;const int Mod = 1e9+7;inline bool isok(int a,int x,int y)&#123; return (2*b[x] &lt;= b[a] + b[y]);&#125;inline void upd(int &amp;x,int y)&#123;x=(x+y)%Mod;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; // freopen("data.in","r",stdin); // freopen("data.ans","w",stdout); n=read(); rep(i,1,n) b[i]=read(); sort(b+1,b+n+1); int ll = b[1],l = 0; rep(i,1,n) &#123;if (ll == b[i]) ++l,ans = ans * i % Mod;&#125; if (l == n) &#123; printf("%lld\n",ans); return 0; &#125; cerr &lt;&lt; ans &lt;&lt; endl; f[l][l][l][l] = 1; for (int i = l; i &lt;= n - 1; ++i) for (int j = 1; j &lt;= i; ++j) for (int k = 1; k &lt;= i; ++k) for (int t = 1; t &lt;= i; ++t) &#123; if (!f[i][j][k][t]) continue; int del = f[i][j][k][t]; upd(f[i+1][i][k][t],del * isok(i+1,i,j)); upd(f[i+1][k][i][j],del * isok(i+1,k,t)); &#125; int ans2 = 0; for (int j = 1; j &lt;= n; ++j) for (int k = 1; k &lt;= n; ++k) for (int t = 1; t &lt;= n; ++t) upd(ans2,f[n][j][k][t]); ans2 = ans2 * ans % Mod; printf("%lld\n",ans2); return 0;&#125;/* Examples: *//**//**/]]></content>
      <categories>
        <category>DP-ÊúüÊúõDP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåHDU5823„Äç2016Â§öÊ†°ËÅîÂêàRound8 Color II Áä∂Âéã]]></title>
    <url>%2F2018%2F08%2F16%2F%E3%80%8CHDU5823%E3%80%8D2016%E5%A4%9A%E6%A0%A1%E8%81%94%E5%90%88Round8-Color-II-%E7%8A%B6%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[Links there:HDU5823 È¢òÊÑèÊ±Ç‰∏Ä‰∏™ÂõæÁöÑÊØè‰∏Ä‰∏™Â≠êÂõæÁöÑÊúÄÂ∞èÊüìËâ≤Êï∞. ÁÇπÈõÜÂ§ßÂ∞è $N \leq 18$ ÊÄùË∑ØÊö¥ÂäõÊûö‰∏æÂ≠êÈõÜÁöÑÂ§çÊùÇÂ∫¶ÊòØ $O(3^n)$ ,Á≠âÁ≠â! ‰ºº‰πé $3^{18} = 387420489$ ÂèØËÉΩÂ∏∏Êï∞‰ºòÁßÄÂèØ‰ª•ËøáÔºü Êàë‰ª¨ÂÖàÊûö‰∏æÂ≠êÂõæ ÂÜçÊûö‰∏æÂ≠êÈõÜ ÊòØÁã¨Á´ãÈõÜÂêà Ê∂Ç‰∏Ä‰∏™È¢úËâ≤ ÁÑ∂ÂêéÂ∞ÜËøô‰∏™Â≠êÈõÜÂâ©‰∏ãÁöÑÁä∂ÊÄÅËΩ¨ÁßªÂá∫Êù• $f[S] = min(f[S],f[SË°•]+1)$ ‰∫§‰∫Ü‰∏ÄÂèë Â±ÖÁÑ∂Ëøá‰∫Ü! ÂÖ∂ÂÆûÂà©Áî®Âø´ÈÄüÊ≤ÉÂ∞î‰ªÄÂèòÂåñÂèØ‰ª•‰ºòÂåñÂà∞ $O(2^N \times N^2)$ ÂÖ∑‰ΩìÂèØ‰ª•ÁúãËøôÈáåLink Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int unsignedinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int msk,t,n;char s[19][19];int res[1&lt;&lt;18],valid[1&lt;&lt;18];///------------------head------------------signed main(signed argc, char *argv[])&#123; t=read(); while(t--)&#123; n=read(); for (int i = 1; i &lt;= n; ++i) scanf("%s",s[i]+1); MM(valid,1); MM(res,0x3F); msk = (1 &lt;&lt; n) - 1; for (int i = 1; i &lt;= msk; ++i)&#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i&gt;&gt;(j-1)&amp;1) for (int k = 1; k &lt;= n; ++k) if ((i&gt;&gt;(k-1)&amp;1) &amp;&amp; s[j][k] == '1') &#123;valid[i] = 0; break;&#125; if (!valid[i]) break; &#125; &#125; res[0] = 0; for (int i = 1; i &lt;= msk; ++i) for (int S = i; S; S = (S-1)&amp;i) if (valid[S]) res[i] = min(res[i],res[S^i] + 1); int mul = 1,ans = 0; for (int i = 1; i &lt;= msk; ++i) mul = mul * 233, ans += res[i] * mul; printf("%u\n",ans); &#125; return 0;&#125;/* Examples: *//**//**/]]></content>
      <categories>
        <category>DP-Áä∂ÂéãDP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåCTSC2018„ÄçÂÅáÈù¢(faceless) Ê¶ÇÁéá‰∏éÊúüÊúõdp ÈÄíÊé® 01ËÉåÂåÖËøòÂéü]]></title>
    <url>%2F2018%2F08%2F16%2F%E3%80%8CCTSC2018%E3%80%8D%E5%81%87%E9%9D%A2-faceless-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9Bdp-%E9%80%92%E6%8E%A8-01%E8%83%8C%E5%8C%85%E8%BF%98%E5%8E%9F%2F</url>
    <content type="text"><![CDATA[Links there:CTSC2018ÂÅáÈù¢ È¢òÊÑèÊúâ $N$ ‰∏™Êïå‰∫∫,ÊØè‰∏™Êïå‰∫∫ÁöÑË°ÄÊù°‰∏∫ $hp_i$ ,ÈíàÈíà‰ºö‰∏¢ $Q$ ‰∏™ÊäÄËÉΩ. ÊäÄËÉΩ1:ÊåáÂÆö‰∏Ä‰∏™ÊïåÊñπÂçï‰Ωç $id$ ,ÁªôÂá∫ $u,v$ ,Ë°®Á§∫Êúâ $\frac{u}{v}$ ÁöÑÊ¶ÇÁéáÂëΩ‰∏≠Ëøô‰∏™Âçï‰ΩçÂπ∂ÈÄ†Êàê1ÁöÑ‰º§ÂÆ≥. ÊäÄËÉΩ2:ÁªôÂá∫‰∏Ä‰∏™Êïå‰∫∫ÁöÑÈõÜÂêà ${ id_i }$ ,Â§ßÂ∞è‰∏∫ $k$ ,Ê±ÇÊØè‰∏Ä‰∏™ $id_i$ ÁöÑÂ≠òÊ¥ªÊúüÊúõ. ÊúÄÂêéËøòË¶ÅÊ±ÇÂá∫ÊØè‰∏™Êïå‰∫∫ÁöÑË°ÄÈáèÂâ©‰ΩôÁöÑÊúüÊúõ. (ËØ≠ÊñáÊ∞¥Âπ≥‰Ωé‰∏ãËøòÊÅ≥ËØ∑ÁúãÂéüÈ¢òÈù¢) ÊÄùË∑ØËÄÉËôëÁî® $a[i][j]$ Ë°®Á§∫Á¨¨ $i$ ‰∏™Êïå‰∫∫Ââ©‰∏ã $j$ ÁöÑË°ÄÈáèÁöÑÊúüÊúõ. Êàë‰ª¨ÂØπ‰∫éÊØè‰∏ÄÊ¨°ÊäÄËÉΩ $1$ ÊòØÂèØ‰ª•Âú® $O(hp[id])$ ÂÜÖÁª¥Êä§Âá∫Ëøô‰∏™ $a[id][j]$ ÁöÑ,‰∏çÈöæÁêÜËß£. ÂÖ∑‰ΩìÂ¶Ç‰∏ã $a[id][0] = a[id][0] + a[id][1] * p$ (Â∑≤ÁªèÊåÇ‰∫ÜÂä†‰∏äÂè™Ââ©‰∏ã1Êª¥Ë°ÄÁöÑËøôÊ¨°ÊåÇÊéâÁöÑ) $a[id][i] = (a[id][i] (1-p) + a[id][i+1] p)$ (ÊâìÂæóÂà∞‰∏éÊâì‰∏çÂà∞) Áî® $f[i][j]$ Ë°®Á§∫Ââç $i$ ‰∏™Êïå‰∫∫Êúâ $j$ ‰∏™Â≠òÊ¥ªÁöÑÊúüÊúõ. Áî® $exist[i]$ Ë°®Á§∫ÊäÄËÉΩ2‰∏≠ÈõÜÂêàÁ¨¨ $i$ ‰∏™ÁöÑÂ≠òÊ¥ªÊúüÊúõ Áî® $dead[i]$ Ë°®Á§∫ÊäÄËÉΩ2‰∏≠ÈõÜÂêàÁ¨¨ $i$ ‰∏™ÁöÑÊ≠ª‰∫°ÊúüÊúõ ÈÇ£‰πàÂØπ‰∫éÊØè‰∏Ä‰∏™ÊäÄËÉΩ $2$ Êú¨Ë¥®‰∏äÊòØ‰∏ÄÊ¨°ËØ¢ÈóÆÊìç‰Ωú. ÈÄöËøáËÄÉËôëÁ¨¨ $i$ ‰∏™Êïå‰∫∫ÁöÑÂ≠òÊ¥ª‰∏éÂê¶ ‰∏çÈöæÊúâ‰ª•‰∏ãÁöÑËΩ¨Áßª f[i][0] = f[i-1][0] * dead[i]\\\\ f[i][j] = (f[i-1][j-1] * exist[i] + f[i-1][j] * dead[i])ËøôÊ†∑ÁöÑËØùÊàë‰ª¨ÂèØ‰ª•ÂØπ‰∫éÊØè‰∏Ä‰∏™ÈõÜÂêà‰∏≠ÁöÑÂÖÉÁ¥† ÈÉΩËøô‰πàÊö¥ÂäõË∑ë‰∏ÄÈÅçÂ∞±ÂèØ‰ª•ÂæóÂà∞ÊØè‰∏™ÁöÑÊúüÊúõ. Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ $O(Cn^3 + Qm)$ , $m$ ‰∏∫ÊúÄÂ§ß$hp$ÂÄº. Âè™ÊãøÂà∞ $70pts$ ËÄÉËôë‰ºòÂåñ ÊØè‰∏ÄÊ¨°Êàë‰ª¨ÈÉΩÊö¥ÂäõÈáçÊñ∞ËΩ¨Áßª ÊòæÁÑ∂ÂæàÂ§öÁä∂ÊÄÅÈÉΩË¢´Êµ™Ë¥π‰∫Ü ËÄÉËôëÈÄÜËΩ¨Áßª f[i][j] = (f[i-1][j-1] * exist[i] + f[i-1][j] * dead[i])‰ª§$f[i][j] = f‚Äô[j]$ Ë°®Á§∫Ë¶ÅËΩ¨ÁßªÂà∞ÁöÑÁä∂ÊÄÅ. $f‚Äô[j]$ Áî± $f[j-1],f[j]$ ËΩ¨ÁßªËÄåÊù• f'[j] = (f[j-1] * exist[i] + f[j] * dead[i])ÊääÂÆÉÊîπÂÜôËøáÊù•Â∞±ÊòØ f[j] = \frac{f'[j] - f[j-1]*exist[i]}{dead[i]}ËøôÊ†∑ÊØèÊ¨°Êàë‰ª¨Â∞±ÂèØ‰ª•‰∏çÈúÄË¶ÅÊö¥ÂäõÈáçÁΩÆÁä∂ÊÄÅÂï¶ÔºÅËøôÊ†∑Â∞±ÂèØ‰ª•‰ºòÂåñÊàê$O(Cn^2+Qm)$ ÂùëÁÇπ Ê≥®ÊÑèÊ±ÇÈÄÜÂÖÉ‰∏çË¶ÅÊØèÊ¨°ÈÉΩÂú®ÂÅöÁöÑÊó∂ÂÄôgetinv(x,Mod)ËøôÊ†∑Â§çÊùÇÂ∫¶Â§ö‰∫Ü‰∏Ä‰∏™log(Mod) ËôΩÁÑ∂Ëøá‰∫ÜÈ¢ò‰ΩÜÊòØËøòÊòØË¶ÅÂ∞èÂøÉÂïä È¢ÑÂ§ÑÁêÜÁ∫øÊé®ÈÄÜÂÖÉ. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int Mod = 998244353;const int MAXN = 210;int n,hp[MAXN],f[MAXN][MAXN],g[MAXN],t[MAXN],Inv[MAXN], inv[MAXN],m,exist[MAXN],a[MAXN][MAXN],dead[MAXN], ans[MAXN];///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(); Inv[1] = 1; for (int i = 2; i &lt;= 200; ++i) Inv[i] = (Mod - Mod/i) * (Inv[Mod % i]) % Mod; for (int i = 1; i &lt;= n; ++i) hp[i] = read(),a[i][hp[i]] = 1; m=read(); for (int op = 1; op &lt;= m; ++op)&#123; int opt = read(); if (opt) &#123; int k = read(); rep(i,1,k) t[i] = read(); rep(i,1,k) exist[i] = (1-a[t[i]][0]+Mod) % Mod; rep(i,1,k) dead[i] = (1-exist[i]+Mod) % Mod; f[0][0] = 1; rep(i,1,n) &#123; f[i][0] = f[i-1][0] * dead[i] % Mod; rep(j,1,i) f[i][j] = (f[i-1][j-1] * exist[i] % Mod + f[i-1][j] * dead[i] % Mod) % Mod; &#125; rep(i,1,k) ans[i] = 0; rep(i,1,k) &#123; if (exist[i]) &#123; if (exist[i] == 1) &#123; for (int j = 1; j &lt;= k; ++j) g[j-1] = f[k][j]; &#125; else &#123; int ded = getinv(dead[i],Mod); g[0] = f[k][0] * ded % Mod; for (int j = 1; j &lt;= k; ++j) g[j] = (f[k][j] - exist[i] * g[j-1] % Mod + Mod) * ded % Mod; &#125; for (int j = 1; j &lt;= k; ++j) ans[i] = (ans[i] + exist[i] * g[j-1] % Mod * Inv[j] % Mod) % Mod; &#125; &#125; for (int i = 1; i &lt;= k; ++i) printf("%lld ",ans[i]); puts(""); &#125; else&#123; int id = read(),u = read(),v = read(),p = u * getinv(v,Mod) % Mod; a[id][0] = (a[id][0] + a[id][1] * p % Mod) % Mod; for (int i = 1; i &lt;= hp[id]; ++i) a[id][i] = (a[id][i] * (1-p+Mod) % Mod + a[id][i+1] * p % Mod) % Mod; &#125; &#125; for (int i = 1; i &lt;= n; ++i) ans[i] = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= hp[i]; ++j) ans[i] = (ans[i] + a[i][j] * j % Mod) % Mod; for (int i = 1; i &lt;= n; ++i) printf("%lld ",ans[i]); return 0;&#125;/* Examples: *//*31 2 360 2 1 11 1 20 2 1 10 3 1 11 1 21 3 1 2 3*//*10499122177 0 4991221771 0 2*/]]></content>
      <categories>
        <category>DP-ÊúüÊúõDP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Suffix Automaton ÂêéÁºÄËá™Âä®Êú∫Â≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2018%2F08%2F09%2FSuffix-Automaton-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ÂêéÁºÄËá™Âä®Êú∫ Suffix Automaton (SAM) ÂÆö‰πâÂêéÁºÄËá™Âä®Êú∫ÔºåÊú¨Ë¥®‰∏äÊòØÂÖ≥‰∫éÂçïËØçÁöÑÊúâÂêëÊó†ÁéØÂõæÔºåÊòØ‰∏ÄÁßçÂº∫ÊúâÂäõÁöÑÊï∞ÊçÆÁªìÊûÑÔºåÂèØ‰ª•Âú®$O(n)$ÁöÑÊó∂Èó¥ÂÜÖÊûÑÈÄ†ÂÆåÊàêÂπ∂ËæÖÂä©Ëß£ÂÜ≥ÂæàÂ§öÂ≠óÁ¨¶‰∏≤ÈóÆÈ¢ò„ÄÇÂÆÉ‰πüÂèØ‰ª•Ë¢´ÁêÜËß£‰∏∫‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫$N$ÁöÑÂ≠óÁ¨¶‰∏≤ÁöÑÂéãÁº©‰πãÂêéÂ≠òËµ∑Êù•ÁöÑ‰ø°ÊÅØ„ÄÇ ÂêéÁºÄËá™Âä®Êú∫ÊòØÈôàËÄÅÂ∏àWJMZBMRÈ¶ñÊ¨°ÂºïËøõÂõΩÂÜÖOIÂúàÁöÑÔºåÈôàËÄÅÂ∏àÁöÑËÆ∫ÊñáÂÖ®ÊòØÂπ≤Ë¥ß„ÄÇ ÊÄßË¥®‰∏Ä‰∫õËØ¥Êòé$Status(str)$Ë°®Á§∫$trans(init,str)$ $Reg(s)$Ë°®Á§∫‰ªéÁä∂ÊÄÅ$s$ÂºÄÂßãÂèØ‰ª•ËØÜÂà´ÁöÑ$string$(ÂêéÁºÄÈõÜÂêà) ‰∏ãÈù¢Ëøô‰∏ÄÊÆµÊòØÂÖ≥‰∫é$Reg(s)$ÁöÑËß£Èáä ‰ªÄ‰πàÊòØ$Reg(s)$? Â•ΩÈóÆÈ¢ò!‰∏æ‰∏™‰æãÂ≠ê: ÂÅáËÆæÁé∞Âú®Êúâ‰∏Ä‰∏™‰∏≤$S = ‚ÄúABCABCBD‚Äù$ ÂØπ‰∫éË¶ÅÂú®$S$‰∏≠ÂØªÊâæÁöÑ‰∏Ä‰∏™Â≠ê‰∏≤$S‚Äô = ‚ÄúBC‚Äù$ ÂæàÊòéÊòæÂá∫Áé∞‰ΩçÁΩÆÁöÑÈõÜÂêà‰∏∫${ (2,3),(5,6)}$ ‰ªñÂá∫Áé∞ÁöÑÂêéÁºÄÈõÜÂêà‰∏∫${ suffix(3), suffix(6)}$ ÂØπ‰∫é‰∏Ä‰∏™$string \space a$ Reg(Status(a)) = \{ suffix(r_1),suffix(r_2) ... suffix(r_n)\}ÂæàÊòéÊòæ Êàë‰ª¨Âè™Ë¶ÅÂ≠ò‰∏ã‰∫Ü${r1,r2,‚Ä¶,rn}$ Â∞±ÂèØ‰ª•Á°ÆÂÆöËøô‰∏™$Reg(Status(a))$ ‰∏çÂ¶®Áî®‰∏Ä‰∏™ÈõÜÂêà$Right(a)$Êù•ËÆ∞ÂΩïËøô‰∏Ä‰ø°ÊÅØ ÊÄßË¥®1 ÂØπ‰∫é‰∏§‰∏™Â≠ê‰∏≤$a,b$,Â¶ÇÊûú$Right(a) = Right(b)$ÈÇ£‰πà$Status(a) = Status(b)$ ÊÄßË¥®2 ‰∏Ä‰∏™Áä∂ÊÄÅ$s$Ë°®Á§∫ÁöÑÊâÄÊúâÂ≠ê‰∏≤$Right$ÈõÜÂêàÁõ∏Âêå,‰∏∫$Right(s)$. ÊâÄ‰ª•ËØ¥ÁªôÂÆö‰∫Ü‰∏Ä‰∏™$Right(s)$‰ª•ÂèäÂ≠ê‰∏≤ÁöÑÈïøÂ∫¶ Êàë‰ª¨Â∞±ÂèØ‰ª•ÂîØ‰∏ÄÁ°ÆÂÆöËøô‰∏™Â≠ê‰∏≤$s$. ÊÄßË¥®3 ‰∏Ä‰∏™$Right$ÈõÜÂêàÂíå‰∏Ä‰∏™ÈïøÂ∫¶ÂÆö‰πâ‰∫Ü‰∏Ä‰∏™Â≠ê‰∏≤„ÄÇ ÊÄßË¥®4 ÂØπ‰∫éÁä∂ÊÄÅ$s$Ôºå‰ΩøÂæó$Right(s)$ÂêàÊ≥ïÁöÑÂ≠ê‰∏≤ÈïøÂ∫¶ÊòØ‰∏Ä‰∏™Âå∫Èó¥Ôºå‰∏çÂ¶®ÂÆö‰πâ‰∏∫$[Min(s),Max(s)]$ ÊÄßË¥®5 $Right$ÈõÜÂêàÁöÑÂåÖÂê´ÂÖ≥Á≥ªÂΩ¢ÊàêÁöÑÊ†ëÂΩ¢ÁªìÊûÑÂè´ÂÅö Parent Tree ÂÖ∂‰ªñÊñáÁåÆ‰∏≠Âè´ÂÅö$Suffix Link$Ëøô‰∏™ËæπÊòØ‰ªéÂ≠©Â≠êÊåáÂêëÁà∂‰∫≤ÁöÑÔºåÂíåACËá™Âä®Êú∫ÁöÑFail TreeÊúâÁÇπÂÉè ÊÄßË¥®6 ParentÊ†ë‰ªé‰∏äÂæÄ‰∏ãRightÈõÜÂêàÂèòÂ∞èÔºåÂ≠ê‰∏≤ÈïøÂ∫¶ÂèòÈïø Parent TreeÁöÑÂè∂Â≠êËäÇÁÇπÊï∞$O(N)$ÔºåÊØè‰∏™ÂÜÖÈÉ®ËäÇÁÇπËá≥Â∞ë‰∏§‰∏™Â≠©Â≠êÔºåÊâÄ‰ª•ÊÄªÁªìÁÇπÊï∞$O(N) $ Â∑Æ‰∏çÂ§öËøô‰∫õÂ∞±Â∑≤ÁªèÂ§ü‰∫ÜÔºü ‰∏Ä‰∫õÊé®ËÆ∫ ÂèØ‰ª•ËØÅÊòéÔºåÂú®SAM‰∏≠ËäÇÁÇπÊï∞‰∏çË∂ÖËøá$2n‚àí2$ÔºåËæπÊï∞‰∏çË∂ÖËøá$3n‚àí3$ÔºàÂåÖÊã¨ËΩ¨ÁßªËæπÂíåParent TreeÁöÑËæπÔºâ ÊÄßË¥®7$Suffix Link$‰ªéÁà∂‰∫≤ÊåáÂêëÂÑøÂ≠êÂêéÂ∞±ÊòØ$Reverse(s)$ ÁöÑ$Suffix Tree$ ÂèçÂêëÂ≠óÁ¨¶‰∏≤ÁöÑÂêéÁºÄÊ†ëÔºÅÂêéÁºÄÊ†ëÊòØ‰∏ÄÈ¢óÁªèËøáÂéãÁº©ÁöÑÂ≠óÂÖ∏Ê†ë ÊÄßË¥®8 (ÊÑüËßâËøô‰∏™Â•ΩÁ•ûÂïä) ‰∏§‰∏™‰∏≤ÁöÑÊúÄÈïøÂÖ¨ÂÖ±ÂêéÁºÄ,‰Ωç‰∫éËøô‰∏§‰∏™‰∏≤ÂØπÂ∫îÁä∂ÊÄÅÂú®$Parent$Ê†ë‰∏äÁöÑÊúÄËøëÂÖ¨ÂÖ±Á•ñÂÖàÁä∂ÊÄÅ ÂÖ∂‰ªñËøòÊúâ‰∏Ä‰∫õÂèØ‰ª•ÂèëÊéòÂïä ÊØîÂ¶Ç$Max$Âíå$Min$ÁöÑÂÖ≥Á≥ª‰ªÄ‰πàÁöÑ‚Ä¶ Âª∫Á´ãSAM$SAM$ÈááÁî®ÁöÑÊòØÂú®Á∫øÈÄê‰∏™Âä†ÂÖ•Â≠óÁ¨¶ÁöÑÊñπÊ≥ï ÁÆÄÂçïÊù•ËØ¥ÂàÜËøôÂá†‰∏™Èò∂ÊÆµ ÂÅáËÆæÂΩìÂâç$T$ÁöÑ‰∏≤ÈïøÂ∫¶‰∏∫$L$,Áé∞Âú®Êñ∞Âä†ÂÖ•‰∏Ä‰∏™$x$ $p = Status(T),Right(p) = L$ Êñ∞Âª∫‰∏Ä‰∏™$np = ST(T+x)$(Âä†Ê≥ï‰∏∫Â≠óÁ¨¶‰∏≤ÁöÑÂä†Ê≥ï) ÈÇ£‰πà$p$ÁöÑ$Parent$Á•ñÂÖàÁöÑ$Right$ÈõÜÂêàÈáåÈÉΩÊúâ$L$ Âêë‰∏äÊõ¥Êñ∞$trans(v,x)$,‰πüÂ∞±ÊòØÊ≤°ÊúâÂ≠óÁ¨¶$x$ÁöÑÁ•ñÂÖàÈÉΩÈúÄË¶ÅÊõ¥Êñ∞,‰ªéËøô‰∏™Áä∂ÊÄÅ$last$Ë¶ÅÂêëÂΩìÂâçÊñ∞Áä∂ÊÄÅ$np$Ê∑ªÂä†ËΩ¨Áßª ‰πüÂ∞±ÊòØ$trans[last].ch[x] = np$ ÂàÜÁ±ªËÆ®ËÆ∫ÊúÄÂêéÁ•ñÂÖàÁöÑÊÉÖÂÜµ (1)Â¶ÇÊûúÊúÄÂêéÊü•ÊâæÂà∞‰∫Ü$root$,‰πüÂ∞±ÊòØÊ†πËäÇÁÇπ Êàë‰ª¨Áõ¥Êé•Â∞ÜÂÆÉÁöÑ$Parent$ËæπËøûÂêë$root$ (2)ÊâæÂà∞Á¨¨‰∏Ä‰∏™ÊúâÁöÑÁ•ñÂÖà‰∏∫$p$,‰ª§$q = trans[p].ch[x]$ ÂÜçÂàÜÁ±ª‰∏ÄÊ≥¢ ‚Äã (i)Â¶ÇÊûúËØ¥Êª°Ë∂≥‰∫Ü$t[q].val=t[p].val+1$ ËØ¥ÊòéÂº∫Ë°åÂä†ÂÖ•Ëøô‰∏™$L+1$‰∏ç‰ºö‰ΩøÂæó$Max(q)$ÂáèÂ∞è Áõ¥Êé•ËøûËæπ ‚Äã (ii)‰∏çÊª°Ë∂≥ Êàë‰ª¨ËÄÉËôëÊñ∞Âª∫‰∏Ä‰∏™ËäÇÁÇπ$nq$,$nq$Êú¨Ë¥®‰∏äÈô§‰∫Ü$Max$‰∏çÂêå,ÂÖ∂‰ªñ‰ø°ÊÅØÂùáÁõ∏Âêå,Â∞Ü$np$,$q$ÁöÑ$parent$ÂùáËøûÂêë$nq$ ‰ª£Á†ÅÂÆûÁé∞ËøòÊòØÊØîËæÉÂèØËØªÁöÑÂêß‚Ä¶ Code12345678910111213141516171819202122232425262728293031struct Sam&#123; struct node&#123; int ch[26],par,val; //par -&gt; parent | val -&gt; Max &#125;t[N]; int c[N],a[N],siz[N]; //Ëøô‰∏ÄË°åËæÖÂä©Êï∞ÁªÑ int sz,root,last; inline void init(void)&#123;sz=root=last=1;&#125; //ÂÆö‰πâÊ†πËäÇÁÇπ‰∏∫1 inline void ins(int x)&#123; int p=last,np=++sz;//Êñ∞Âª∫‰∏Ä‰∏™ËäÇÁÇπ t[np].val=t[p].val+1;//ÈïøÂ∫¶‰∏∫‰∏ä‰∏Ä‰∏™ËäÇÁÇπÈïøÂ∫¶+1 for(;p&amp;&amp;!t[p].ch[x];p=t[p].par) t[p].ch[x]=np;//Âêë‰∏äÁ•ñÂÖàÊõ¥Êîπch[x] if(!p) t[np].par=root;//Â¶ÇÊûúÊúÄÁªà‰∏∫Ê†πËäÇÁÇπÁõ¥Êé•Â∞ÜparentËæπËøûÂêëroot else&#123;//ÂàÜÁ±ªËÆ®ËÆ∫ int q=t[p].ch[x]; if(t[q].val==t[p].val+1) t[np].par=q;//Êª°Ë∂≥Max(q) = Max(p) + 1 else&#123; int nq=++sz;//Êñ∞Âª∫nqËäÇÁÇπ t[nq]=t[q];//Êã∑Ë¥ùËäÇÁÇπqÁöÑ‰ø°ÊÅØ t[nq].val=t[p].val+1;//nqÂíåpÂîØ‰∏ÄÁöÑ‰∏çÂêåMax t[q].par=t[np].par=nq;//‰πüÊòØÊã∑Ë¥ù‰ø°ÊÅØ for(;p&amp;&amp;t[p].ch[x]==q;p=t[p].par) t[p].ch[x]=nq;//Êã∑Ë¥ù‰ø°ÊÅØ &#125; &#125; last=np; &#125; inline void calc(void)&#123; //ÂÅöÂÖ∂‰ªñ‰∫ãÁöÑÊó∂ÂÄôÂèØËÉΩ‰ºöÁî® for (int i = 1; i &lt;= sz; ++i) c[t[i].val]++; for (int i = 1; i &lt;= sz; ++i) c[i] += c[i-1]; for (int i = 1; i &lt;= sz; ++i) a[--c[t[i].val]] = i; //ËøôÈáåÊòØÂü∫Êï∞ÊéíÂ∫èÂØπparentËæπ‰ΩúÊãìÊâë &#125;&#125;sam; È¢òÂçïspoj8222 ÂêéÁºÄËá™Âä®Êú∫Ê®°Êùø(spoj8222) BZOJ3998 Á¨¨KÂ§ßÂ≠ê‰∏≤ÔºåÁª¥Êä§valÂíåsum NOI2015ÂìÅÈÖíÂ§ß‰ºö Áî®ÂêéÁºÄËá™Âä®Êú∫Âª∫Âá∫ÂêéÁºÄÊ†ëÔºåÁÑ∂ÂêéÂ∞±ÂèòÊàê‰∫ÜÂêéÁºÄÊ†ëË£∏È¢ò BZOJ4545 ÂêéÁºÄËá™Âä®Êú∫+ÊúâÂêëLCT]]></content>
      <categories>
        <category>Â≠óÁ¨¶‰∏≤</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåCF743D„ÄçChloe and pleasant prizes]]></title>
    <url>%2F2018%2F07%2F22%2F%E3%80%8CCF743D%E3%80%8DChloe-and-pleasant-prizes%2F</url>
    <content type="text"><![CDATA[Links there:CF734D È¢òÊÑèÊ±ÇÊúÄÂ§ßÁöÑ‰∏§Â≠êÊ†ëÊùÉÂÄº‰πãÂíå,Ë¶ÅÊ±ÇÂ≠êÊ†ëÊ≤°Êúâ‰∫§ÈõÜ ÊÄùË∑ØÁúü¬∑ÊñØÊ≥¢È¢ò,Áõ¥Êé•ÁªüËÆ°ÊúÄÂ§ßÂ≠êÊ†ëÂíåÊ¨°Â§ßÂ≠êÊ†ëÂç≥ÂèØ. ÁâπÂà§‰∏ÄÊù°ÈìæÁöÑÊÉÖÂÜµ ÊòØ‰∏çÂèØËÉΩÊúâÁ≠îÊ°àÁöÑ. ÊÅ∂ÂøÉÁöÑinfÂºÑÊàëÂçäÂ§© Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 2e5+100;const int inf = 0x3f3f3f3f3f3f3f3fLL;int n,w[MAXN],fa[MAXN],dp[MAXN],head[MAXN],sz[MAXN],cnt,flag=0,ans=-inf;struct Edges&#123; int to,nxt;&#125;E[MAXN&lt;&lt;1];inline void addedge(int u,int v)&#123; E[++cnt].nxt = head[u]; E[cnt].to = v; head[u] = cnt;&#125;inline void dfs(int u,int f)&#123; int cur = -inf; fa[u] = f; dp[u] = -inf; for (int i = head[u]; i; i = E[i].nxt)&#123; int v = E[i].to; if (v == fa[u]) continue; ++sz[u]; dfs(v,u); w[u] += w[v]; dp[u] = max(dp[u],dp[v]); if (sz[u] &gt; 1) flag = 1; ans = max(ans,cur + dp[v]); cur = max(cur,dp[v]); &#125; dp[u] = max(dp[u],w[u]);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(); rep(i,1,n) w[i]=read(); rep(i,1,n-1) &#123;int u=read(),v=read(); addedge(u,v); addedge(v,u);&#125; dfs(1,-1); if (!flag) return puts("Impossible"),0; else return printf("%lld\n",ans),0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåCF696B„ÄçPuzzles Ê†ë‰∏äÊúüÊúõDP]]></title>
    <url>%2F2018%2F07%2F22%2F%E3%80%8CCF696B%E3%80%8DPuzzles-%E6%A0%91%E4%B8%8A%E6%9C%9F%E6%9C%9BDP%2F</url>
    <content type="text"><![CDATA[Links there:CF696B È¢òÊÑèÁªô‰∏ÄÊ£µÊ†ë,Ê†πÊçÆ$dfs(x)$‰∏≠$x$ÁöÑ‰∏çÂêå,ÊØè‰∏™ËäÇÁÇπÁöÑ$dfn(i)$‰πü‰ºö‰∏çÂêå,Ê±Ç$dfs(i),i \in[1,n]$‰∏≠$dfn(i)$ÁöÑÊúüÊúõ. ÊÄùË∑ØËøòÊòØÂéªËÄÉËôëÊØè‰∏™ËäÇÁÇπ‰Ωú‰∏∫Ê†πËäÇÁÇπÂ§ßÊ≥ïÂ∏àÊó∂ÂØπÂÖ∂‰ªñÁÇπÁöÑË¥°ÁåÆ. Êàë‰ª¨‰∏çÂ¶ÇËÄÉËôë‰∏ÄÈ¢óÂ≠êÊ†ë.Â∑≤Áü•ËäÇÁÇπ$u$ÁöÑÊúüÊúõ$ans[u]=1.0$ ÂØπ‰∫éÂâ©‰∏ãÁöÑÁÇπËÄÉËôë$dfn$ÁöÑÊéíÂàóÂèØ‰ª•ÊòØÁõ¥Êé•‰ªé$u$Âà∞Ëææ,Âàô$ans[v] += ans[u] + 1.0$ ÊàñËÄÖÊòØÁªèËøá$u$ÁöÑÂÖ∂‰ªñÂÑøÂ≠ê‰∏îÊéíÂú®ËäÇÁÇπ$v$ÂâçÈù¢ÁöÑÂÑøÂ≠êÁöÑÊù•. ‰∏çÈöæÂèëÁé∞ÊØèÊ¨°ÂØπ‰∫é‰ªªÊÑè$u$ÁöÑÂÑøÂ≠ê$a,b$Êª°Ë∂≥$dfn(a)&gt;dfn(b)$ÁöÑÊ¶ÇÁéá‰∏∫$\frac{1}{2}$ ÊâÄ‰ª•Á¨¨‰∫åÈÉ®ÂàÜ$ans[v] += (ÂÖ∂‰ªñËäÇÁÇπÊÄªÊï∞) * 0.5$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+100;struct Edges&#123; int to,nxt;&#125;E[MAXN&lt;&lt;1];int head[MAXN],sz[MAXN],cnt = 0,n;double ans[MAXN];inline void addedge(int u,int v)&#123; E[++cnt].nxt = head[u]; E[cnt].to = v; head[u] = cnt;&#125;///------------------head------------------inline void dfs(int u,int fa)&#123; sz[u] = 1; for (int i=head[u],v; i; i=E[i].nxt)&#123; v=E[i].to; //if (v != fa) dfs(v,u); sz[u] += sz[v]; &#125;&#125;inline void dfs2(int u,int f)&#123; for (int i=head[u],v; i; i=E[i].nxt)&#123; v=E[i].to; //if(v==f)continue; ans[v]=ans[u]+1.0+(sz[u]-sz[v]-1)*0.5; dfs2(v,u); &#125;&#125;signed main(signed argc, char *argv[])&#123; n=read(); rep(i,2,n) &#123; int t=read(); addedge(t,i); &#125; dfs(1,-1); ans[1] = 1.0; dfs2(1,-1); rep(i,1,n) printf("%.7lf ",ans[i]); return 0;&#125;/* Examples: *//**//**/]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåZOJ3626„ÄçTreasure Hunt I Ê†ë‰∏äËÉåÂåÖ]]></title>
    <url>%2F2018%2F07%2F22%2F%E3%80%8CZOJ3626%E3%80%8DTreasure-Hunt-I-%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Links there:ZOJ3626 È¢òÊÑèÁªô‰∏ÄÊ£µÊ†ëÊØèÊù°Ëæπ‰∏äÊúâËä±Ë¥πÂÄº$cost_i$,ÊØè‰∏™ÁÇπ‰∏äÊúâÊùÉÂÄº$w_i$,Ê±Ç‰ª•$k$‰∏∫Ëµ∑ÁÇπ,Ëä±Ë¥πÂ∞è‰∫é$m$,Âπ∂ÊúÄÁªàÂõûÂà∞Ëµ∑ÁÇπ$k$,ËÉΩÂæóÂà∞ÁöÑÊúÄÂ§ßÊùÉÂÄº ÊÄùË∑ØÊ†ë‰∏äÁöÑËÉåÂåÖdp ‰ª§$f[i][j]$Ë°®Á§∫‰ªé$i$‰∏∫Ëµ∑ÁÇπ,Ëä±Ë¥π$j$ÊâÄÂèØ‰ª•ÂæóÂà∞ÁöÑÊúÄÂ§ßÊùÉÂÄº.Êúâ‰∏§ÁßçÂÜ≥Á≠ñÂØπ‰∫é$i$ÁöÑÂ≠©Â≠ê$v$,Ë¶Å‰πà‰∏çËµ∞,Ë¶Å‰πàËä±Ë¥π$cost_{i \space to \space v}$ ÊâÄ‰ª•Êúâ$f[i][j]=max(f[i][j],f[v][k]+f[i][j-cost-k])$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 110;struct Edges&#123; int to,nxt,cost;&#125;E[MAXN&lt;&lt;1];int n,m,k,head[MAXN],w[MAXN],vis[MAXN],cnt,ans;int f[MAXN][2010];inline void addedge(int u,int v,int w)&#123; E[++cnt].nxt = head[u]; E[cnt].to = v; E[cnt].cost = w; head[u] = cnt;&#125;void dfs(int u)&#123; vis[u]=1; f[u][0] = w[u]; for (int i = head[u]; i; i = E[i].nxt)&#123; int v = E[i].to,cost = E[i].cost; if (!vis[v]) &#123; dfs(v); per(j,m,0) rep(k,0,j-cost) f[u][j]=max(f[v][k]+f[u][j-k-cost],f[u][j]); &#125; &#125;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; while(scanf("%lld",&amp;n) == 1)&#123; cnt=0;ans=-1;MM(vis,0);MM(head,0);MM(f,0); rep(i,1,n) w[i]=read(); rep(i,1,n-1) &#123;int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w);&#125; k=read(),m=read()&gt;&gt;1; dfs(k); rep(i,0,m) ans=max(ans,f[k][i]); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>DP-Ê†ëÂΩ¢DP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåCF1006F„ÄçXor-Paths Meet-in-the-middle]]></title>
    <url>%2F2018%2F07%2F21%2F%E3%80%8CCF1006F%E3%80%8DXor-Paths-Meet-in-the-middle%2F</url>
    <content type="text"><![CDATA[(Á¨¨‰∏Ä‰ªΩÂ±ØÈ¢òËÆ°Âàí?) Links there:CF1006F È¢òÊÑèÁªôÂÆö‰∏Ä‰∏™$n \times m$ÁöÑÁü©Èòµ,‰ªéËµ∑ÁÇπ$(1,1)$Ëµ∑Ê≠•Âà∞$(n,m)$,ÊØèÊ¨°Âè™ËÉΩÂêë‰∏ãÊàñËÄÖÂêëÂè≥Ëµ∞. Ê±ÇÊâÄÊúâÊª°Ë∂≥Ë∑ØÂæÑ‰∏äÁöÑÂºÇÊàñÂíå‰∏∫ $k$ ÁöÑË∑ØÂæÑÊù°Êï∞. $ n,m \leq 20 ,\space k\leq 1e18$ ÊÄùË∑ØÈááÁî®‰∏≠Èó¥Áõ∏ÈÅáÁöÑÊñπÊ≥ï.ÊòæÁÑ∂ÊØèÊ¨°‰ªé$(1,1)$ Âà∞ $(n,m)$ ÈúÄË¶ÅËµ∞$(n+m-2)$Ê≠•.Ââç‰∏ÄÂçäÊö¥ÂäõÂ§ßÊ≥ïÂ∏à.Âêé‰∏ÄÂçäÁõ¥Êé•Âà§Êñ≠ÊòØÂê¶ÂèØ‰ª•ÂºÇÊàñÂà∞$k$Âç≥ÂèØ.$k$ÂæàÂ§ßÁöÑËØù‰∏çÂ¶ÇÂºÄ‰∏™$map$. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 25;map&lt;int,int&gt;cnt[MAXN][MAXN];int a[MAXN][MAXN],ans=0,n,m,k,h;inline void dfs(int x,int y,int val,int step)&#123; if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) return ; int cur = val ^ a[x][y]; if (x+y == h+2) &#123; ++cnt[x][y][cur]; return ; &#125; dfs(x+1,y,cur,step+1); dfs(x,y+1,cur,step+1);&#125;inline void dfs2(int x,int y,int val,int step)&#123; if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) return ; int cur = val ^ a[x][y]; if (x+y == h+2) &#123; if (cnt[x][y][val^k]) ans += cnt[x][y][val^k]; return ; &#125; dfs2(x-1,y,cur,step+1); dfs2(x,y-1,cur,step+1);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),m=read(),k=read(); h=(n+m-2)&gt;&gt;1; rep(i,1,n) rep(j,1,m) a[i][j]=read(); dfs(1,1,0,0); dfs2(n,m,0,0); printf("%lld\n",ans); return 0;&#125;/* Examples: *//*3 3 112 1 57 10 012 6 4*//*3*/]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåÂ±ØÈ¢òËÆ°Âàí„ÄçCodeforces Ê≥õÂÅö]]></title>
    <url>%2F2018%2F07%2F21%2F%E3%80%8C%E5%B1%AF%E9%A2%98%E8%AE%A1%E5%88%92%E3%80%8DCodeforces-%E6%B3%9B%E5%81%9A%2F</url>
    <content type="text"><![CDATA[‰πüÁÆóÊòØ‰∏™ËÑëÂ≠êÂ∫∑Â§çËÆ≠ÁªÉÂêß„ÄÇ ËíüËíª‰∏çÂÅöÈ¢òÊèêÂâçÈÄÄÂΩπ„ÄÇËíüËíª‰∏çÊíïÁÉ§Êô∫ÁÜµ‰ΩïÊù•ÔºüËíüËíª‰∏çÂèçÁúÅÂ§©Â§©Ë¢´D„ÄÇ Codeforces: 3 / 50]]></content>
      <categories>
        <category>Â±ØÈ¢òËÆ°Âàí</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåBZOJ5028„ÄçÂ∞èZÁöÑÂä†Ê≤πÂ∫ó Â∑ÆÂàÜ Á∫øÊÆµÊ†ëÂçïÁÇπ‰øÆÊîπÂå∫Èó¥Ê±Çgcd]]></title>
    <url>%2F2018%2F07%2F21%2F%E3%80%8CBZOJ5028%E3%80%8D%E5%B0%8FZ%E7%9A%84%E5%8A%A0%E6%B2%B9%E5%BA%97-%E5%B7%AE%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%B1%82gcd%2F</url>
    <content type="text"><![CDATA[Links there:BZOJ5028 È¢òÊÑèÂèÇËßÅ‰º†ÈÄÅÈó®(ÊáíÂæóÂÜô‰∫Ü) ÊÄùË∑ØËÄÉËØïÊó∂ÁöÑÊàë:‚ÄùmdÊÄé‰πàÊêûÂïä Â∫îËØ•ÊòØÊ±Ç‰∏™Âå∫Èó¥gcdÂêß ÈÇ£ËøôÊ†∑ÁöÑËØùÂä†Ê†áËÆ∞ÂØπÊ±ÇgcdÊúâÂΩ±ÂìçÊÄé‰πàÁÆóÂïä ‰∏ç‰ºö‰∏çÊòØÁ∫øÊÆµÊ†ëËøô‰∏™‰∏úË•øÂêß ‰ºö‰∏ç‰ºöÊòØÂàÜÂùóÂïä ÈöæÈÅìËøòÊúâÂÖ∂‰ªñÂßøÂäøÂêó‚Ä¶‚Äù ËØ∂ ÈÇ£‰πàÂ∑ÆÂàÜ‰∏Ä‰∏ã‰∏ç‰πÖÂÆå‰∫ã‰∫Ü!Â§öÂºÄ‰∏™Á∫øÊÆµÊ†ëÊàñËÄÖÊ†ëÁä∂Êï∞ÁªÑËÆ∞ÂΩïÂéüÂ∫èÂàóÂ∞±Â•Ω‰∫ÜÂïä! Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long long#define lowbit(x) (x&amp;-x)inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1const int N = 1e5+100;int n,m,B[N],ans[4*N],C[4*N];inline void add(int p,int v)&#123;for(int i = p;i &lt; N;i += lowbit(i)) C[i] += v;&#125;inline int sum(int p)&#123;int ret = 0;for(int i = p;i;i -= lowbit(i)) ret += C[i];return ret;&#125;inline int _gcd(int a,int b)&#123;a=abs(a);b=abs(b);return __gcd(a,b);&#125;inline void build(int o,int l,int r)&#123; if(l == r)&#123;ans[o] = B[l] - B[l - 1];return;&#125; int mid = (l + r) &gt;&gt; 1; build(lc,l,mid);build(rc,mid + 1,r); ans[o] = _gcd(ans[lc],ans[rc]);&#125;inline void modify(int o,int l,int r,int p,int v)&#123; if(l == r)&#123;ans[o] += v;return;&#125; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) modify(lc,l,mid,p,v); else modify(rc,mid + 1,r,p,v); ans[o] = _gcd(ans[lc],ans[rc]);&#125;inline int query(int o,int l,int r,int L,int R)&#123; if(l == L &amp;&amp; r == R) return ans[o]; int mid = (l + r) &gt;&gt; 1; if(R &lt;= mid) return query(lc,l,mid,L,R); if(L &gt; mid) return query(rc,mid + 1,r,L,R); return _gcd(query(lc,l,mid,L,mid),query(rc,mid + 1,r,mid + 1,R));&#125;signed main(signed argc, char *argv[])&#123; // freopen("bucket.in","r",stdin); // freopen("bucket.out","w",stdout); n = read(),m = read(); MM(B,0);MM(C,0); for(int i = 1;i &lt;= n;i++)&#123; B[i] = read(); add(i,B[i]); add(i + 1,-B[i]); &#125; build(1,1,n); while(m--)&#123; int opt = read(),l = read(),r = read(),v; if(opt == 1)&#123; v = read(); modify(1,1,n,l,v); if(r &lt; n) modify(1,1,n,r + 1,-v); add(l,v); add(r + 1,-v); &#125; else&#123; if(l == r)&#123; printf("%lld\n",sum(l)); continue; &#125; printf("%lld\n",_gcd(query(1,1,n,l + 1,r),sum(r))); &#125; &#125; // fclose(stdin); fclose(stdout); return 0;&#125;]]></content>
      <categories>
        <category>Á∫øÊÆµÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåHDU1290„Äç(Âä†Âº∫) Êï∞Â≠¶ ÈÄíÊé®]]></title>
    <url>%2F2018%2F07%2F21%2FHDU1290-%E5%8A%A0%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[Links there:HDU1290(Âº±ÂåñÁâà) È¢òÊÑèÁªô‰∏Ä‰∏™ÁêÉ,ÊääÁêÉÂàá $N$ ÂàÄ(ÂÖÅËÆ∏ÂêÑ‰∏™ÊñπÂêë‰ΩÜÊòØÂøÖÈ°ªÁõ¥Á∫øÂàá),ÈóÆÊúÄÂ§öÂèØ‰ª•ÂàÜÊàêÂ§öÂ∞ëÂùó(ÂØπ$1e9+7$ÂèñÊ®°). Âä†Âº∫,$N \leq 1,000,000,000$ ÊÄùË∑Ø‰ª§$f(n)$Ë°®Á§∫Á≠îÊ°à,Êó¢ÊúÄÂ§öÂèØ‰ª•ÂàÜÊàêÁöÑÂùóÊï∞,$d(n)$Ë°®Á§∫‰∫åÁª¥Âπ≥Èù¢ÂÜÖ $N$ Êù°Áõ¥Á∫øÂàÜÊàêÁöÑÂùóÊï∞ ËÄÉËôë$f(n)$‰∏é$f(n-1)$ÁöÑÂÖ≥Á≥ª,Áõ∏ÂΩì‰∫éÂú®$f(n-1)$ÁöÑÂü∫Á°Ä‰∏äÂÜçÂú®‰∏Ä‰∏™Âπ≥Èù¢ÂÜÖÂ§öÂàÜÂá∫$d(n-1)$Âùó ÊâÄ‰ª•Êúâ$f(n)=f(n-1)+d(n-1)$ $d(n-1) = 1+\frac{(n-1)\times n}{2}$ (Ëøô‰∏™Â∫îËØ•Â∞èÂ≠¶Â••Êï∞Â∞±ÊïôËøáÂêß..Êâæ‰∏Ä‰∏ãËßÑÂæãÂ∞±Ë°å‰∫Ü) ÊâÄ‰ª•$f(n) = f(1) + \sum_{i=1}^{n-1}d(i)$ ÊòéÊòæ$f(1)=2$ $f(n)=2+(n-1)+\sum{i=2}^{n}\frac{n^2}{2}-\sum{i=2}^{n}\frac{n}{2}$ ËØ∂Êàë‰ª¨‰ºº‰πéÂèëÁé∞ÊääÂêéÈù¢‰∏§‰∏™$\sum$‰∏≠$i$‰∏ãÊ†á‰ªé1ÂºÄÂßãÂØπÁ≠îÊ°àÊ≤°ÊúâÂΩ±ÂìçËÄå‰∏î‰ºº‰πéÊõ¥‰ºòÁæé‰∫Ü! $\therefore f(n) = n+1+\frac{n\times (n+1) \times (2n+1)}{12}+\frac{(1+n)\times n}{4}$ ‰∫éÊòØÊ±Ç‰∏Ä‰∏ãÈÄÜÂÖÉÂïä‰ªÄ‰πàÁöÑÂ∞±Ëß£ÂÜ≥‰∫ÜÂïä Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int Mod = 1e9+7;///------------------head------------------signed main(signed argc,char *argv[])&#123; freopen("melon.in","r",stdin); freopen("melon.out","w",stdout); rep(i,1,5) &#123; int n=read(); int ans=(1+n+(getinv(12,Mod) * n % Mod * (n+1) % Mod * (2*n+1) % Mod) - (getinv(4,Mod) * n % Mod * (n+1) % Mod) + Mod) % Mod; printf("%lld\n",ans); &#125; fclose(stdin); fclose(stdout); return 0;&#125;/* Examples: *//**//**/]]></content>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåNOI2018„ÄçÂ±†ÈæôÂãáÂ£´ CRT,EXCRT]]></title>
    <url>%2F2018%2F07%2F21%2FNOI2018-%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB-CRT-EXCRT%2F</url>
    <content type="text"><![CDATA[‰∏ÄÈÅìÁªÜËäÇÊØíÁò§ÁöÑÁ≠æÂà∞È¢ò È¢òÊÑèÂ∞èD ÊúÄËøëÂú®ÁΩë‰∏äÂèëÁé∞‰∫Ü‰∏ÄÊ¨æÂ∞èÊ∏∏Êàè„ÄÇÊ∏∏ÊàèÁöÑËßÑÂàôÂ¶Ç‰∏ãÔºö Ê∏∏ÊàèÁöÑÁõÆÊ†áÊòØÊåâÁÖßÁºñÂè∑$1 - n$ È°∫Â∫èÊùÄÊéâ $n$ Êù°Â∑®ÈæôÔºåÊØèÊù°Â∑®ÈæôÊã•Êúâ‰∏Ä‰∏™ÂàùÂßãÁöÑÁîüÂëΩÂÄº $a_i$ „ÄÇÂêåÊó∂ÊØèÊù°Â∑®ÈæôÊã•ÊúâÊÅ¢Â§çËÉΩÂäõÔºåÂΩìÂÖ∂‰ΩøÁî®ÊÅ¢Â§çËÉΩÂäõÊó∂ÔºåÂÆÉÁöÑÁîüÂëΩÂÄºÂ∞±‰ºöÊØèÊ¨°Â¢ûÂä† $p_i$ ,Áõ¥Ëá≥ÁîüÂëΩÂÄºÈùûË¥ü„ÄÇÂè™ÊúâÂú®ÊîªÂáªÁªìÊùüÂêé‰∏îÂΩìÁîüÂëΩÂÄºÊÅ∞Â•Ω‰∏∫ $0$ Êó∂ÂÆÉÊâç‰ºöÊ≠ªÂéª„ÄÇ Ê∏∏ÊàèÂºÄÂßãÊó∂Áé©ÂÆ∂Êã•Êúâ $m$ ÊääÊîªÂáªÂäõÂ∑≤Áü•ÁöÑÂâëÔºåÊØèÊ¨°Èù¢ÂØπÂ∑®ÈæôÊó∂ÔºåÁé©ÂÆ∂Âè™ËÉΩÈÄâÊã©‰∏ÄÊääÂâëÔºåÂΩìÊùÄÊ≠ªÂ∑®ÈæôÂêéËøôÊääÂâëÂ∞±‰ºöÊ∂àÂ§±Ôºå‰ΩÜ‰Ωú‰∏∫Â•ñÂä±ÔºåÁé©ÂÆ∂‰ºöËé∑ÂæóÂÖ®Êñ∞ÁöÑ‰∏ÄÊääÂâë„ÄÇ Â∞èDËßâÂæóËøôÊ¨æÊ∏∏ÊàèÂçÅÂàÜÊó†ËÅäÔºå‰ΩÜÊúÄÂø´ÈÄöÂÖ≥ÁöÑÁé©ÂÆ∂ÂèØ‰ª•Ëé∑Âæó ION2018 ÁöÑÂèÇËµõËµÑÊ†ºÔºå‰∫éÊòØÂ∞èDÂÜ≥ÂÆöÂÜô‰∏Ä‰∏™Á¨®Á¨®ÁöÑÊú∫Âô®‰∫∫Â∏ÆÂ•πÈÄöÂÖ≥ËøôÊ¨æÊ∏∏ÊàèÔºåÂ•πÂÜôÁöÑÊú∫Âô®‰∫∫ÈÅµÂæ™‰ª•‰∏ãËßÑÂàôÔºö ÊØèÊ¨°Èù¢ÂØπÂ∑®ÈæôÊó∂ÔºåÊú∫Âô®‰∫∫‰ºöÈÄâÊã©ÂΩìÂâçÊã•ÊúâÁöÑÔºåÊîªÂáªÂäõ‰∏çÈ´ò‰∫éÂ∑®ÈæôÂàùÂßãÁîüÂëΩÂÄº‰∏≠ÊîªÂáªÂäõÊúÄÂ§ßÁöÑ‰∏ÄÊääÂâë‰Ωú‰∏∫Ê≠¶Âô®„ÄÇÂ¶ÇÊûúÊ≤°ÊúâËøôÊ†∑ÁöÑÂâëÔºåÂàôÈÄâÊã©ÊîªÂáªÂäõÊúÄ‰ΩéÁöÑ‰∏ÄÊääÂâë‰Ωú‰∏∫Ê≠¶Âô®„ÄÇ Êú∫Âô®‰∫∫Èù¢ÂØπÊØèÊù°Â∑®ÈæôÔºåÂÆÉÈÉΩ‰ºö‰ΩøÁî®‰∏ä‰∏ÄÊ≠•‰∏≠ÈÄâÊã©ÁöÑÂâëÊîªÂáªÂ∑®ÈæôÂõ∫ÂÆöÁöÑ$x$Ê¨°Ôºå‰ΩøÂ∑®ÈæôÁöÑÁîüÂëΩÂÄºÂáèÂ∞ë $x \times ATK$ „ÄÇ ‰πãÂêéÔºåÂ∑®Èæô‰ºö‰∏çÊñ≠‰ΩøÁî®ÊÅ¢Â§çËÉΩÂäõÔºåÊØèÊ¨°ÊÅ¢Â§çpi ÁîüÂëΩÂÄº„ÄÇËã•Âú®‰ΩøÁî®ÊÅ¢Â§çËÉΩÂäõÂâçÊàñ Êüê‰∏ÄÊ¨°ÊÅ¢Â§çÂêéÂÖ∂ÁîüÂëΩÂÄº‰∏∫0 ÔºåÂàôÂ∑®ÈæôÊ≠ª‰∫°ÔºåÁé©ÂÆ∂ÈÄöËøáÊú¨ÂÖ≥„ÄÇ ÈÇ£‰πàÊòæÁÑ∂Êú∫Âô®‰∫∫ÁöÑÊîªÂáªÊ¨°Êï∞ÊòØÂÜ≥ÂÆöËÉΩÂê¶ÊúÄÂø´ÈÄöÂÖ≥ËøôÊ¨æÊ∏∏ÊàèÁöÑÂÖ≥ÈîÆ„ÄÇÂ∞è D Áé∞Âú®ÂæóÁü•‰∫ÜÊØèÊù°Â∑®ÈæôÁöÑÊâÄÊúâÂ±ûÊÄßÔºåÂ•πÊÉ≥ËÄÉËÄÉ‰Ω†Ôºå‰Ω†Áü•ÈÅìÂ∫îËØ•Â∞ÜÊú∫Âô®‰∫∫ÁöÑÊîªÂáªÊ¨°Êï∞xËÆæÁΩÆ‰∏∫Â§öÂ∞ëÔºåÊâçËÉΩÁî®ÊúÄÂ∞ëÁöÑÊîªÂáªÊ¨°Êï∞ÈÄöÂÖ≥Ê∏∏ÊàèÂêóÔºü ÂΩìÁÑ∂Â¶ÇÊûúÊó†ËÆ∫ËÆæÁΩÆÊàêÂ§öÂ∞ëÈÉΩÊó†Ê≥ïÈÄöÂÖ≥Ê∏∏ÊàèÔºåËæìÂá∫$-1$Âç≥ÂèØ„ÄÇ ÊÄùË∑Ø‰∏çÈöæÂèëÁé∞ ÊØèÊ¨°‰ΩøÁî®ÁöÑÂâëÈÉΩÊòØÂèØ‰ª•Á°ÆÂÆöÁöÑ Áî®priority_queueÊàñËÄÖmapÊàñËÄÖsetÊàñËÄÖËÑëÊÆãÂú∞ÊâãÂÜô‰∏Ä‰∏™Âπ≥Ë°°Ê†ëÈÉΩÂèØ‰ª•Âú®$logn$ÁöÑÊó∂Èó¥ÂÜÖÂæóÂà∞. ÊâÄ‰ª•Áî®$O(nlogn)$ÁöÑÊó∂Èó¥ÂæóÂà∞ÊâÄÊúâÁöÑ$swd_i,p_i,a_i$ Êàë‰ª¨ÁöÑ‰ªªÂä°ÊòØËß£ÂØπ‰∫éÊâÄÊúâÊ®°ÊñπÁ®ãÁªÑÊàêÁ´ãÁöÑ $x$. swd_i\times x \space -a_i \equiv0 \pmod {p_i} x \equiv a_i * inv(swd_i) \pmod {p_i}‰ºº‰πéÁî®‰∏Ä‰∏™EXCRTÂ∞±Â•Ω‰∫Ü,Âõ†‰∏∫‰∏ç‰øùËØÅ$p_i$ÊòØË¥®Êï∞,Ë¶ÅÁî®ex_gcdÊ±ÇÈÄÜÂÖÉ,ÁâπÂà§Ë¥üÊï∞ÊÉÖÂÜµ. Â¶ÇÊûúÁî®‰πòËµ∑Êù•ÁöÑCRTÁßíÁßíÈíüÁàÜÁÇ∏long longÂì¶ Áî®ÂêàÂπ∂ÂºèÁöÑEXCRT‰ºº‰πéÊõ¥Âä†ËµÑÁì∑Âì¶ ‰∏≠Èó¥ÁàÜlong longÂØºËá¥ÊàëÂêåÊ≠•ËµõÂ∞±Âè™Êúâ25ÂàÜ‰∫Ü‚Ä¶.ÁÇíÈ∏°ÈöæÂèó‚Ä¶ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 2e5+100;///------------------head------------------int a[MAXN],p[MAXN],swd[MAXN],tag[MAXN],cur=1,cc;int Remain[MAXN];inline int MulMod(int a,int b,int m)&#123; int t = a * b - (int)((long double) a * b /m) *m; return t%m+(t&gt;&gt;63&amp;m);&#125;struct Node&#123; int pri,atk; bool operator &lt; (const Node &amp;b) const &#123; if (pri &lt; cur &amp;&amp; b.pri &lt; cur)&#123; if(atk &lt;= cc &amp;&amp; b.atk &lt;= cc) return atk &lt; b.atk; else return atk &gt; b.atk; &#125; else return pri &lt; b.pri; &#125; Node(int xx=0,int yy=0):pri(xx),atk(yy)&#123;&#125;&#125;b[MAXN];priority_queue&lt;Node&gt;pq;int n,m;void Pref()&#123; while(!pq.empty()) pq.pop(); cur=1; cc=0;&#125;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123;if(!b)&#123;x=1;y=0;return a;&#125;int k=exgcd(b,a%b,y,x);y-=x*(a/b); return k;&#125;inline int exgcd_inv(int a,int b)&#123; //calc inv(a) in mod b int x,y,ans; if (exgcd(a,b,x,y) == 1) ans = (x%b+b) % b; else ans = -1; return ans;&#125;inline bool merge(int a1, int m1, int a2, int m2, int &amp;a3, int &amp;m3) &#123; int d = __gcd(m1, m2); int c = a2 - a1; if(c % d) return false; c = (c % m2 + m2) % m2; m1 /= d;m2 /= d;c /= d; c = MulMod(c,exgcd_inv(m1, m2),m2); c *= m1 * d; c += a1; m3 = m1 * m2 * d; a3 = (c % m3 + m3) % m3; return true;&#125;int CRT(int a[], int m[], int n) &#123; int a1 = a[1]; int m1 = m[1]; for(int i=2; i&lt;=n; i++) &#123; int a2 = a[i]; int m2 = m[i]; int m3, a3; if(!merge(a1, m1, a2, m2, a3, m3)) return -1; a1 = a3; m1 = m3; &#125; return (a1 % m1 + m1) % m1;&#125;signed main(signed argc, char *argv[])&#123; freopen("dragon.in","r",stdin); freopen("dragon.out","w",stdout); int T=read(); while(T--)&#123; int flg=0,minans=0; Pref(); n=read(); m=read(); rep(i,1,n) a[i]=read();rep(i,1,n) p[i]=read(); rep(i,1,n) b[i]=Node(i,read());rep(i,1,m) b[n+i] = Node(0,read()); rep(i,1,m) pq.push(b[n+i]); rep(i,1,n)&#123; cur=i; cc=a[cur]; Node t=pq.top(); swd[i]=t.atk; pq.pop(); pq.push(b[i]); minans = max(minans,((a[i]+swd[i]-1)/swd[i])); &#125; rep(i,1,n) &#123; int iv = exgcd_inv(swd[i],p[i]); if (iv == -1) &#123;flg = 1; break;&#125; Remain[i] = MulMod(iv,a[i],p[i]); //iv * a[i] % p[i]; &#125; if (flg) &#123;puts("-1"); continue;&#125; int ans = CRT(Remain,p,n); if (ans == -1) puts("-1"); else printf("%lld\n",max(ans,minans)); &#125; fclose(stdin); fclose(stdout); return 0;&#125;]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåPKUSC2018„ÄçÁ•û‰ªôÁöÑÊ∏∏Êàè NTT ÁîüÊàêÂáΩÊï∞ Â≠óÁ¨¶‰∏≤]]></title>
    <url>%2F2018%2F07%2F19%2F%E3%80%8CPKUSC2018%E3%80%8D%E7%A5%9E%E4%BB%99%E7%9A%84%E6%B8%B8%E6%88%8F-NTT-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Links there:PKUSC2018-Á•û‰ªôÁöÑÊ∏∏Êàè ÂÖàÂêëËÄÉÂú∫Âè™ÂÅö‰∫Ü18ÂàÜÁöÑÊàëÂá≠Âêä. ‰∏äÊ¨°ËÄÉÂÆåÂê¨ËØ¥ËøôÊòØ‰∏™Â§öÁøîÂºèÁöÑÈ¢ò,‰ΩÜ‰ºº‰πé‰∏ÄÁõ¥Âøò‰∫ÜÂéªÊÄùËÄÉ‰∏∫‰ªÄ‰πà‚Ä¶ÊâÄ‰ª•Â∞±ÂΩìË°•‰∏ä‰∫ÜÂêß. È¢òÊÑèÁªôÂá∫‰∏Ä‰∏™Áî± $0$ , $1$ , $?$ ÊûÑÊàêÁöÑ‰∏≤ $s$ .ÈóÆÂè∑ÂèØ‰ª•Êç¢Êàê $0,1$,Áé∞Âú®ÂÆö‰πâ$f(len)$ Ë°®Á§∫ $s$ ‰∏≠ÈïøÂ∫¶‰∏∫ $len$ ÁöÑÂâçÁºÄÊòØÂê¶ËÉΩÂ§üÊàê‰∏∫$border$,Â¶ÇÊûúÊòØÂàôÂÄº‰∏∫$1$,Âê¶Âàô‰∏∫$0$. Ê±ÇÂºÇÊàñÂíå (f(1) √ó1^2 ) xor(f(2)√ó2^2)xor¬∑¬∑\space xor(f(n) √ón^2) ÊÄùË∑ØÂØªÊâæÊâÄË∞ìÁöÑ$border$ÁöÑÊÄßË¥®,Â¶ÇÊûúÂØπ‰∫é‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫$len$ÁöÑborderÂ≠òÂú®,ÂΩì‰∏î‰ªÖÂΩì $\forall i‚àà[1,n‚àílen]$ Êúâ $s[i] = s[n-len+1]$ Á≠â‰ª∑‰∫éÂú®Mod $n-len$ÁöÑÊÑè‰πâ‰∏ãÂàÜÁªÑ,ÊØè‰∏ÄÁªÑÁöÑÊâÄÊúâ01ÂøÖÈ°ªÁõ∏Âêå„ÄÇ ÈÇ£‰πàÂØπ‰∫éÊØè‰∏ÄÂØπ01Êù•ËØ¥ÂØπ‰∫é‰ªªÊÑèÁöÑ$x,x|(pos_0 - pos_1)$ÈÉΩ‰∏çÂèØË°å. ËÄÉËôëÊ±ÇÂá∫ÊâÄÊúâÁöÑ$(pos_0 - pos_1)$ÁÑ∂ÂêéÊö¥ÂäõÊûö‰∏æ‰ªñÁöÑÂÄçÊï∞Â∞±Ë°åÂï¶,Â§çÊùÇÂ∫¶ÊòØ$O(n lnn)$ ËÄÉËôëÊûÑÈÄ†ËøôÊ†∑‰∏§‰∏™ÁîüÊàêÂáΩÊï∞ $f1(x)=\sum{i=0}^{n}[s_i== 0] x^i$ $f2(x)=\sum{i=0}^n[s_{n-i}==1]x^i$ ÊûÑÈÄ†Âç∑ÁßØ$f_1 * f_2 = f_3$ Âú®$f_3$‰∏≠ÂèëÁé∞$pos_0-pos_1$ÂØπÂ∫îÁöÑÂ∞±ÊòØ$pos_0-pos_1+n$ $NTT$‰ºòÂåñÂêéÂú®$f_3$‰∏≠ÁªüËÆ°Á≠îÊ°àÂ∞±Ë°åÂï¶.Â§çÊùÇÂ∫¶ÊòØ$O(nlogn)$,Ëøô‰πüÊòØÊÄªÂ§çÊùÇÂ∫¶. ÊûúÁÑ∂ÊòØÁ•û‰ªôÁöÑÊ∏∏Êàè! Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 2e6+100;const int Mod = 998244353;int A[MAXN],B[MAXN],Rev[MAXN],N,l=0,w = 3;char s[MAXN];///------------------head------------------void NTT(int *a,int op)&#123; for(int i=0;i&lt;N;i++) if(i&lt;Rev[i]) swap(a[i],a[Rev[i]]); for(int i=1;i&lt;N;i&lt;&lt;=1) &#123; int wn = quickpow(w,op==1?(Mod-1)/(2*i):Mod-1-(Mod-1)/(2*i),Mod),t,w; for(int j=0;j&lt;N;j+=i&lt;&lt;1) &#123; w=1; for(int k=0;k&lt;i;k++) &#123; t=w*a[i+j+k]%Mod; w=w*wn%Mod; a[i+j+k]=(a[j+k]-t+Mod)%Mod; a[j+k]=(a[j+k]+t)%Mod; &#125; &#125; &#125; if(~op) for(int i=0,inv=getinv(N,Mod);i&lt;N;i++) a[i]=a[i]*inv%Mod;&#125;int ans = 0;signed main(signed argc, char *argv[])&#123; scanf("%s",s); int Len = strlen(s); for (N=1;N&lt;Len+Len;N&lt;&lt;=1) ++l; for (int i=0;i&lt;N;++i) Rev[i] = (Rev[i&gt;&gt;1] &gt;&gt; 1) | ((i&amp;1)&lt;&lt;(l-1)); for (int i=0;i&lt;Len;++i) A[i] = s[i] == '0',B[i] = s[Len-i-1] == '1'; NTT(A,1); NTT(B,1); for (int i=0;i&lt;N;i++) A[i]=A[i]*B[i]%Mod; NTT(A,-1); ans = Len * Len; for (int i = 1; i &lt; Len; i++)&#123; ans ^= (Len-i) * (Len - i); for (int j = i; j &lt; Len; j += i) if (A[Len-1+j] || A[Len-1-j]) &#123;ans ^= (Len - i) * (Len - i); break;&#125; &#125; printf("%lld\n",ans); return 0;&#125;/* Examples: *//*1?0?*//*17*/]]></content>
      <categories>
        <category>FFT/NTT</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåNOI2011„ÄçÈÅìË∑Ø‰øÆÂª∫ Ê†ëÂΩ¢dp]]></title>
    <url>%2F2018%2F07%2F16%2F%E3%80%8CNOI2011%E3%80%8D%E9%81%93%E8%B7%AF%E4%BF%AE%E5%BB%BA-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[Links there:NOI2011ÈÅìË∑Ø‰øÆÂª∫ È¢òÊÑèÁªôÂá∫‰∏Ä‰∏™Ê†ë,ÂÆö‰πâÊØèÊù°ËæπÁöÑÂª∫ÈÄ†Ë¥πÁî®‰∏∫Ëæπ‰∏§‰æßÁÇπÁöÑÂ∑ÆÁöÑÁªùÂØπÂÄº‰∫éËæπÊùÉ$w_i$ÁöÑ‰πòÁßØ,Ê±ÇÂá∫ÊÄªÁöÑÂª∫ÈÄ†Ë¥πÁî®. (ËØ∂ÊòØ‰∏çÊòØÂ§™ÁÆÄÊ¥Å‰∫Ü) ÊÄùË∑ØÁõ¥Êé•Ê†ëÂΩ¢dpÂ∞±Ë°åÂï¶.‰ºº‰πéÊ≤°‰ªÄ‰πàÂèØ‰ª•ÊÄùËÄÉÁöÑÂú∞ÊñπÂë¢‚Ä¶ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 1e6+100;int sz[MAXN],n,vis[MAXN];struct Edges&#123; int to,w,nxt;&#125;E[MAXN&lt;&lt;1];int head[MAXN],cnt=0,ans=0;inline void addedge(int u,int v,int w)&#123; E[++cnt].nxt = head[u];E[cnt].to = v;E[cnt].w = w;head[u] = cnt; E[++cnt].nxt = head[v];E[cnt].to = u;E[cnt].w = w;head[v] = cnt;&#125;void dfs(int cur)&#123; sz[cur] = 1; for (int i = head[cur]; i; i = E[i].nxt) &#123; int v = E[i].to,w = E[i].w; if (!vis[v]) &#123; vis[v] = 1; dfs(v); sz[cur] += sz[v]; ans += w * abs(n-(sz[v]) - sz[v]); &#125; &#125;&#125;signed main(signed argc, char *argv[])&#123; n=read(); MM(head,0); MM(vis,0); rep(i,1,n-1) &#123;int u=read(),v=read(),w=read(); addedge(u,v,w);&#125; vis[1]=1; dfs(1); printf("%lld\n",ans); return 0;&#125;/* Examples: *//*61 2 11 3 11 4 26 3 15 2 1*//*20*/]]></content>
      <categories>
        <category>DP-Ê†ëÂΩ¢DP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåHEOI2015„ÄçÂÖîÂ≠ê‰∏éÊ®±Ëä± Ë¥™ÂøÉ+Ê†ëÂΩ¢dp]]></title>
    <url>%2F2018%2F07%2F16%2F%E3%80%8CHEOI2015%E3%80%8D%E5%85%94%E5%AD%90%E4%B8%8E%E6%A8%B1%E8%8A%B1-%E8%B4%AA%E5%BF%83-%E6%A0%91%E5%BD%A2dp%E2%80%98%2F</url>
    <content type="text"><![CDATA[Links there:HEOI2015 ÂÖîÂ≠ê‰∏éÊ®±Ëä± È¢òÊÑèÁªôÂá∫‰∏Ä‰∏™ÊúâÊ†πÊ†ë,ÊØè‰∏™ËäÇÁÇπÊúâ‰∏Ä‰∏™ÊùÉÂÄº(Ê®±Ëä±‰∏™Êï∞) $c_i$ ,ÁªôÂá∫ÂÆöÂÄº $m$ ,ÂÆö‰πâÂà†Èô§ËäÇÁÇπÊìç‰Ωú. ÂΩì‰∏Ä‰∏™ËäÇÁÇπË¢´ÂéªÊéâ‰πãÂêé,Ëøô‰∏™ËäÇÁÇπ‰∏äÁöÑÊ®±Ëä±ÂíåÂÆÉÁöÑÂÑøÂ≠êËäÇÁÇπÈÉΩË¢´ËøûÂà∞Âà†ÊéâËäÇÁÇπÁöÑÁà∂ËäÇÁÇπ‰∏ä.Â¶ÇÊûúÁà∂ËäÇÁÇπ‰πüË¢´Âà†Èô§,ÈÇ£‰πàÂ∞±‰ºöÁªßÁª≠Âêë‰∏äËøûÊé•,Áõ¥Âà∞Á¨¨‰∏Ä‰∏™Ê≤°ÊúâË¢´Âà†Èô§ÁöÑËäÇÁÇπ‰∏∫Ê≠¢„ÄÇ ÂØπ‰∫éÊØè‰∏Ä‰∏™ËäÇÁÇπ $i‚Äã$ ,ÂÆÉÁöÑÂÑøÂ≠êËäÇÁÇπÁöÑ‰∏™Êï∞Âíå $i‚Äã$ ËäÇÁÇπ‰∏äÊ®±Ëä±‰∏™Êï∞‰πãÂíå‰∏çËÉΩË∂ÖËøá $m‚Äã$ ,$son_i + c_i \leq m‚Äã$. Ê±ÇÊúÄÂ§öÂà†ÂéªËäÇÁÇπÁöÑ‰∏™Êï∞. ÊÄùË∑ØÔºàÊÑüËßâÊï¥Â§©ÂÇªÈÄºÈ¢òÂÜôÂçäÂ§©Â•ΩÈ¢ìÂ∫üÂïäÔºâ ÂèØ‰ª•ÊääÊ†ë‰∏äÊØè‰∏™ÁÇπÁöÑÊùÉÂÄºÁúã‰∏∫$c_i + son_i$ ÊØèÊ¨°ÂÖàÁªüËÆ°Â≠êÊ†ë‰ø°ÊÅØ,ÂØπÂ≠êÊ†ëË¥™ÂøÉ‰ªéÊùÉÂÄºÂ∞èÁöÑÂºÄÂßãÈÄâÂπ∂Âà†Èô§,Áõ¥Âà∞Êó†Ê≥ï‰ΩøÂæó$son_i + c_i \leq m$‰∏∫Ê≠¢. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 2e6+10;vector&lt;int&gt;lt[MAXN];int n,m,a[MAXN],fa[MAXN],vis[MAXN],ans;///------------------head------------------inline bool cmp(const int &amp;x,const int &amp;y)&#123; return a[x] &lt; a[y];&#125;void dfs(int u)&#123; for (int i = 0; i &lt; (int)(lt[u].size()); i++) dfs(lt[u][i]); a[u] += lt[u].size(); sort(lt[u].begin(),lt[u].end(),cmp); for (int i = 0,v; i &lt; (int)(lt[u].size()); i++) &#123; v = lt[u][i]; if (a[u] + a[v] &lt;= m+1) ++ans,a[u] += a[v] - 1; else break; &#125;&#125;signed main(signed argc, char *argv[])&#123; n=read(),m=read(); rep(i,0,n-1) a[i]=read(); rep(i,0,n-1) &#123; int k=read(); while(k--)&#123; int v=read(); fa[v]=i; lt[i].pb(v); &#125; &#125; dfs(0); printf("%lld\n",ans); return 0;&#125;/* Examples: *//*10 40 2 2 2 4 1 0 4 1 13 6 2 31 91 81 1002 7 401 50*//*4*/]]></content>
      <categories>
        <category>DP-Ê†ëÂΩ¢DP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåSHOI2017„ÄçÂàÜÊâãÊòØÁ•ùÊÑø Â∑ÆÂàÜ,ÊúüÊúõdp]]></title>
    <url>%2F2018%2F07%2F15%2F%E3%80%8CSHOI2017%E3%80%8D%E5%88%86%E6%89%8B%E6%98%AF%E7%A5%9D%E6%84%BF-%E5%B7%AE%E5%88%86-%E6%9C%9F%E6%9C%9Bdp%2F</url>
    <content type="text"><![CDATA[Links there:LOJ-2145/SHOI2017 È¢òÊÑèB ÂêõÂú®Áé©‰∏Ä‰∏™Ê∏∏Êàè,Ëøô‰∏™Ê∏∏ÊàèÁî± $N$ ‰∏™ÁÅØÂíå $N$‰∏™ÂºÄÂÖ≥ÁªÑÊàêÔºåÁªôÂÆöËøô $N$ ‰∏™ÁÅØÁöÑÂàùÂßãÁä∂ÊÄÅ.‰∏ãÊ†á‰∏∫‰ªé $1$ Âà∞ $N$ ÁöÑÊ≠£Êï¥Êï∞„ÄÇ ÊØè‰∏™ÁÅØÊúâ‰∏§‰∏™Áä∂ÊÄÅ‰∫ÆÂíåÁÅ≠ÔºåÊàë‰ª¨Áî® $1$ Êù•Ë°®Á§∫Ëøô‰∏™ÁÅØÊòØ‰∫ÆÁöÑÔºåÁî® $0$ Ë°®Á§∫Ëøô‰∏™ÁÅØÊòØÁÅ≠ÁöÑÔºåÊ∏∏ÊàèÁöÑÁõÆÊ†áÊòØ‰ΩøÊâÄÊúâÁÅØÈÉΩÁÅ≠Êéâ„ÄÇ ‰ΩÜÊòØÂΩìÊìç‰ΩúÁ¨¨ $i$ ‰∏™ÂºÄÂÖ≥Êó∂ÔºåÊâÄÊúâÁºñÂè∑‰∏∫ $i$ ÁöÑÁ∫¶Êï∞ÔºàÂåÖÊã¨ $1$ Âíå $i$ÔºâÁöÑÁÅØÁöÑÁä∂ÊÄÅÈÉΩ‰ºöË¢´ÊîπÂèòÔºåÂç≥‰ªé‰∫ÆÂèòÊàêÁÅ≠ÔºåÊàñËÄÖÊòØ‰ªéÁÅ≠ÂèòÊàê‰∫Æ„ÄÇ B ÂêõÂèëÁé∞Ëøô‰∏™Ê∏∏ÊàèÂæàÈöæÔºå‰∫éÊòØÊÉ≥Âà∞‰∫ÜËøôÊ†∑ÁöÑ‰∏Ä‰∏™Á≠ñÁï•ÔºåÊØèÊ¨°Á≠âÊ¶ÇÁéáÈöèÊú∫Êìç‰Ωú‰∏Ä‰∏™ÂºÄÂÖ≥ÔºåÁõ¥Âà∞ÊâÄÊúâÁÅØÈÉΩÁÅ≠Êéâ„ÄÇ Ëøô‰∏™Á≠ñÁï•ÈúÄË¶ÅÁöÑÊìç‰ΩúÊ¨°Êï∞ÂæàÂ§öÔºåB ÂêõÊÉ≥Âà∞ËøôÊ†∑ÁöÑ‰∏Ä‰∏™‰ºòÂåñ„ÄÇÂ¶ÇÊûúÂΩìÂâçÂ±ÄÈù¢ÔºåÂèØ‰ª•ÈÄöËøáÊìç‰ΩúÂ∞è‰∫éÁ≠â‰∫é $k$ ‰∏™ÂºÄÂÖ≥‰ΩøÊâÄÊúâÁÅØÈÉΩÁÅ≠ÊéâÔºåÈÇ£‰πà‰ªñÂ∞Ü‰∏çÂÜçÈöèÊú∫ÔºåÁõ¥Êé•ÈÄâÊã©Êìç‰ΩúÊ¨°Êï∞ÊúÄÂ∞èÁöÑÊìç‰ΩúÊñπÊ≥ïÔºàËøô‰∏™Á≠ñÁï•ÊòæÁÑ∂Â∞è‰∫éÁ≠â‰∫é $k$ Ê≠•ÔºâÊìç‰ΩúËøô‰∫õÂºÄÂÖ≥„ÄÇ B ÂêõÊÉ≥Áü•ÈÅìÊåâÁÖßËøô‰∏™Á≠ñÁï•Ôºà‰πüÂ∞±ÊòØÂÖàÈöèÊú∫Êìç‰ΩúÔºåÊúÄÂêé Â∞è‰∫éÁ≠â‰∫é $k‚Äã$ Ê≠•Ôºå‰ΩøÁî®Êìç‰ΩúÊ¨°Êï∞ÊúÄÂ∞èÁöÑÊìç‰ΩúÊñπÊ≥ïÔºâÁöÑÊìç‰ΩúÊ¨°Êï∞ÁöÑÊúüÊúõ„ÄÇ Ëøô‰∏™ÊúüÊúõÂèØËÉΩÂæàÂ§ßÔºå‰ΩÜÊòØ B ÂêõÂèëÁé∞Ëøô‰∏™ÊúüÊúõ‰πò‰ª• $N$ ÁöÑÈò∂‰πò‰∏ÄÂÆöÊòØÊï¥Êï∞ÔºåÊâÄ‰ª•‰ªñÂè™ÈúÄË¶ÅÁü•ÈÅìËøô‰∏™Êï¥Êï∞ÂØπ $100003$ ÂèñÊ®°‰πãÂêéÁöÑÁªìÊûú„ÄÇ ÊÄùË∑ØbikeÁöÑÈ¢òÂ∞±ÊòØÁÆÄÊ¥ÅÂπ≤ÂáÄ. ËÄÉËôë$N=K$ÁöÑÊÉÖÂÜµ,ÂèëÁé∞Âè™Ë¶ÅË¥™ÂøÉ‰ªéÂ§ßÂà∞Â∞èÂèñÂ∞±Ë°åÂï¶,ÊâÄ‰ª•50ÂàÜÊòØÈÄÅÁöÑ!? ‰ª§$f(i)$Ë°®Á§∫ËøòÊúâ$i$Ê≠•ËææÊàêÁõÆÊ†áÁöÑÊúüÊúõÊ≠•Êï∞. f(i)=\frac{i}{n}f(i-1)+(1-\frac{i}{n})f(i+1) \\\\ f(i+1)=\frac{i+1}{n}f(i)+(1-\frac{i+1}{n})f(i+2)\\\\ ...‰ΩÜÊòØËøôÊ†∑Âπ∂‰∏çÂ•ΩËÆ°ÁÆóÂïä!Âú®ÁÆó$f(i)$ÁöÑÊó∂ÂÄôÂπ∂‰∏çËÉΩ‰øùËØÅÈÉΩÁü•ÈÅì$f(i-1),f(i+1)$ ËÄÉËôëÂ∑ÆÂàÜ.Â∑ÆÂàÜ$g$ÁöÑÊÑè‰πâÂ∞±ÊòØ‰ªéÁ¨¨$i$Ê≠•Âà∞Á¨¨$i-1$Ê≠•ÁöÑÊúüÊúõ. g(i)=\frac{i}{n}+\frac{n-i}{n}(1+g(i+1)+g(i))\\\\ g(i)=\frac{i}{n}+\frac{n-i}{n}g(i)+\frac{n-i}{n}(1+g(i+1))\\\\ \frac{i}{n}g(i)=\frac{i}{n}+\frac{n-i}{n}(1+g(i+1))\\\\ g(i)=1+\frac{n-i}{i}(i+g(i+1))ÊúÄÁªàÊää$g(i)$Âä†Ëµ∑Êù•Â∞±ÊòØÁ≠îÊ°àÂï¶ CODE123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+100;const int Mod = 1e5+3;int g[MAXN],n,k,lt[MAXN];inline int calc(void)&#123; int ret = 0; for (int i = n; i; i--)&#123; if (lt[i]) &#123; int tt = sqrt(i+0.5); ++ret; for (int j = 1; j &lt;= tt; ++j) if(!(i%j))&#123; lt[j] ^= 1; if (i != j * j) lt[i/j] ^= 1; &#125; &#125; &#125; return ret;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),k=read(); int fac = 1,ans = 0; rep(i,1,n) fac = fac * i % Mod; rep(i,1,n) lt[i]=read(); int t = calc(); if (t &lt;= k) return printf("%lld\n", t * fac % Mod),0; rep(i,1,k) g[i] = 1; g[n] = 1; per(i,n-1,k+1) g[i] = (1 + (g[i+1] + 1) * (n - i) % Mod * getinv(i,Mod) % Mod) % Mod; rep(i,1,t) &#123;ans += g[i]; if (ans &gt;= Mod) ans -= Mod;&#125; ans = ans * fac % Mod; printf("%lld\n",ans); return 0;&#125;/* Examples: *//*4 00 0 1 1*//*512*/]]></content>
      <categories>
        <category>DP-ÊúüÊúõDP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ËØæ‰ª∂/‰∏™‰∫∫ÊÄªÁªì[-RESERVED-]]]></title>
    <url>%2F2018%2F07%2F11%2F%E8%AF%BE%E4%BB%B6-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-RESERVED%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19Ju7k6o3GATIrP5YTvDtlpHdN5I5olEQQfFGB5pGmY+yiS/OX9vOjWoKBsyV2NNcP/a92N+eWakLH0zIYEVWYb/d44CJlvrVodAhSLdtczOO3HQ6I2AMxJ var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>ÊÄªÁªì</category>
      </categories>
      <tags>
        <tag>ÊÄªÁªì</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåHDU2089„Äç‰∏çË¶Å62 Êï∞‰Ωçdp]]></title>
    <url>%2F2018%2F07%2F10%2F%E3%80%8CHDU2089%E3%80%8D%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%2F</url>
    <content type="text"><![CDATA[Links there:HDU-2089-‰∏çË¶Å62 È¢òÊÑèË∫´‰∏∫Êù≠Â∑û‰∫∫ÁúãÂà∞Ëøô‰∏™È¢òÊÑèÁ¨ëÂá∫‰∫ÜÂ£∞. Ê±ÇËßÑÂÆöÂå∫Èó¥ÂÜÖÊï∞Â≠ó‰∏≠Êª°Ë∂≥‰∏çÂê´62ËøûÂè∑„ÄÅ‰∏çÂê´4ÁöÑÊï∞Â≠ó. ÊÄùË∑ØÂíåwindyÊï∞Â∑Æ‰∏çÂ§öÁöÑ ÂèçÊ≠£ÈÉΩÊòØ‰∏Ä‰∏™Â•óË∑Ø. È¢ÑÂ§ÑÁêÜ‰πãÂêéÂÜçÁªüËÆ°Âç≥ÂèØ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int f[14][14];int a[14],cnt=0;///------------------head------------------inline void init(void)&#123; rep(i,0,9) f[1][i] = 1; f[1][4] = 0; rep(i,2,13) rep(j,0,9) &#123; if (j == 4) continue; rep(k,0,9) &#123; if ((k == 2 &amp;&amp; j == 6)) continue; f[i][j] += f[i-1][k]; &#125; &#125;&#125;inline int calc(int x)&#123; int ret = 0; cnt = 0; while(x)&#123;a[++cnt]=x%10;x/=10;&#125; rep(i,1,cnt-1) rep(j,1,9) ret += f[i][j]; rep(j,1,a[cnt]-1) ret += f[cnt][j]; per(i,cnt-1,1) &#123; rep(j,0,a[i]-1) if (j != 4 &amp;&amp; a[i+1] != 4) ret += f[i][j] * (!(a[i+1] == 6 &amp;&amp; j == 2)); if ((a[i+1] == 6 &amp;&amp; a[i] == 2) || a[i+1] == 4 || a[i] == 4) break; if (i==1) ++ret; &#125; return ret;&#125;signed main(signed argc, char *argv[])&#123; init(); int a,b; while(scanf("%lld %lld",&amp;a,&amp;b) == 2 &amp;&amp; (a+b)) printf("%lld\n",calc(b)-calc(a-1)+((!a)||(!b))); return 0;&#125;]]></content>
      <categories>
        <category>DP-Êï∞‰ΩçDP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåBZOJ1026/SCOI2009„ÄçwindyÊï∞ Êï∞‰Ωçdp]]></title>
    <url>%2F2018%2F07%2F10%2F%E3%80%8CBZOJ1026%E3%80%8Dwindy%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%2F</url>
    <content type="text"><![CDATA[Links there:BZOJ1026-windyÊï∞ È¢òÊÑèÂÆö‰πâ‰∏çÂê´ÂâçÂØºÈõ∂‰∏îÁõ∏ÈÇª‰∏§‰∏™Êï∞Â≠ó‰πãÂ∑ÆËá≥Â∞ë‰∏∫2ÁöÑÊ≠£Êï¥Êï∞Ë¢´Áß∞‰∏∫windyÊï∞.ÁªôÂá∫$A,B$,Ê±ÇÂú®$A,B$‰πãÈó¥windyÊï∞ÁöÑ‰∏™Êï∞. ÊÄùË∑Ø(Âà´ÈóÆÊàë‰∏∫‰ªÄ‰πàËøô‰πàÊôöÊâçÊù•Ë°•È¢ò) ‰ª§$f[i][j]$Ë°®Á§∫ÂΩìÂâçÊï∞Â≠óÊúâ$i$‰Ωç,ÊúÄÈ´ò‰ΩçÂèñÂà∞$j$‰ª•‰∏ãÁöÑÊª°Ë∂≥Êù°‰ª∂ÁöÑwindyÊï∞. ÂæàÊòéÊòæÊúâËΩ¨Áßª$f[i][j] = \sum f[i-1][k] * (|k - j|&gt;=2)$ È¢ÑÂ§ÑÁêÜÂá∫$f[i][j]$ÂêéÊù•Ëø≠‰ª£ÊàñËÄÖÈÄíÂΩíËÆ°ÁÆó$x$‰ª•ÂÜÖÁöÑÁ≠îÊ°àÂç≥ÂèØ Ê≥®ÊÑèÁªÜËäÇËÆ®ËÆ∫. Âú®ËÆ°ÁÆó$calc(x)$ÁöÑÊó∂ÂÄô,ÂÖàÂ§ÑÁêÜ$x$ÁöÑ‰ΩçÊï∞ÂíåÂêÑÊï∞‰ΩçÁöÑÂÄº. ‰ª§‰ΩçÊï∞‰∏∫$cnt$,ÂΩì$i&lt;=n-1$ÁöÑÊó∂ÂÄôÁõ¥Êé•ÁªüËÆ°. $j = ÊúÄÈ´ò‰Ωç-1$ Áã¨Á´ãËÆ°ÁÆó‰∏ÄÊ¨° rep(j,1,a[cnt]-1) ret+=f[cnt][j]; ÂØπ‰∫éÂâ©‰ΩôÁöÑ‰ΩçÊï∞$ret += f[i][j],cnt-1\geq i \geq 1 ,0 \leq j \leq a[i] - 1$. ÁÑ∂ÂêéË¶Å‰øùËØÅ$|a[i]-a[i+1] |&gt;= 2$,Âê¶ÂàôÁõ¥Êé•ÈÄÄÂá∫. Â∑Æ‰∏çÂ§öÂ∞±ËøôÊ†∑‰∫Ü. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int a[15],cnt=0,f[15][15];///------------------head------------------inline void init(void)&#123; rep(i,0,9) f[1][i]=1; rep(i,2,13) rep(j,0,9) rep(k,0,9) if (abs(k-j)&gt;=2) f[i][j] += f[i-1][k];&#125;inline int calc(int x)&#123; cnt=0; int ret=0; while(x)&#123;a[++cnt]=x%10;x/=10;&#125; rep(i,1,cnt-1) rep(j,1,9) ret+=f[i][j]; rep(j,1,a[cnt]-1) ret+=f[cnt][j]; per(i,cnt-1,1)&#123; rep(j,0,a[i]-1) ret+=f[i][j]*(abs(a[i+1]-j)&gt;=2); if (abs(a[i]-a[i+1])&lt;2) break; if (i==1) ++ret; &#125; return ret;&#125;signed main(signed argc, char *argv[])&#123; init(); int a=read(),b=read(); printf("%lld\n",calc(b)-calc(a-1)); return 0;&#125;]]></content>
      <categories>
        <category>DP-Êï∞‰ΩçDP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåZJOI2007„Äç‰ªìÂ∫ìÂª∫ËÆæ -ÊñúÁéá‰ºòÂåñdp]]></title>
    <url>%2F2018%2F07%2F10%2F%E3%80%8CZJOI2007%E3%80%8D%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[Links there:ZJOI2007-‰ªìÂ∫ìÂª∫ËÆæ È¢òÊÑèÂáëÂ≠óÊï∞ÊàëÊù•copy‰∏ÄÊ≥¢$L$ÂÖ¨Âè∏Êúâ$N$‰∏™Â∑•ÂéÇÔºåÁî±È´òÂà∞Â∫ïÂàÜÂ∏ÉÂú®‰∏ÄÂ∫ßÂ±±‰∏ä„ÄÇÂ¶ÇÂõæÊâÄÁ§∫ÔºåÂ∑•ÂéÇ$1$Âú®Â±±È°∂ÔºåÂ∑•ÂéÇ$N$Âú®Â±±ËÑö„ÄÇÁî±‰∫éËøôÂ∫ßÂ±±Â§Ñ‰∫éÈ´òÂéüÂÜÖÈôÜÂú∞Âå∫ÔºàÂπ≤Áá•Â∞ëÈõ®ÔºâÔºå$L$ÂÖ¨Âè∏‰∏ÄËà¨Êää‰∫ßÂìÅÁõ¥Êé•Â†ÜÊîæÂú®Èú≤Â§©Ôºå‰ª•ËäÇÁúÅË¥πÁî®„ÄÇÁ™ÅÁÑ∂Êúâ‰∏ÄÂ§©Ôºå$L$ÂÖ¨Âè∏ÁöÑÊÄªË£Å$L$ÂÖàÁîüÊé•Âà∞Ê∞îË±°ÈÉ®Èó®ÁöÑÁîµËØùÔºåË¢´ÂëäÁü•‰∏âÂ§©‰πãÂêéÂ∞ÜÊúâ‰∏ÄÂú∫Êö¥Èõ®Ôºå‰∫éÊòØ$L$ÂÖàÁîüÂÜ≥ÂÆöÁ¥ßÊÄ•Âú®Êüê‰∫õÂ∑•ÂéÇÂª∫Á´ã‰∏Ä‰∫õ‰ªìÂ∫ì‰ª•ÂÖç‰∫ßÂìÅË¢´Ê∑ãÂùè„ÄÇÁî±‰∫éÂú∞ÂΩ¢ÁöÑ‰∏çÂêåÔºåÂú®‰∏çÂêåÂ∑•ÂéÇÂª∫Á´ã‰ªìÂ∫ìÁöÑË¥πÁî®ÂèØËÉΩÊòØ‰∏çÂêåÁöÑ„ÄÇÁ¨¨$i$‰∏™Â∑•ÂéÇÁõÆÂâçÂ∑≤ÊúâÊàêÂìÅ$P_i$‰ª∂ÔºåÂú®Á¨¨$i$‰∏™Â∑•ÂéÇ‰ΩçÁΩÆÂª∫Á´ã‰ªìÂ∫ìÁöÑË¥πÁî®$C_i$„ÄÇÂØπ‰∫éÊ≤°ÊúâÂª∫Á´ã‰ªìÂ∫ìÁöÑÂ∑•ÂéÇÔºåÂÖ∂‰∫ßÂìÅÂ∫îË¢´ËøêÂæÄÂÖ∂‰ªñÁöÑ‰ªìÂ∫ìËøõË°åÂÇ®ËóèÔºåËÄåÁî±‰∫é$L$ÂÖ¨Âè∏‰∫ßÂìÅÁöÑÂØπÂ§ñÈîÄÂîÆÂ§ÑËÆæÁΩÆÂú®Â±±ËÑöÁöÑÂ∑•ÂéÇ$N$ÔºåÊïÖ‰∫ßÂìÅÂè™ËÉΩÂæÄÂ±±‰∏ãËøêÔºàÂç≥Âè™ËÉΩËøêÂæÄÁºñÂè∑Êõ¥Â§ßÁöÑÂ∑•ÂéÇÁöÑ‰ªìÂ∫ìÔºâÔºåÂΩìÁÑ∂ËøêÈÄÅ‰∫ßÂìÅ‰πüÊòØÈúÄË¶ÅË¥πÁî®ÁöÑÔºåÂÅáËÆæ‰∏Ä‰ª∂‰∫ßÂìÅËøêÈÄÅ$1$‰∏™Âçï‰ΩçË∑ùÁ¶ªÁöÑË¥πÁî®ÊòØ$1$„ÄÇÂÅáËÆæÂª∫Á´ãÁöÑ‰ªìÂ∫ìÂÆπÈáèÈÉΩÈÉΩÊòØË∂≥Â§üÂ§ßÁöÑÔºåÂèØ‰ª•ÂÆπ‰∏ãÊâÄÊúâÁöÑ‰∫ßÂìÅ„ÄÇ‰Ω†Â∞ÜÂæóÂà∞‰ª•‰∏ãÊï∞ÊçÆÔºö$1$ÔºöÂ∑•ÂéÇ$i$Ë∑ùÁ¶ªÂ∑•ÂéÇ$1$ÁöÑË∑ùÁ¶ª$Xi$ÔºàÂÖ∂‰∏≠X1=0Ôºâ;$2$ÔºöÂ∑•ÂéÇ$i$ÁõÆÂâçÂ∑≤ÊúâÊàêÂìÅÊï∞Èáè$P_i$;$3$ÔºöÂú®Â∑•ÂéÇ$i$Âª∫Á´ã‰ªìÂ∫ìÁöÑË¥πÁî®$C_i$;ËØ∑‰Ω†Â∏ÆÂä©$L$ÂÖ¨Âè∏ÂØªÊâæ‰∏Ä‰∏™‰ªìÂ∫ìÂª∫ËÆæÁöÑÊñπÊ°àÔºå‰ΩøÂæóÊÄªÁöÑË¥πÁî®ÔºàÂª∫ÈÄ†Ë¥πÁî®+ËøêËæìË¥πÁî®ÔºâÊúÄÂ∞è„ÄÇ ÊÄùË∑ØÊñúÁéáÈ¢òÂÅöÂ§ö‰∫ÜÁúüÁöÑÂ∞±Âá†Ê≠•Êé®Âá∫ÊñúÁéáÂÖ¨ÂºèÁª¥Êä§Âá∏ÂåÖÂ∞±Â•Ω‰∫Ü ‰ª£Á†ÅËøòÁü≠‚Ä¶ $O(n^3)$ÁöÑËΩ¨ÁßªËøòÊòØÈùûÂ∏∏ÊòæÁÑ∂ÁöÑ.Â±ïÂºÄÂêéÈÄöËøáÁª¥Êä§ÂâçÁºÄÂíåÂèØ‰ª•‰ºòÂåñÊàê$O(n^2)$ f[i] = max\{(f[j]+x[i]*(sump[i]-sump[j])-(sumpx[i]-sumpx[j]))\} + c[i]ËøôÊòØ‰∏Ä‰∏™ÂçÅÂàÜÂçÅÂàÜÊòæÁÑ∂ÁöÑÊñúÁéá‰ºòÂåñÁöÑÂΩ¢Âºè. ËÄÅÂ•óË∑Ø ÂÅáËÆæÊúâ$x&lt;y$, $x$ÁöÑËΩ¨ÁßªÊØî$y$Êõ¥‰ºò. ÈÇ£‰πàÊúâ \frac{(f[x]+sumpx[x])-(f[y]+sumpx[y])}{(sump[x]-sump[y])} < x[i]ÂØπËøô‰∏™ÂºèÂ≠êÁª¥Êä§‰∏Ä‰∏™Âá∏ÂåÖÂç≥ÂèØ.Êàë‰ª£Á†ÅÈáåËøòÊòØÁî®doubleÊù•Âà§Êñ≠ÊñúÁéáÁöÑ„ÄÇ ÂÖ∂ÂÆûÊîπÁî®ÂàÜÊØçÂàÜÂ≠êÂàÜÂà´Áõ∏‰πòÂà§Â§ßÂ∞èÁöÑÂÜôÊ≥ïÊõ¥‰∏•Ë∞®„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e6+100;int n,x[MAXN],c[MAXN],p[MAXN],f[MAXN];int K[MAXN],l,r;int sump[MAXN],sumpx[MAXN];///------------------head------------------inline double calc(int x,int y)&#123;return 1.0*((f[x]+sumpx[x])-(f[y]+sumpx[y]))/(sump[x]-sump[y]);&#125;signed main(signed argc, char *argv[])&#123; n=read(); rep(i,1,n) x[i]=read(),p[i]=read(),c[i]=read(); rep(i,1,n) sump[i] = sump[i-1] + p[i]; rep(i,1,n) sumpx[i] = sumpx[i-1] + x[i]*p[i]; // rep(i,1,n) printf("%lld %lld\n",sump[i],sumpx[i]); rep(i,1,n)&#123; while(l&lt;r &amp;&amp; calc(K[l],K[l+1]) &lt; x[i]) ++l; int j = K[l]; f[i] = f[j] + x[i] * (sump[i] - sump[j]) - (sumpx[i] - sumpx[j]) + c[i]; while(l&lt;r &amp;&amp; calc(K[r-1],K[r]) &gt; calc(K[r],i)) --r; //Áª¥Êä§‰∏ãÂá∏ÂåÖ.. K[++r] = i; &#125; printf("%lld\n",f[n]); return 0;&#125;]]></content>
      <categories>
        <category>DP-ÊñúÁéá‰ºòÂåñDP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåHDU3507„ÄçPrint Article ÊñúÁéá‰ºòÂåñdp]]></title>
    <url>%2F2018%2F07%2F10%2F%E3%80%8CHDU3507%E3%80%8DPrint-Article-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[Links there:HDU-3507-PrintArticle È¢òÊÑèÂ∞Ü$n$‰∏™Êï∞ÂàÜÊàêËã•Âπ≤‰∏™Âå∫Èó¥,ÊØè‰∏™Âå∫Èó¥ÁöÑ‰ª£‰ª∑‰∏∫Âå∫Èó¥ÂíåÁöÑÂπ≥ÊñπÂä†‰∏ä‰∏Ä‰∏™Â∏∏Êï∞$m$,Ê±ÇÊúÄÂ∞è‰ª£‰ª∑. ÊÄùË∑ØËÄÉËôëÊñúÁéá‰ºòÂåñ,ÂÅáËÆæÂ≠òÂú®$x&lt;y$, $x$ÁöÑËΩ¨ÁßªÊØî$y$‰ºò. ÂàôÊúâ \frac{(f[y] - f[x] + (sum[y]*sum[y]) - (sum[x]*sum[x])) }{2*(sum[x]-sum[y])} < sum[i]Áª¥Êä§‰∏Ä‰∏™Âá∏ÂåÖÂ∞±ÂÆå‰∫ã‰∫Ü. ÔºàÂÆå‰∫ÜÊàëÊõ¥Êñ∞ÂçöÂÆ¢Ë∂äÊù•Ë∂äÊáí‰∫Ü ÈöæÈÅìËøôÂ∞±ÊòØÈ¢ìÂ∫üÈÄÄÂΩπÁöÑÂâçÂÖÜÔºüÔºÅÔºâ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 5e5+100;int sum[MAXN],a[MAXN],M,N;int f[MAXN],q[MAXN];double calc(int x,int y)&#123;return 1.0 * (f[y] - f[x] + (sum[y]*sum[y]) - (sum[x]*sum[x]))/(2*(sum[x]-sum[y]));&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; scanf("%lld %lld",&amp;N,&amp;M); &#123; MM(f,0);MM(q,0); rep(i,1,N) sum[i] = sum[i-1] + read(); int l = 0,r = 0; rep(i,1,N) &#123; while(l &lt; r &amp;&amp; calc(q[l],q[l+1]) &lt; sum[i]) ++l; int j = q[l]; f[i] = f[j] + (sum[i] - sum[j]) * (sum[i] - sum[j]) + M; while(l &lt; r &amp;&amp; calc(q[r-1],q[r]) &gt; calc(q[r],i)) --r; q[++r] = i; &#125; printf("%lld\n",f[N]); &#125; return 0;&#125;/* Examples: *//**//**/]]></content>
      <categories>
        <category>DP-ÊñúÁéá‰ºòÂåñDP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[„ÄåAPIO2010„ÄçÁâπÂà´Ë°åÂä®Èòü-ÊñúÁéá‰ºòÂåñdp]]></title>
    <url>%2F2018%2F07%2F10%2F%E3%80%8CAPIO2010%E3%80%8D%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[Links there:APIO2010-ÁâπÂà´Ë°åÂä®Èòü È¢òÊÑèÁúãÈìæÊé•Âéª ÊáíÂæóÊê¨Ëøê ËøòÊòØÁÖß‰æãÂÖàÊé®‰∏Ä‰∏™ÊúÄÂº±ÁöÑ$O(n^3)$ÁöÑËΩ¨Áßª. ‰ª§$f[i]$Ë°®Á§∫ÂèñÂà∞Ââç$i$‰∏™Â£´ÂÖµÊó∂ÁöÑÊúÄÂ§ßÊàòÊñóÂäõ,ËÄÉËôëÊûö‰∏æ$[j+1,i]$Âå∫Èó¥Êñ∞Êàê‰∏ÄÈòü. f[i] = max\{f[j],calc(i,j)\},calc(i,j) = a(\sum_{k=j+1}^{i}x_i)^2+b\sum_{k=j+1}^{i}x_i+c)ËøôÊ†∑ÁöÑËΩ¨ÁßªÂèØ‰ª•ÂÜç‰ºòÂåñÂâçÁºÄÂíåÂæóÂà∞$O(n^2)$ÁöÑËΩ¨Áßª. ËÄÉËôëÊñúÁéá‰ºòÂåñ. ÂÅáËÆæÂ≠òÂú®$j &gt; k$,$j$ÁöÑËΩ¨ÁßªÊØî$k$‰ºò.ÔºàËøôÈáåÁöÑ$x[i]$Â∑≤ÁªèÊòØÂâçÁºÄÂíåÂï¶Ôºâ f[j]+Ax[j]^{2}-2Ax[i]x[j]-Bx[j] > f[k]+Ax[k]^{2}-2Ax[i]x[k]-Bx[k]ÁßªÈ°π„ÄÇ 2Ax[i](x[j]-x[k]) < (f[j]+Ax[j]^{2}-Bx[j])-(f[k]+Ax[k]^{2}-Bx[k])ÁÑ∂ÂêéÂ∞±ÂèØ‰ª•ÊñúÁéá‰ºòÂåñÂï¶. x[i] < \frac{(f[j]+Ax[j]^{2}-Bx[j])-(f[k]+Ax[k]^{2}-Bx[k])}{2A(x[j]-x[k])}ÁÑ∂ÂêéÁª¥Êä§‰∏Ä‰∏™‰∏ãÂá∏ÂåÖÂ∞±ÂèØ‰ª•Âï¶. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,b,a) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e6+100;int sum[MAXN],a,b,c,x[MAXN],n;int f[MAXN],q[MAXN];inline int calc(int x)&#123;return x*x*a+b*x+c;&#125;inline int UP(int x,int y)&#123;return ((f[x]+a*sum[x]*sum[x]-b*sum[x])-(f[y]+a*sum[y]*sum[y]-b*sum[y]));&#125;inline int DOWN(int x,int y)&#123;return 2LL*a*(sum[x]-sum[y]);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(); a=read(),b=read(),c=read(); rep(i,1,n) sum[i] = sum[i-1] + read(); int l = 0,r = 0; rep(i,1,n)&#123; while(l &lt; r &amp;&amp; UP(q[l],q[l+1]) &lt;= sum[i] * DOWN(q[l],q[l+1])) ++l; int j = q[l]; f[i] = f[j] + calc(sum[i]-sum[j]); while(l &lt; r &amp;&amp; UP(q[r-1],q[r]) * DOWN(q[r],i) &gt;= UP(q[r],i) * DOWN(q[r-1],q[r])) --r; q[++r] = i; &#125; //rep(i,1,n) printf("%lld ",f[i]); printf("%lld\n",f[n]); return 0;&#125;]]></content>
      <categories>
        <category>DP-ÊñúÁéá‰ºòÂåñDP</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåAtcoder„ÄçARC075 E - Meaningful Mean]]></title>
    <url>%2F2018%2F06%2F30%2F%E3%80%8CAtcoder%E3%80%8DARC075-E-Meaningful-Mean%2F</url>
    <content type="text"><![CDATA[h fake qÂÆâÂà©ÁöÑÈ¢ò. Links there:ARC075E È¢òÊÑè:ÁªôÂá∫‰∏Ä‰∏™Èïø‰∏∫$N$ÁöÑÂ∫èÂàó ,Ê±ÇÂá∫ÊâÄÊúâÁöÑËøûÁª≠Â∫èÂàó,Êª°Ë∂≥‰ªñ‰ª¨ÁöÑÁÆóÊúØÂπ≥ÂùáÊï∞Â∞è‰∫éÁ≠â‰∫é$K$. ËåÉÂõ¥:$N\leq 200000,1 \leq A_i \leq 10^9,1 \leq K \leq 10^9$ ÂàÜÊûê:È¶ñÂÖàÂèØ‰ª•ËÄÉËôëÁÆÄÂåñÈóÆÈ¢ò,Â∞ÜÊØè‰∏Ä‰∏™Êï∞ÂÖàÂáèÂéª$K$,ÂÜçÁª¥Êä§‰∏Ä‰∏™ÂâçÁºÄÂíå$sum$,ÈÇ£‰πàÈóÆÈ¢òÁÆÄÂåñÊàêÊ±ÇÂá∫ÊâÄÊúâÂØπ$(l,r)$‰ΩøÂæó$sum(r)-sum(l-1) \geq 0$.ÈÇ£‰πàÊàë‰ª¨Ê±ÇÂá∫ÊâÄÊúâ$sum$‰∏≠ÁöÑÈ°∫Â∫èÂØπ,‰πüÂ∞±ÊòØÊª°Ë∂≥$i&lt;j,sum[i]&lt;sum[j]$ÁöÑ‰∏™Êï∞Â∞±Ë°å‰∫Ü,Êàë‰ª¨ÂèØ‰ª•Áî®Ê†ëÁä∂Êï∞ÁªÑÊù•Áª¥Êä§Ëøô‰∏™‰∏úË•ø.Ê≥®ÊÑèÁ¶ªÊï£Âåñ. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;#define lowbit(x) (x&amp;-x)inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 2e5 + 100;int n,k,a[MAXN],s[MAXN],ans = 0;int C[MAXN];vector&lt;int&gt;v;inline void add(int x,int d)&#123;for(int i=x;i&lt;MAXN;i+=lowbit(i)) C[i]+=d;&#125;inline int Gsum(int x)&#123;int ret = 0;for (int i=x;i&gt;=1;i-=lowbit(i)) ret += C[i]; return ret;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(); k=read(); rep(i,1,n) a[i]=read()-k,s[i]=s[i-1]+a[i]; rep(i,0,n) v.pb(s[i]); sort(v.begin(),v.end()); v.resize(unique(v.begin(),v.end())-v.begin()); rep(i,0,n) s[i]=lower_bound(v.begin(),v.end(),s[i])-v.begin()+1; rep(i,0,n)&#123; ans += Gsum(s[i]); add(s[i],1); &#125; printf("%lld\n",ans); return 0;&#125;/* Examples: *//*7 2610203040302010*//*13*/]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåLOJ6277-6285„ÄçÊï∞ÂàóÂàÜÂùóÂÖ•Èó®ÂÇªÈÄºÈ¢ò]]></title>
    <url>%2F2018%2F06%2F28%2F%E3%80%8CLOJ6277-6285%E3%80%8D%E6%95%B0%E5%88%97%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8%E5%82%BB%E9%80%BC%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Á™ÅÁÑ∂ÊÉ≥Ëµ∑‰πãÂâçÂ∞±ÊÉ≥ÂÅöÁöÑÂàÜÂùóÁªÉ‰π†. Áé∞Âú®ÂÅöËµ∑Êù•ÁúüÁöÑÊÑüËßâÂ•ΩÂÇªÈÄºÂïä. ÂàÜÂùóÊö¥ÂäõÁæéÂ≠¶ ÊúâÊó∂ÂÄôËä±ÈáåËÉ°Âì®ÁöÑÊï∞ÊçÆÁªìÊûÑÂá∫ÈîÖÁöÑÊó∂ÂÄô‰πüÁÆóÊòØ ‰∏ÄÁßçË°•ÊïëÊñπÊ≥ïÂêß. ÂàÜÂùó‰ª£Á†Å‰∏çÈïø‰πüÊØîËæÉÂ•ΩÂÜô,Ê†πÊçÆhzwerÁöÑblog,ÂàÜÂùóÊó∂‰∏ÄÂÆöË¶ÅÊÉ≥ÊÉ≥ËøôÂá†‰∏™ÈóÆÈ¢ò: ÂØπ‰∫éÊØèÊ¨°Âå∫Èó¥Êìç‰ΩúÔºö 1.‰∏çÂÆåÊï¥ÁöÑÂùó ÁöÑ$O(\sqrt{n})$‰∏™ÂÖÉÁ¥†ÊÄé‰πàÂ§ÑÁêÜ? 2.$O(\sqrt{n})$‰∏™ Êï¥Âùó ÊÄé‰πàÂ§ÑÁêÜ? 3.Ë¶ÅÈ¢ÑÂ§ÑÁêÜ‰ªÄ‰πà‰ø°ÊÅØÔºàÂ§çÊùÇÂ∫¶‰∏çËÉΩË∂ÖËøáÂêéÈù¢ÁöÑÊìç‰ΩúÔºâ? ÂàÜÂùóÂú®Â§ßÊï∞ÊçÆ‰∏ãÂæàÂÆπÊòìÊâæÂá∫ÈîÖ. ‰∏ÄËà¨Êü•ÈîôÂ∞±ÂàÜ‰∏çÂêåÂ§ßÂ∞èÁöÑÂùóÂ∞±Â•ΩÂï¶. ÊàëË¥¥ÂÆå‰ª£Á†ÅÂ∞±Ë∑ë! ÂàÜÂùóÂÖ•Èó®1 Âå∫Èó¥Âä†Ê≥ï ÂçïÁÇπÊü•ÂÄºÊ≤°Èîô Ê†ëÁä∂Êï∞ÁªÑÂêåÂ≠¶‰ªäÂ§©ËØ∑‰Ω†Âùê‰∏ãÔºÅ 1234567891011121314151617181920212223242526272829303132333435363738394041//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 5e4+10;int sum_B[251],ref[MAXN],a[MAXN],n,m;int refer_blk(int x)&#123;return (x-1)/m+1;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read();MM(sum_B,0); m=sqrt(n+0.5); rep(i,1,n) a[i]=read(); rep(i,1,n)&#123; int opt=read(),l=read(),r=read(),c=read(); if (opt) &#123;printf("%lld\n",a[r]+sum_B[refer_blk(r)]);continue;&#125; int L = refer_blk(l),R = refer_blk(r); if (L == R) &#123;rep(j,l,r) a[j] += c; continue;&#125; rep(j,L+1,R-1) sum_B[j] += c; rep(j,l,refer_blk(l)*m) a[j] += c; rep(j,(refer_blk(r)-1)*m+1,r) a[j] += c; &#125; return 0;&#125; ÂàÜÂùóÂÖ•Èó®2 Âå∫Èó¥Âä†Ê≥ï Ê±ÇÂå∫Èó¥Â∞è‰∫écÁöÑÂÖÉÁ¥†‰∏™Êï∞Ê≤°Èîô Ê†ëÁä∂Êï∞ÁªÑÂêåÂ≠¶ÊÇ®ËøòÊòØÂùê‰∏ãÂêß 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define int long longinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 8e4+100;const int MAXM = 500;struct Blks&#123; vector&lt;int&gt;v; int add; int query(int x)&#123;int q = lower_bound(v.begin(),v.end(),x-add)-v.begin();return q;&#125;&#125;Blk[MAXM];int n,a[MAXN],m,cnt=0,p=1,D;int refer_blk(int x)&#123;return (x-1)/m+1;&#125;void Reset(int x)&#123; Blk[x].v.clear(); rep(i,(x-1)*m+1,x*m) Blk[x].v.pb(a[i]); sort(Blk[x].v.begin(),Blk[x].v.end());&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read();D=n; m=sqrt(n); rep(i,1,n) &#123;a[i]=read();Blk[refer_blk(i)].v.push_back(a[i]);&#125; rep(i,1,m) sort(Blk[i].v.begin(),Blk[i].v.end()); //rep(k,1,n) &#123;for (auto it : Blk[k].v) printf("%lld ",it); puts("");&#125; rep(ss,1,D)&#123; //printf("%lld\n",o); //rep(k,1,n) &#123;for (auto it : Blk[k].v) printf("%lld ",it); puts("");&#125; int opt,l,r,c; opt=read(),l=read(),r=read(),c=read(); int L = refer_blk(l),R = refer_blk(r); if (opt) &#123; int ret = 0; rep(i,l,min(m*L,r)) ret += (Blk[L].add + a[i] &lt; c * c); if (L != R) rep(i,(R-1)*m+1,r) ret += (Blk[R].add + a[i] &lt; c * c); rep(i,L+1,R-1) ret += Blk[i].query(c*c); // cerr &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; c &lt;&lt; endl; printf("%lld\n",ret); &#125; else &#123; rep(i,l,min(m*L,r)) a[i] += c; Reset(L); if (L != R) &#123;rep(i,(R-1)*m+1,r) a[i] += c;Reset(R);&#125; rep(i,L+1,R-1) Blk[i].add += c; &#125; &#125; return 0;&#125; ÂàÜÂùóÂÖ•Èó®3 Âå∫Èó¥Âä†Ê≥ï Êü•ÊâæÂâçÈ©±1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+10;const int MAXM = 500+50;//----------head----------int n,M;int v[MAXN],BL[MAXN],atag[MAXN];set&lt;int&gt;Sets[MAXM];void add(int a,int b,int c)&#123; for(int i=a;i&lt;=min(BL[a]*M,b);i++) &#123; Sets[BL[a]].erase(v[i]); v[i]+=c; Sets[BL[a]].insert(v[i]); &#125; if(BL[a]!=BL[b]) &#123; for(int i=(BL[b]-1)*M+1;i&lt;=b;i++) &#123; Sets[BL[b]].erase(v[i]); v[i]+=c; Sets[BL[b]].insert(v[i]); &#125; &#125; for(int i=BL[a]+1;i&lt;=BL[b]-1;i++) atag[i]+=c;&#125;int query(int a,int b,int c)&#123; int Ret=-1; for(int i=a;i&lt;=min(BL[a]*M,b);i++) &#123; int val=v[i]+atag[BL[a]]; if(val&lt;c)Ret=max(val,Ret); &#125; if(BL[a]!=BL[b])for(int i=(BL[b]-1)*M+1;i&lt;=b;i++)&#123;int val=v[i]+atag[BL[b]];if(val&lt;c)Ret=max(val,Ret);&#125; for(int i=BL[a]+1;i&lt;=BL[b]-1;i++)&#123;int x=c-atag[i];set&lt;int&gt;::iterator it=Sets[i].lower_bound(x);if(it==Sets[i].begin())continue;--it;Ret=max(Ret,*it+atag[i]);&#125; return Ret;&#125;signed main(signed argc, char *argv[])&#123; n=read();M=sqrt(n+0.5); for(int i=1;i&lt;=n;i++)v[i]=read(); for(int i=1;i&lt;=n;i++) &#123; BL[i]=(i-1)/M+1; Sets[BL[i]].insert(v[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; int f=read(),a=read(),b=read(),c=read(); if(f==0)add(a,b,c); if(f==1)printf("%lld\n",query(a,b,c)); &#125; return 0;&#125; ÂàÜÂùóÂÖ•Èó®4 Âå∫Èó¥Âä†Ê≥ï Âå∫Èó¥Ê±ÇÂíåÂÖ∂ÂÆûÂ§öÁªüËÆ°‰∏™sum‰ø°ÊÅØÂ∞±Â•Ω‰∫Ü 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define RG register#define rep(i,a,b) for(RG int i=a;i&lt;=b;i++)#define per(i,a,b) for(RG int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline char gc()&#123; static char now[1&lt;&lt;16],*S,*T; if(S==T) &#123;T=(S=now)+fread(now,1,1&lt;&lt;16,stdin); if(S==T) return EOF;&#125; return *S++;&#125;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=gc(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=gc();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=gc();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 8e4+100;const int MAXM = 300+50;int n,m,a[MAXN],add[MAXM],sum[MAXM];inline int refer_blk(int x)&#123;return (x-1)/m+1;&#125;signed main(signed argc, char *argv[])&#123; n=read(),m=sqrt(n+0.5); rep(i,1,n) a[i]=read(),sum[refer_blk(i)] += a[i]; rep(op,1,n)&#123; int opt=read(),l=read(),r=read(),c=read(); int L = refer_blk(l),R = refer_blk(r); if(!opt)&#123; rep(i,l,min(r,L*m)) a[i] += c,sum[L] += c; if (L != R) rep(i,(R-1)*m+1,r) a[i] += c,sum[R] += c; rep(i,L+1,R-1) add[i] += c; &#125; else&#123; int ret = 0; rep(i,l,min(r,L*m)) ret += a[i] + add[L]; if (L != R) rep(i,(R-1)*m+1,r) ret += a[i] + add[R]; rep(i,L+1,R-1) ret += sum[i] + m * add[i]; printf("%lld\n",ret % (c+1)); &#125; &#125; return 0;&#125; ÂàÜÂùóÂÖ•Èó®5 Âå∫Èó¥ÂºÄÊñπ Âå∫Èó¥Ê±ÇÂíåÂ∞±ÊòØÂà©Áî®‰∏Ä‰∏™Êï∞Âú®ÊúâÈôêÊ¨°ÂÜÖ(Ê†πÊçÆËåÉÂõ¥ÊúÄÂ§ö5~6Ê¨°)‰∏ÄÂÆöÂèØ‰ª•Ë¢´ÂºÄÊñπÊàê1ÁªôÊï¥‰∏™ÂùóÊâìÊ†áËÆ∞ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 8e4+100;const int MAXM = 4e2+10;int n,m,sum[MAXM],f[MAXM],a[MAXN];inline int refer_blk(int x)&#123;return (x-1)/m+1;&#125;inline void Upd_in_blk(int x)&#123; if (f[x]) return ; f[x] = 1; sum[x] = 0; rep(i,(x-1)*m+1,x*m) &#123; a[i] = sqrt(a[i] + 0.5); sum[x] += a[i]; f[x] = a[i] &gt; 1 ? 0 : f[x]; &#125;&#125;signed main(signed argc, char *argv[])&#123; n=read(),m=sqrt(n+0.5); rep(i,1,n) a[i]=read(),sum[refer_blk(i)] += a[i]; rep(op,1,n)&#123; int opt=read(),l=read(),r=read(),c=read(); int L=refer_blk(l),R=refer_blk(r); if(!opt)&#123; rep(i,l,min(r,L*m)) sum[L] -= a[i],a[i] = sqrt(a[i] + 0.5),sum[L] += a[i]; if (L != R) rep(i,(R-1)*m+1,r) sum[R] -= a[i],a[i] = sqrt(a[i] + 0.5),sum[R] += a[i]; rep(i,L+1,R-1) Upd_in_blk(i); &#125; else&#123; int ans = 0; rep(i,l,min(r,L*m)) ans += a[i]; if(L != R) rep(i,(R-1)*m+1,r) ans += a[i]; rep(i,L+1,R-1) ans += sum[i]; printf("%lld\n",ans); &#125; &#125; return 0;&#125; ÂàÜÂùóÂÖ•Èó®6 ÂçïÁÇπÊèíÂÖ• ÂçïÁÇπÊ±ÇÂÄºÂèØ‰ª•ÊâîÈìæË°® ‰ΩÜÊòØÂàÜÂùóÊàë‰ª¨ÂèØ‰ª•ËµÑÁì∑Êõ¥Â§öÁöÑÂå∫Èó¥Êìç‰Ωú Êú¨Êù•ÁöÑÂÅöÊ≥ïÊòØÊâæÂà∞Êñ∞ÂÖÉÁ¥†ÊâÄÂú®ÁöÑÂùóÁÑ∂ÂêéÊö¥ÂäõÂêëÂè≥ÁßªÂä® ‰ΩÜÊòØÁé©ÊÑèÊâÄÊúâÊìç‰ΩúÈÉΩÊîæÂú®Âêå‰∏Ä‰∏™ÂùóÊÄé‰πàÂäûÔºü ‰∏çÈöæÂèëÁé∞ÊØèÊ¨°ÈáçÊûÑÂùóÊòØ$O(n)$ÁöÑ ÈÇ£‰πàÊàë‰ª¨Â¢ûÂä†$\sqrt{n}$‰∏™ÂÖÉÁ¥†Â∞±ÈáçÊûÑ‰∏ÄÊ¨°Âùó ‰ΩøÂæóÊâÄÊúâÁöÑÂùóÂ§ßÂ∞èÂùáË°° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 1e5+100;const int MAXM = 400+10;int n,m,a[MAXN],M;inline int refer_blk(int x)&#123;return (x-1)/M+1;&#125;vector&lt;int&gt;v[MAXM];int buc[MAXN&lt;&lt;1],head = 0;pair&lt;int,int&gt; query(int x)&#123; int xx = 1; while(x &gt; v[xx].size()) x -= v[xx].size(),++xx; return make_pair(xx,x-1);&#125;inline void Reset(void)&#123; head = 0; rep(i,1,m)&#123; for (auto j = v[i].begin(); j != v[i].end(); j++) buc[++head] = *j; v[i].clear(); &#125; int mm = sqrt(head); rep(i,1,head) v[(i-1)/mm+1].push_back(buc[i]); m=(head-1)/mm+1;&#125;void ins(int x,int d)&#123; pair&lt;int,int&gt; t = query(x); int f1 = t.fi,f2 = t.se; v[f1].insert(v[f1].begin()+f2,d); if(v[f1].size() &gt; 20 * M) Reset();&#125;//insert x to pos dsigned main(signed argc, char *argv[])&#123; // freopen("a1.in","r",stdin); // freopen("my.out","w",stdout); n=read(),M=sqrt(n+0.5); rep(i,1,n) a[i]=read(); rep(i,1,n) v[refer_blk(i)].pb(a[i]); m = (n - 1) / M + 1; rep(op,1,n)&#123; int opt = read(),l = read(),r = read(),c = read(); if (!opt) &#123;ins(l,r);&#125; else &#123;pair&lt;int,int&gt;t = query(r);int f1 = t.fi,f2 = t.se;printf("%lld\n",v[f1][f2]);&#125; &#125; return 0;&#125; ÂàÜÂùóÂÖ•Èó®7 Âå∫Èó¥Âä†Ê≥ï Âå∫Èó¥‰πòÊ≥ï ÂçïÁÇπËØ¢ÈóÆÊ≥®ÊÑè‰ºòÂÖàÂ∫¶Â∞±Ë°å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+100;const int MAXM = 400+50;int n,m,a[MAXN],mul[MAXM],add[MAXM];///------------------head------------------const int Mod = 1e4+7;inline int refer_blk(int x)&#123;return (x-1)/m+1;&#125;inline void Reset(int x)&#123; rep(i,(x-1)*m+1,min(x*m,n)) a[i]=(a[i]*mul[x]+add[x])%Mod; add[x] = 0; mul[x] = 1;&#125;signed main(signed argc, char *argv[])&#123; n=read(),m=sqrt(n+0.5); rep(i,1,n) a[i]=read(); rep(i,1,refer_blk(n)) mul[i] = 1; rep(op,1,n)&#123; int opt=read(),l=read(),r=read(),c=read(); int L = refer_blk(l),R = refer_blk(r); if (!opt) &#123; Reset(L); rep(i,l,min(r,m*L)) a[i] += c,a[i] %= Mod; if (L != R) &#123;Reset(R); rep(i,(R-1)*m+1,r) a[i] += c,a[i] %= Mod;&#125; rep(i,L+1,R-1) &#123;add[i] += c; add[i] %= Mod;&#125; &#125; else if (opt == 1)&#123; Reset(L); rep(i,l,min(r,m*L)) a[i] *= c,a[i] %= Mod; if (L != R) &#123;Reset(R); rep(i,(R-1)*m+1,r) a[i] *= c,a[i] %= Mod;&#125; rep(i,L+1,R-1) &#123;add[i] *= c; add[i] %= Mod;mul[i] *= c;mul[i] %= Mod;&#125; &#125; else printf("%lld\n",(a[r]*mul[R]+add[R])%Mod); &#125; return 0;&#125; ÂàÜÂùóÂÖ•Èó®8 Âå∫Èó¥‰øÆÊîπ Âå∫Èó¥ËØ¢ÈóÆÊå∫ÂÇªÈÄºÁöÑ. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+100;const int MAXM = 400+50;int n,m,a[MAXN],f[MAXM];///------------------head------------------const int Mod = 1e4+7;inline int refer_blk(int x)&#123;return (x-1)/m+1;&#125;inline void Reset(int x)&#123; if (f[x]==-1) return ; rep(i,(x-1)*m+1,min(x*m,n)) a[i]=f[x]; f[x]=-1;&#125;signed main(signed argc, char *argv[])&#123; MM(f,-1); n=read(),m=sqrt(n+0.5); rep(i,1,n) a[i]=read(); rep(op,1,n)&#123; int l=read(),r=read(),c=read(); int L = refer_blk(l),R = refer_blk(r),ans = 0; Reset(L); rep(i,l,min(L*m,r)) &#123;ans += a[i] == c; if (a[i] != c) a[i] = c;&#125; if (L != R) &#123; Reset(R); rep(i,(R-1)*m+1,r) &#123;ans += a[i] == c; if (a[i] != c) a[i] = c;&#125; &#125; rep(i,L+1,R-1)&#123; if (f[i] != -1) &#123; if (f[i] == c) ans += m; else f[i] = c; &#125; else &#123; rep(j,(i-1)*m+1,i*m)&#123;ans += a[j] == c; if(a[j] != c) a[j] = c;&#125; f[i] = c; &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125; ÂàÜÂùóÂÖ•Èó®9 Âå∫Èó¥‰ºóÊï∞Êü•ËØ¢Á¶ªÁ∫øÁâàÊú¨‰∏çÈöæÊÉ≥Âà∞ ‰ΩÜ‰ºº‰πéÂèØ‰ª•Âú®Á∫øËµÑÁì∑Â∏¶‰øÆÊìç‰ΩúÔºü bzoj2724‰∫ÜËß£‰∏Ä‰∏ã 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 1e5+10;const int MAXM = 500+10;int n,m,id,v[MAXN],f[MAXM][MAXM];map&lt;int,int&gt;mp;int val[MAXM],cnt[MAXM];vector&lt;int&gt;ve[MAXM];inline int refer_blk(int x)&#123;return (x-1)/m+1;&#125;void pre(int x)&#123; memset(cnt,0,sizeof(cnt)); int mx=0,ans=0; for(int i=(x-1)*m+1;i&lt;=n;i++) &#123; cnt[v[i]]++; int t=refer_blk(i); if(cnt[v[i]]&gt;mx||(cnt[v[i]]==mx&amp;&amp;val[v[i]]&lt;val[ans])) ans=v[i],mx=cnt[v[i]]; f[x][t]=ans; &#125;&#125;int query(int l,int r,int x)&#123; int t=upper_bound(ve[x].begin(),ve[x].end(),r)-lower_bound(ve[x].begin(),ve[x].end(),l); return t;&#125;int query(int a,int b)&#123; int ans,mx; ans=f[refer_blk(a)+1][refer_blk(b)-1]; mx=query(a,b,ans); for(int i=a;i&lt;=min(refer_blk(a)*m,b);i++) &#123; int t=query(a,b,v[i]); if(t&gt;mx||(t==mx&amp;&amp;val[v[i]]&lt;val[ans]))ans=v[i],mx=t; &#125; if(refer_blk(a)!=refer_blk(b)) for(int i=(refer_blk(b)-1)*m+1;i&lt;=b;i++) &#123; int t=query(a,b,v[i]); if(t&gt;mx||(t==mx&amp;&amp;val[v[i]]&lt;val[ans]))ans=v[i],mx=t; &#125; return ans;&#125;signed main(signed argc, char *argv[])&#123; n=read();m=sqrt(n+0.5); rep(i,1,n)&#123;v[i]=read();if(!mp[v[i]])&#123;mp[v[i]]=++id;val[id]=v[i];&#125; v[i]=mp[v[i]];ve[v[i]].push_back(i); &#125;; rep(i,1,refer_blk(n)) pre(i); rep(i,1,n)&#123;int a=read(),b=read();if(a&gt;b)swap(a,b);printf("%lld\n",val[query(a,b)]);&#125; return 0;&#125;]]></content>
      <categories>
        <category>ÂàÜÂùó</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåNOI2014„ÄçÈ≠îÊ≥ïÊ£ÆÊûó]]></title>
    <url>%2F2018%2F06%2F26%2F%E3%80%8CNOI2014%E3%80%8D%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[NOI2014-È≠îÊ≥ïÊ£ÆÊûó Links there:NOI2014MogicForest È¢òÊÑè:ÁªôÂá∫‰∏Ä‰∏™Êó†ÂêëÂõæ,ÊØè‰∏ÄÊù°ËæπÊúâ‰∏§‰∏™ÊùÉÂÄº$A_i,B_i$ Ë¶ÅÊ±Ç‰ªé$1$ËäÇÁÇπË∑ëÂà∞$n$ËäÇÁÇπÁöÑÂèØËÉΩË∑ØÂæÑ‰∏ä,Ê±ÇÂá∫ÊúÄÂ∞èÁöÑ$A_i+B_i$ ÊÄùË∑Ø: È¶ñÂÖàÂØπËæπËøõË°åÊéíÂ∫è,ÂæàÊòæÁÑ∂ÁöÑÈíàÂØπÊüê‰∏™ÂèòÈáè($A$ÊàñËÄÖ$B$)ÂÖ≥ÈîÆÂ≠óÊéíÂ∫è. ÁÑ∂ÂêéÁî®$LCT$Âä®ÊÄÅÁª¥Êä§‰∏Ä‰∏™MST.ÊØèÊ¨°ÊâæËæπÁöÑÊó∂ÂÄô,Â¶ÇÊûú‰∏§‰∏™ÁÇπÂ∑≤ÁªèËøûÁªì,ÈÇ£‰πàÂú®ËØ•Êç¢‰∏äÊâæÂà∞ÊúÄÂ§ßÂÄºÂπ∂Êç¢ÊàêÊ¨°Â§ßÂÄº,ÁâπÂà´ÁöÑ,Â¶ÇÊûú1,nËÅîÈÄö,ÂàôËØ¥ÊòéÊúâË∑ØÂæÑÂ≠òÂú®,Êàë‰ª¨Êõ¥Êñ∞Á≠îÊ°à.ËøôÊ†∑Â∞±ÂÅöÂà∞‰∫ÜÂä®ÊÄÅÁª¥Êä§. ‰∏äËø∞‰∏∫Ê≠£Â∏∏$LCT$ÂÅöÊ≥ï. ‰ΩÜÊòØÂê¨Â§ßÁà∑‰ª¨ËÆ≤ËøôÈ¢òÂèØ‰ª•Áî®$SPFA$ÁöÑ$O(ÁéÑÂ≠¶)$Â§çÊùÇÂ∫¶Ê∞¥Êéâ. ‰∏™‰∫∫ÊÑüËßâÂÖ∂ÂÆûÂ¶ÇÊûúÊï∞ÊçÆÂá∫ÁöÑÊØîËæÉÂº∫ÁöÑËØùÂèØ‰ª•Âç°Êéâ$SPFA$ÁöÑ,‰ΩÜÊòØ‰º∞ËÆ°Âá∫È¢ò‰∫∫‰πüÊ≤°ÊÉ≥Âà∞ÈÇ£‰πàÂ§öÂêß‚Ä¶ ÔºàmdË∞É‰∫ÜÂçäÂ§©‰∏Ä‰∏™pushupÂÜôÈîô‰∫ÜÔºâ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define lc ch[u][0]#define rc ch[u][1]const int INF = 0x3f3f3f3f;const int MAXN = 5e4+10;const int MAXM = 1e5+10;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv( int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int n,m,F[MAXN&lt;&lt;1];int getf(int x)&#123;return x==F[x]?x:F[x]=getf(F[x]);&#125;struct Edges&#123; int u,v,A,B; inline bool operator &lt; (const Edges &amp;b) const &#123; return (A==b.A)?(B&lt;b.B):A&lt;b.A; &#125; inline void Rd(void)&#123;u=read(),v=read(),A=read(),B=read();&#125;&#125;E[MAXM&lt;&lt;1];struct LinkCutTree&#123; int ch[MAXN&lt;&lt;2][2],fa[MAXN&lt;&lt;2],rev[MAXN&lt;&lt;2],sum[MAXN&lt;&lt;2],mx[MAXN&lt;&lt;2],w[MAXN&lt;&lt;2]; inline bool isRson(int u)&#123;return ch[fa[u]][1] == u;&#125; inline bool isRoot(int u)&#123;return (ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u);&#125; inline void Reverse(int u)&#123;rev[u] ^= 1;swap(lc,rc);&#125; inline void pushdown(int u)&#123;if(rev[u])&#123;if (lc) Reverse(lc); if(rc)Reverse(rc); rev[u]=0;&#125;&#125; inline void pushup(int u)&#123; mx[u]=u; mx[u]=w[mx[u]]&lt;w[mx[lc]]?mx[lc]:mx[u]; mx[u]=w[mx[u]]&lt;w[mx[rc]]?mx[rc]:mx[u]; &#125; inline void Update(int u)&#123;if (!isRoot(u)) Update(fa[u]); pushdown(u);&#125;/* ----------- Splay part ------------*/ inline void rotate(int u)&#123; int fau = fa[u],ffau = fa[fau],d = isRson(u); fa[u]=ffau; if (!isRoot(fau)) ch[ffau][isRson(fau)] = u; fa[ch[fau][d] = ch[u][d^1]] = fau; fa[ch[u][d^1] = fau] = u; pushup(fau); pushup(u); &#125; inline void Splay(int u)&#123; //ËæπSplayËæπÂêëÊ†π‰º†ÈÄí‰ø°ÊÅØ Update(u); for (;(!isRoot(u));rotate(u))&#123; if (!isRoot(fa[u])) rotate(isRson(fa[u])==isRson(u)?fa[u]:u); &#125; &#125;/* ----------- LCT part ------------*/ inline void access(int u)&#123; for(int f = 0; u; f = u,u = fa[u])&#123; Splay(u); rc = f; pushup(u); &#125; &#125; inline void makeroot(int u)&#123;access(u);Splay(u);Reverse(u);&#125; inline int find(int u)&#123;access(u);Splay(u);while(lc)pushdown(u),u=lc;return u;&#125; inline void split(int x,int y)&#123;makeroot(x);access(y);Splay(y);&#125; inline void link(int x,int y)&#123;makeroot(x);fa[x]=y;&#125; inline void cut(int u,int v)&#123;split(u,v);if(fa[u]==v&amp;&amp;(!rc))fa[u]=ch[v][0]=0;pushup(v);&#125; inline int query(int u,int v)&#123;makeroot(u);access(v);Splay(v);return mx[ch[v][0]];&#125;&#125;LCT;int ans = INF;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),m=read(); rep(i,1,m) E[i].Rd(); sort(E+1,E+m+1); rep(i,1,m)&#123; int u=E[i].u,v=E[i].v,A=E[i].A,B=E[i].B; LCT.w[n+i]=B; LCT.mx[n+i] = n+i; if(LCT.find(u)==LCT.find(v)) &#123; int ret = LCT.query(u,v); if (LCT.w[ret] &gt; B)&#123; LCT.cut(ret,E[ret-n].u); LCT.cut(ret,E[ret-n].v); LCT.link(u,n+i); LCT.link(v,n+i); &#125; &#125; else&#123;LCT.link(u,n+i); LCT.link(v,n+i);&#125; if (LCT.find(1)==LCT.find(n)) ans = min(ans,A+LCT.w[LCT.query(1,n)]); &#125; printf("%d\n",ans==INF?-1:ans); return 0;&#125;]]></content>
      <categories>
        <category>Âä®ÊÄÅÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåZJOI2008„ÄçÊ†ëÁöÑÁªüËÆ°]]></title>
    <url>%2F2018%2F06%2F26%2F%E3%80%8CZJOI2008%E3%80%8D%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[ZJOI-2008Ê†ëÁöÑÁªüËÆ° Links there:ZJOI-2008Ê†ëÁöÑÁªüËÆ° È¢òÊÑè:Ë¶ÅÊ±ÇÂÆûÁé∞Ëøô‰∫õÊìç‰Ωú I. CHANGE u t : ÊääÁªìÁÇπuÁöÑÊùÉÂÄºÊîπ‰∏∫t II. QMAX u v: ËØ¢ÈóÆ‰ªéÁÇπuÂà∞ÁÇπvÁöÑË∑ØÂæÑ‰∏äÁöÑËäÇÁÇπÁöÑÊúÄÂ§ßÊùÉÂÄº III. QSUM u v: ËØ¢ÈóÆ‰ªéÁÇπuÂà∞ÁÇπvÁöÑË∑ØÂæÑ‰∏äÁöÑËäÇÁÇπÁöÑÊùÉÂÄºÂíå Ê≥®ÊÑèÔºö‰ªéÁÇπuÂà∞ÁÇπvÁöÑË∑ØÂæÑ‰∏äÁöÑËäÇÁÇπÂåÖÊã¨uÂíåvÊú¨Ë∫´ ÂÖ∂ÂÆûÊòØ‰∏™Ê†ëÂâñË£∏È¢òÂïä.‰ΩÜÊòØÂ≠¶‰∫Ü$LCT$ËøôÁßçÊõ¥Âº∫Â§ßÁöÑ‰∏úË•ø‰πàÂÜôËµ∑Êù•Â≤Ç‰∏çÊòØÊõ¥ËàíÊúç. ÂÖ∂ÂÆûÂíåÊ®°ÊùøÈ¢òÂ∑Æ‰∏çÂ§ö,Ê≥®ÊÑèpushupÊõ¥Êñ∞ÁöÑÊó∂ÂÄôÁª¥Êä§‰ø°ÊÅØÊó∂,ÊØè‰∏™ËäÇÁÇπÁöÑMxÂíåSumÂÖàËµãÂÄº‰∏∫Ëá™Â∑±ÁÑ∂ÂêéÂª∫Á´ãËôöÊãüÁÇπMx[0]=-INF. ÂÇªÈÄºÁöÑÊàëËøòÊòØË∞É‰∫ÜÂ•Ω‰πÖÊâçÂØπ,ÂèëÁé∞Ëá™Â∑±Ë∞É$LCT$ÁöÑÈ¢òÁúüÂøÉ‰∏çÁÜü. P.S. LCTÂÜôËµ∑Êù•ÊØîÊ†ëÂâñ‰ºòÁæéÂ§ö‰∫Ü. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define lc ch[u][0]#define rc ch[u][1]inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------const int MAXN = 3e4+10;int n,m,u[MAXN],v[MAXN];inline char NextChar(void)&#123; char c=getchar(); while(!isalpha(c)) c=getchar(); return c;&#125;struct LinkCutTree&#123; int ch[MAXN][2],sum[MAXN],rev[MAXN],w[MAXN],fa[MAXN],Mx[MAXN]; inline bool isRson(int u)&#123;return ch[fa[u]][1] == u;&#125; inline bool isRoot(int u)&#123;return (ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u);&#125; inline void Reverse(int u)&#123;rev[u] ^= 1;swap(lc,rc);&#125; inline void pushdown(int u)&#123;if(rev[u])&#123;if (lc) Reverse(lc); if(rc)Reverse(rc); rev[u]=0;&#125;&#125; inline void pushup(int u)&#123;sum[u]=sum[lc]+sum[rc]+w[u];Mx[u]=max(w[u],max(Mx[lc],Mx[rc]));&#125; inline void Update(int u)&#123;if (!isRoot(u)) Update(fa[u]); pushdown(u);&#125;/* ----------- Splay part ------------*/ inline void rotate(int u)&#123; int fau = fa[u],ffau = fa[fau],d = isRson(u); fa[u]=ffau; if (!isRoot(fau)) ch[ffau][isRson(fau)] = u; fa[ch[fau][d] = ch[u][d^1]] = fau; fa[ch[u][d^1] = fau] = u; pushup(fau); pushup(u); &#125; inline void Splay(int u)&#123; Update(u); for (;(!isRoot(u));rotate(u))&#123; if (!isRoot(fa[u])) rotate(isRson(fa[u])==isRson(u)?fa[u]:u); &#125; &#125;/* ----------- LCT part ------------*/ inline void access(int u)&#123; for(int f = 0; u; f = u,u = fa[u])&#123; Splay(u); rc = f; pushup(u); &#125; &#125; inline void makeroot(int u)&#123;access(u);Splay(u);Reverse(u);&#125; inline int find(int u)&#123;access(u);Splay(u);while(lc)pushdown(u),u=lc;return u;&#125; inline void split(int x,int y)&#123;makeroot(x);access(y);Splay(y);&#125; inline void link(int x,int y)&#123;makeroot(x);fa[x]=y;&#125; inline void cut(int u,int v)&#123;split(u,v);if(fa[u]==v&amp;&amp;(!rc))fa[u]=ch[v][0]=0;pushup(v);&#125;&#125;LCT;signed main(signed argc, char *argv[])&#123; //freopen("1.in","r",stdin); //freopen("my.out","w",stdout); n=read();rep(i,1,n-1)&#123;u[i]=read(),v[i]=read();&#125; rep(i,1,n) LCT.w[i]=read(),LCT.sum[i]=LCT.Mx[i]=LCT.w[i]; LCT.Mx[0]=-INT_MAX; rep(i,1,n-1) LCT.link(u[i],v[i]); m=read(); rep(i,1,m) &#123; char xx=NextChar(); while(isalpha(xx)) &#123;char t=xx;xx=getchar();if(!isalpha(xx))&#123;xx=t;break;&#125;&#125; int x=read(),y=read(); switch(xx)&#123; case 'X':&#123;LCT.split(x,y);printf("%d\n",LCT.Mx[y]);break;&#125; case 'M':&#123;LCT.split(x,y);printf("%d\n",LCT.sum[y]);break;&#125; case 'E':&#123;LCT.Splay(x);LCT.w[x]=y;LCT.pushup(x);break;&#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Âä®ÊÄÅÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåSDOI2008„ÄçCave Ê¥ûÁ©¥ÂãòÊµã]]></title>
    <url>%2F2018%2F06%2F26%2F%E3%80%8CSDOI2008%E3%80%8DCave-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[SDOI2008-Ê¥ûÁ©¥ÂãòÊµã Links there:SDOI2008 Cave È¢òÊÑè:Ë¶ÅÊ±Ç‰Ω†ÂÆûÁé∞Âè™ÊúâLink‰∏éCutÊìç‰ΩúÁöÑ,ÁúüÊ≠£ÊÑè‰πâ‰∏äÁöÑ,$LCT$! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define lc ch[u][0]#define rc ch[u][1]//#define localinline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;inline char NextChar(void)&#123; char c = getchar(); while(!isalpha(c)) c=getchar(); return c;&#125;///------------------head------------------int n,m,op;const int MAXN = 1e4+10;struct LinkCutTree&#123; int ch[MAXN][2],sum[MAXN],rev[MAXN],w[MAXN],fa[MAXN]; inline bool isRson(int u)&#123;return ch[fa[u]][1] == u;&#125; inline bool isRoot(int u)&#123;return (ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u);&#125; inline void Reverse(int u)&#123;rev[u] ^= 1;swap(lc,rc);&#125; inline void pushdown(int u)&#123;if(rev[u])&#123;if (lc) Reverse(lc); if(rc)Reverse(rc); rev[u]=0;&#125;&#125; inline void pushup(int u)&#123;sum[u]=sum[lc]^sum[rc]^w[u];&#125; inline void Update(int u)&#123;if (!isRoot(u)) Update(fa[u]); pushdown(u);&#125;/* ----------- Splay part ------------*/ inline void rotate(int u)&#123; int fau = fa[u],ffau = fa[fau],d = isRson(u); fa[u]=ffau; if (!isRoot(fau)) ch[ffau][isRson(fau)] = u; fa[ch[fau][d] = ch[u][d^1]] = fau; fa[ch[u][d^1] = fau] = u; pushup(fau); pushup(u); &#125; inline void Splay(int u)&#123; //ËæπSplayËæπÂêëÊ†π‰º†ÈÄí‰ø°ÊÅØ Update(u); for (;(!isRoot(u));rotate(u))&#123; if (!isRoot(fa[u])) rotate(isRson(fa[u])==isRson(u)?fa[u]:u); &#125; &#125;/* ----------- LCT part ------------*/ inline void access(int u)&#123; for(int f = 0; u; f = u,u = fa[u])&#123; Splay(u); rc = f; pushup(u); &#125; &#125; inline void makeroot(int u)&#123;access(u);Splay(u);Reverse(u);&#125; inline int find(int u)&#123;access(u);Splay(u);while(lc)pushdown(u),u=lc;return u;&#125; inline void split(int x,int y)&#123;makeroot(x);access(y);Splay(y);&#125; inline void link(int x,int y)&#123;makeroot(x);fa[x]=y;&#125; inline void cut(int u,int v)&#123;split(u,v);if(fa[u]==v&amp;&amp;(!rc))fa[u]=ch[v][0]=0;pushup(v);&#125;&#125;LCT;signed main(signed argc, char *argv[])&#123; #ifdef local freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif n=read(),m=read(); rep(i,1,m)&#123; char x = NextChar();// putchar(x);puts(""); switch(x)&#123; case 'C':&#123; int x=read(),y=read(); if (LCT.find(x) != LCT.find(y)) LCT.link(x,y); break; &#125; case 'Q':&#123; int x=read(),y=read(); printf("%s\n",LCT.find(x)==LCT.find(y)?"Yes":"No"); break; &#125; default :&#123; int x=read(),y=read(); if (LCT.find(x) == LCT.find(y)) LCT.cut(x,y); break; &#125; &#125; &#125; #ifdef local fclose(stdin); fclose(stdout); #endif return 0;&#125;]]></content>
      <categories>
        <category>Âä®ÊÄÅÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåLink-Cut-Trees„ÄçLCTÂä®ÊÄÅÊ†ëÂ≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2018%2F06%2F14%2F%E3%80%8CLink-Cut-Trees%E3%80%8DLCT%E5%8A%A8%E6%80%81%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Ë∞É‰∫ÜÂ∑Æ‰∏çÂ§ö‰∏Ä‰∏ãÂçà+Êôö‰∏äÂ∑¶Âè≥ÁöÑLCT,ÁÆóÊòØÊêûÊáÇ‰∫Ü ÊÑüË∞¢qxqÂ∑®Áà∑ÁöÑÂÄæÊÉÖËÆ≤Ëß£ÔºàÂ§ßÈõæ LCTËÆ≤Á®ø(Êó†ÊØîÁîüÂä®Áâà) LUOGU P3690 LCT[Ê®°Êùø] Link there 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se secondusing namespace std;#define lc ch[u][0]#define rc ch[u][1]inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------int n,m,op;const int MAXN = 3e5+10;struct LinkCutTree&#123; int ch[MAXN][2],sum[MAXN],rev[MAXN],w[MAXN],fa[MAXN]; inline bool isRson(int u)&#123;return ch[fa[u]][1] == u;&#125; inline bool isRoot(int u)&#123;return (ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u);&#125; inline void Reverse(int u)&#123;rev[u] ^= 1;swap(lc,rc);&#125; inline void pushdown(int u)&#123;if(rev[u])&#123;if (lc) Reverse(lc); if(rc)Reverse(rc); rev[u]=0;&#125;&#125; inline void pushup(int u)&#123;sum[u]=sum[lc]^sum[rc]^w[u];&#125; inline void Update(int u)&#123;if (!isRoot(u)) Update(fa[u]); pushdown(u);&#125;/* ----------- Splay part ------------*/ inline void rotate(int u)&#123; int fau = fa[u],ffau = fa[fau],d = isRson(u); fa[u]=ffau; if (!isRoot(fau)) ch[ffau][isRson(fau)] = u; fa[ch[fau][d] = ch[u][d^1]] = fau; fa[ch[u][d^1] = fau] = u; pushup(fau); pushup(u); &#125; inline void Splay(int u)&#123; //ËæπSplayËæπÂêëÊ†π‰º†ÈÄí‰ø°ÊÅØ Update(u); for (;(!isRoot(u));rotate(u))&#123; if (!isRoot(fa[u])) rotate(isRson(fa[u])==isRson(u)?fa[u]:u); &#125; &#125;/* ----------- LCT part ------------*/ inline void access(int u)&#123; for(int f = 0; u; f = u,u = fa[u])&#123; Splay(u); rc = f; pushup(u); &#125; &#125; inline void makeroot(int u)&#123;access(u);Splay(u);Reverse(u);&#125; inline int find(int u)&#123;access(u);Splay(u);while(lc)pushdown(u),u=lc;return u;&#125; inline void split(int x,int y)&#123;makeroot(x);access(y);Splay(y);&#125; inline void link(int x,int y)&#123;makeroot(x);fa[x]=y;&#125; inline void cut(int u,int v)&#123;split(u,v);if(fa[u]==v&amp;&amp;(!rc))fa[u]=ch[v][0]=0;pushup(v);&#125;&#125;LCT;signed main(signed argc, char *argv[])&#123; n=read(),m=read(); rep(i,1,n) LCT.w[i]=read(); rep(i,1,m) &#123; int op=read(),x=read(),y=read(); switch(op)&#123; case 0:&#123;LCT.split(x,y);printf("%d\n",LCT.sum[y]);break;&#125; case 1:&#123;if(LCT.find(x) != LCT.find(y))LCT.link(x,y);break;&#125; case 2:&#123;if(LCT.find(x) == LCT.find(y))LCT.cut(x,y);break;&#125; case 3:&#123;LCT.w[x]=y;LCT.Splay(x);break;&#125; &#125; &#125; return 0;&#125; Ââ©‰∏ãÁöÑ‰∏≠ËÄÉ‰πãÂêéÂÜçË°•Ëæ£.]]></content>
      <categories>
        <category>Âä®ÊÄÅÊ†ë</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåCodeforces„Äç Educational Round 45 Â§çÁõò]]></title>
    <url>%2F2018%2F06%2F10%2F%E3%80%8CCodeforces%E3%80%8D-Educational-Round-45%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[Ê≤°Êúâ‰ΩìÈ™å. È¶ñÂÖàÁΩëÈÄüÂ∞±Âæà‰∏çÁªôÂäõ Ë£∏ËøûpingÂú®1000ms+,LOSSÁàÜÁÇ∏,Ê†πÊú¨Êâì‰∏çÂºÄ. ‰∫éÊòØÁßëÂ≠¶‰∏äÁΩëÂãâÂº∫ÂèØ‰ª•Êâì. ÂûÉÂúæER,Êï¥Â§©Âç°‰∫∫ÁöÑÂ∞èÊï∞ÊçÆÂá∫Âá∫ È¢òÊÑè‰∏çÊòé‰∏çÁü•ÈÅìË¶ÅÊûÑÈÄ†ÁöÑÂõæÁöÑÊÄßË¥® Âç°Êàë‰∏Ä‰∏™Â§öÂ∞èÊó∂ÁöÑD,ÊúÄÂêéÂ∞±Êîπ‰∫Ü‰∏ÄË°å‰ª£Á†ÅËµõÂêé‰∏ÄÂèëACÔºàËµõÊó∂4ÂèëWAÔºâ,‰ΩìÈ™åÊûÅÂ∑ÆÔºÅ ÊéâRatingÊòØËÇØÂÆöÁöÑ. shit. :( ÂêéÊù•ÂèëÁé∞EÂéüÊù•ÊòØÂÇªÈÄºÈ¢ò F‰πü‰∏ÄÁúºÂèØÂÅöÁöÑÊ†∑Â≠ê mdzzÊàëÂÆåÂÆåÂÖ®ÂÖ®ÈîôÂ§±ELOÊú∫‰ºö ‰∏çÊòØÂÖàÊääÂÅö‰∫ÜÁöÑ‰∏¢‰∏äÊù•Âêß. A 12345678910111213141516171819202122232425262728293031323334353637383940//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; int n=read(),m=read(),a=read(),b=read(); if (!(n % m)) &#123;puts("0"); return 0;&#125; int x1 = n % m,x2 = m - x1; printf("%lld\n",min(x1 * b,x2 * a)); return 0;&#125;/* Examples: *//**//**/ B 123456789101112131415161718192021222324252627282930313233343536373839404142434445//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int maxn = 2e5+10;int n,k,a[maxn],b[maxn],c[maxn];pair&lt;int,int&gt;pa[maxn];///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),k=read(); rep(i,1,n) a[i]=read(),pa[i]=make_pair(a[i],i); int ans = 0; sort(pa+1,pa+n+1); rep(i,1,n) b[i]=pa[i].fi,c[i]=pa[i].se; rep(i,1,n) &#123;int tof = b[i],s; s = (upper_bound(b+1,b+n+1,tof+k) - b) - 1 - (upper_bound(b+1,b+n+1,tof)-b) + 1; if (s &gt; 0) ++ans;&#125; printf("%lld\n",n-ans); return 0;&#125;/* Examples: *//**//**/ C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 3e5+10;int n,ans = 0;map&lt;int,int&gt;buc;string a;pair&lt;int,int&gt; check(string a,int l)&#123; int lf = 0,rt = 0; int lneed=0; rep(i,0,l-1) &#123; if (lf == 0 &amp;&amp; a[i] == ')') &#123;++lneed;continue;&#125; lf += a[i] == '('; rt += a[i] == ')'; int x=min(lf,rt); lf -= x; rt -= x; &#125; return make_pair(lneed,lf);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; int n=read(); rep(i,1,n)&#123; int ret = 0; cin &gt;&gt; a; int l = a.length(); pair&lt;int,int&gt; Re = check(a,l); if (Re.fi &gt; 0 &amp;&amp; Re.se &gt; 0) continue; if (Re.fi == 0 &amp;&amp; Re.se == 0) ++buc[0]; else if (Re.fi != 0) ++buc[Re.fi]; else ++buc[-Re.se]; &#125; for (int i = 1; i &lt;= MAXN; i++) &#123; if (!buc[i] || !buc[-i]) continue; ans += buc[i] * buc[-i]; &#125; ans += buc[0] * buc[0]; printf("%lld",ans); return 0;&#125;/* Examples: *//**//**/ D ÊàëÊåÇÂº†ÂõæÂ∏åÊúõÊ≥•ËêåÊÑüÂèóÂà∞ÊàëÁöÑÁªùÊúõ ÂèØËÉΩÊòØÊàëËèúÂêß. ËµõÂêé‰∏ÄÂèëÂ∞±ÂØπÊàë‰πü‰∏çÁü•ÈÅìÊòØ‰ªÄ‰πàÊìç‰ΩúÂïä(Èõæ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int n,a,b,g[1001][1001],flag = 0;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),a=read(),b=read(); if (a != 1 &amp;&amp; b != 1) &#123;puts("NO"); return 0;&#125; if (n == 2 &amp;&amp; a == 1 &amp;&amp; b == 1) &#123;puts("NO"); return 0;&#125; if (n == 3 &amp;&amp; a == 1 &amp;&amp; b == 1) &#123;puts("NO"); return 0;&#125; if (a &gt; b) swap(a,b),flag = 1; for (int i = b; i &lt;= n - 1; i++) g[i][i+1] = g[i+1][i] = 1; if (!flag) rep(i,1,n) rep(j,1,n) &#123;if (i==j) continue; g[i][j]^=1;&#125; puts("YES"); rep(i,1,n) &#123; rep(j,1,n) printf("%d",g[i][j]); puts(""); &#125; return 0;&#125;/* Examples: *//**//**/ E 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e6+10;int n,m,k,x[MAXN],ans = LLONG_MAX;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(),m=read(),k=read(); while(m--)&#123; int t = read(); x[t] = 1; &#125; rep(i,0,n-1)&#123; if (x[i]) &#123; if (!i) x[i] = -1; else x[i] = x[i-1]; &#125; else x[i] = i; &#125; rep(i,1,k)&#123; int e1=0,e2=0,y; y=read(); while(e1 &lt; n)&#123; if (x[e1] &lt; 0 || x[e1] &lt;= e1 - i) break; e1 = i + x[e1]; ++e2; &#125; ans = (e1 &gt;= n) ? min(ans,y * e2) : ans; &#125; printf("%lld\n",ans==LLONG_MAX?-1:ans); return 0;&#125;/* Examples: *//**//**/ gg my friend. ÊòéÂ§©div2ËßÅ. ÊàëÁúüÁöÑÊØîËÄÅÁãóËøòËèú Âä†Ê≤π.]]></content>
      <categories>
        <category>ELO Record</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåPOJ-3237„ÄçTree]]></title>
    <url>%2F2018%2F06%2F10%2F%E3%80%8CPOJ-3237%E3%80%8DTree%2F</url>
    <content type="text"><![CDATA[POJ-3237 Description You are given a tree with N nodes. The tree‚Äôs nodes are numbered 1 through N and its edges are numbered 1 through N ‚àí 1. Each edge is associated with a weight. Then you are to execute a series of instructions on the tree. The instructions can be one of the following forms: CHANGE i v Change the weight of the ith edge to v NEGATE a b Negate the weight of every edge on the path from a to b QUERY a b Find the maximum weight of edges on the path from a to b Input The input contains multiple test cases. The first line of input contains an integer t (t ‚â§ 20), the number of test cases. Then follow the test cases.Each test case is preceded by an empty line. The first nonempty line of its contains N (N ‚â§ 10,000). The next N ‚àí 1 lines each contains three integers a, b and c, describing an edge connecting nodes a and b with weight c. The edges are numbered in the order they appear in the input. Below them are the instructions, each sticking to the specification above. A lines with the word ‚ÄúDONE‚Äù ends the test case. Output For each ‚ÄúQUERY‚Äù instruction, output the result on a separate line. Sample Input 12345678131 2 12 3 2QUERY 1 2CHANGE 1 3QUERY 1 2DONE Sample Output 1213 Ê†ëÂâñÁ†ÅÂÜúÈ¢ò,ÊòØÁúüÁöÑÈöæË∞É. ‰ºº‰πéfor (int i = head[u]; ~i; i = E[i].next)Âíåfor (int i = head[u]; i; i = E[i].next) ÊúâÂ∑ÆÂà´? Âùë‰∫ÜÊàëÂ•Ω‰πÖÂïä‚Ä¶ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230//my vegetable has exploded. :(#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;climits&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 21000+10;struct Edges&#123; int to,w,next;&#125;E[MAXN&lt;&lt;2];int cnt=0,dfs_cnt=0;struct SegmentTree&#123; int L,R,rev; int minn,maxx;&#125;tree[MAXN&lt;&lt;3];int fa[MAXN],sz[MAXN],hson[MAXN],dep[MAXN],top[MAXN],dfn[MAXN],head[MAXN],T,n,uu[MAXN],vv[MAXN],ww[MAXN];int R1[MAXN],R[MAXN];//Êò†Â∞Ñvoid addedge(int u,int v,int w)&#123; E[++cnt].to = v; E[cnt].w = w; E[cnt].next = head[u]; head[u]=cnt;&#125;inline void Reset(void)&#123; MM(hson,-1);MM(sz,0);MM(head,0); cnt=dfs_cnt=0;&#125;///------------------head------------------/*void dfs1(int u,int F,int depth)&#123; printf("%d %d %d\n",u,F,depth); sz[u]=1;fa[u]=F;dep[u]=depth; for(int i=head[u]; i; i=E[i].next) &#123; int v = E[i].to; if (v != F) &#123; R[v]=E[i].w; dfs1(v,u,depth+1); sz[u] += sz[v]; if((hson[u] == -1) || sz[hson[u]] &lt; sz[v]) hson[u] = v; &#125; &#125;&#125;*/void dfs1(int u, int father, int depth) &#123; dep[u] = depth; fa[u] = father; sz[u] = 1; for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != fa[u]) &#123; R[v] = E[i].w; dfs1(v, u, depth + 1); sz[u] += sz[v]; if (hson[u] == -1 || sz[v] &gt; sz[hson[u]]) hson[u] = v; &#125; &#125;&#125;void dfs2(int u,int t)&#123; dfn[u] = dfs_cnt++; top[u] = t; R1[dfn[u]] = R[u]; if (!hson[u]) return ; dfs2(hson[u],t); for (int i = head[u]; i; i = E[i].next)&#123; int v = E[i].to; if (v != fa[u] &amp;&amp; v != hson[u]) dfs2(v,v); &#125;&#125;void pushup(int o)&#123; tree[o].minn = min(tree[lc].minn,tree[rc].minn); tree[o].maxx = max(tree[lc].maxx,tree[rc].maxx);&#125;void Modify(int o)&#123; swap(tree[o].minn,tree[o].maxx); tree[o].maxx *= -1; tree[o].minn *= -1;&#125;void pushdown(int o)&#123; if (!tree[o].rev) return ; tree[lc].rev ^= 1; tree[rc].rev ^= 1; //‰∏ãÊîæÂèçËΩ¨Ê†áËÆ∞ Modify(lc); Modify(rc); tree[o].rev = 0;&#125;void Build(int o,int l,int r)&#123; tree[o].L = l,tree[o].R = r; tree[o].rev = 0; int m = (l + r) &gt;&gt; 1; if (l == r) tree[o].minn = tree[o].maxx = R1[l]; else &#123; Build(lc,l,m); Build(rc,m+1,r); pushup(o); &#125;&#125;void update(int o,int p,int z)&#123; if (p == tree[o].L &amp;&amp; p == tree[o].R) &#123;tree[o].minn = tree[o].maxx = z;&#125; else &#123; pushdown(o); int ll = tree[o].L,rr = tree[o].R,mid = (ll + rr) &gt;&gt; 1; if (p &lt;= mid) update(lc,p,z); else update(rc,p,z); pushup(o); &#125;&#125;void update2(int o,int l,int r )&#123; int L = tree[o].L,R = tree[o].R; if (L &gt;= l &amp;&amp; R &lt;= r)&#123; tree[o].rev ^= 1; Modify(o); return ; &#125; pushdown(o); int m = (L + R) &gt;&gt; 1; if (l &lt;= m) update2(lc,l,r); if (r &gt; m) update2(rc,l,r); pushup(o);&#125;void Maintain(int u,int v)&#123; int topu = top[u],topv = top[v]; while(topu != topv) &#123; if (dep[topu] &lt; dep[topv]) swap(u,v),swap(topu,topv); update2(1,dfn[topu],dfn[u]); u = fa[topu],topu = top[u]; &#125; if (u == v) return ; if (dep[u] &lt; dep[v]) swap(u,v); update2(1,dfn[v] + 1,dfn[u]);&#125;int query_on_tree(int o,int l,int r)&#123; int L = tree[o].L,R = tree[o].R; if (l &lt;= L &amp;&amp; R &lt;= r) return tree[o].maxx; if (l &gt; R || r &lt; L) return -INT_MAX; pushdown(o); return max(query_on_tree(lc,l,r),query_on_tree(rc,l,r));&#125;int Query_mx(int u,int v)&#123; if (u == v) return 0; int ans = -INT_MAX; int topu = top[u],topv = top[v]; while(topu != topv) &#123; if (dep[topu] &lt; dep[topv]) swap(u,v),swap(topu,topv); ans = max(ans,query_on_tree(1,dfn[topu],dfn[u])); u = fa[topu],topu = top[u]; &#125; if (u == v) return ans; if (dep[u] &lt; dep[v]) swap(u,v); return ans = max(ans,query_on_tree(1,dfn[v]+1,dfn[u]));&#125;signed main(signed argc, char *argv[])&#123; T=read(); while(T--)&#123; Reset(); n = read(); rep(i,1,n-1)&#123;uu[i]=read(),vv[i]=read(),ww[i]=read();addedge(uu[i],vv[i],ww[i]);addedge(vv[i],uu[i],ww[i]);&#125; /* for (int u = 1; u &lt;= n; u++)&#123; for (int i = head[u]; i; i = E[i].next) printf("%d -&gt; %d = %d\n",u,E[i].to,E[i].w); puts(""); &#125; */ dfs1(1,0,1); dfs2(1,1); Build(1,1,n); string op; while(cin &gt;&gt; op)&#123; if (op == "DONE") break; else if (op == "QUERY")&#123; int u=read(),v=read(); printf("%lld\n",Query_mx(u,v)); &#125; else if (op == "CHANGE")&#123; int m=read(),newv=read(); if (dep[uu[m]] &lt; dep[vv[m]]) swap(uu[m],vv[m]); update(1,dfn[uu[m]],newv); &#125; else &#123; int u=read(),v=read(); Maintain(u,v); &#125; &#125; &#125; return 0;&#125;/* Examples: *//*IN131 2 12 3 2QUERY 1 2CHANGE 1 3QUERY 1 2DONE*//*OUT13*/]]></content>
      <categories>
        <category>Âä®ÊÄÅÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåÊ†ëÈìæÂâñÂàÜ - Â≠¶‰π†Á¨îËÆ∞„Äç]]></title>
    <url>%2F2018%2F06%2F08%2F%E3%80%8C%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8D%2F</url>
    <content type="text"><![CDATA[Ê†ëÈìæÂâñÂàÜ‰ºº‰πéÊòØ‰∏™ÂæàÂº∫Â§ßÁöÑ‰∏úË•ø ÂèØÊÉúÊàë‰πãÂâç‰∏ç‰ºöÂïä ÊâÄ‰ª•Â∞±mark‰∏Ä‰∏ãÂïä ÂÆö‰πâÊ†ëÈìæÂâñÂàÜ ÁÆÄÁß∞Ê†ëÂâñ.ÂØπ‰∫é‰∏ÄËà¨ÁöÑÊ†ë‰∏äË∑ØÂæÑ/ÊùÉÂÄºÁöÑÈóÆÈ¢ò,TarjanÁöÑLCAÂú®Á∫øÊÄßÂÜÖÂ∞±ÂèØ‰ª•Âø´ÈÄüÊ±ÇËß£. Â¶ÇÊûúË¶Å‰øÆÊîπÁÇπÊùÉÊàñËÄÖËæπÊùÉÂë¢? Ê†ëÈìæÂâñÂàÜÂ∞±ÊòØÁî®Êù•Ëß£ÂÜ≥Âä®ÊÄÅ‰øÆÊîπÊ†ë‰∏äÊùÉÂÄºÂπ∂Ê±ÇËß£ÁöÑÈóÆÈ¢òÁöÑ ‰∏ÄËà¨Ê†ëÈìæÂâñÂàÜÊõ¥Êñ∞ÊùÉÂÄºÁöÑÂ§çÊùÇÂ∫¶‰∏∫$O(logn)$,ÁªüËÆ°Ë∑ØÂæÑ‰ø°ÊÅØÁöÑÂ§çÊùÇÂ∫¶‰∏∫$O((logn)^2)$ ÂÜÖÂÆπÊüê‰∫õ‰∏ÄÂÆöË¶ÅÁü•ÈÅìÁöÑÊ¶ÇÂøµ ÈáçËäÇÁÇπÔºöÂ≠êÊ†ëÁªìÁÇπÊï∞ÁõÆÊúÄÂ§öÁöÑËäÇÁÇπÔºõ ËΩªËäÇÁÇπÔºöÁà∂‰∫≤ËäÇÁÇπ‰∏≠Èô§‰∫ÜÈáçÁªìÁÇπ‰ª•Â§ñÁöÑËäÇÁÇπÔºõ ÈáçËæπÔºöÁà∂‰∫≤ËäÇÁÇπÂíåÈáçËäÇÁÇπËøûÊàêÁöÑËæπÔºõ ËΩªËæπÔºöÁà∂‰∫≤ËäÇÁÇπÂíåËΩªËäÇÁÇπËøûÊàêÁöÑËæπÔºõ ÈáçÈìæÔºöÁî±Â§öÊù°ÈáçËæπËøûÊé•ËÄåÊàêÁöÑË∑ØÂæÑÔºõ ËΩªÈìæÔºöÁî±Â§öÊù°ËΩªËæπËøûÊé•ËÄåÊàêÁöÑË∑ØÂæÑÔºõ Ëøô‰∫õ‰∏úË•øÊúâ‰∏Ä‰∏™ÊÄßË¥®. 1.‰∏ÄÊù°ÈáçÈìæÂú®Á∫øÊÆµÊ†ë‰∏äÊòØ‰∏ÄÊÆµËøûÁª≠ÁöÑÂå∫Èó¥„ÄÇ 2.‰∏Ä‰∏™ËäÇÁÇπÁöÑÈáçÂÑøÂ≠êÂ∞±ÊòØËøô‰∏™ËäÇÁÇπÁöÑÂ≠êËäÇÁÇπ‰∏≠Â≠êÊ†ëÊúÄÂ§ßÁöÑÁÇπ„ÄÇ ÊâÄ‰ª•Á¨¨‰∏ÄÊ¨°dfsÊ±ÇÂá∫ÈáçÂÑøÂ≠ê Á¨¨‰∫åÊ¨°ÈÄöËøádfsÊó∂Èó¥Êà≥(dfn),ÂæóÂá∫ËäÇÁÇπÊñ∞ÁºñÂè∑,Âπ∂‰∏îÂ∞ÜÂêÑ‰∏™ÈáçËäÇÁÇπËøûÊé•ÊàêÈáçÈìæÔºåËΩªËäÇÁÇπËøûÊé•ÊàêËΩªÈìæ Â∞ÜÈáçÈìæÔºàÂÖ∂ÂÆûÂ∞±ÊòØ‰∏ÄÊÆµÂå∫Èó¥ÔºâÁî®Êï∞ÊçÆÁªìÊûÑÔºà‰∏ÄËà¨ÊòØÊ†ëÁä∂Êï∞ÁªÑÊàñÁ∫øÊÆµÊ†ëÔºâÊù•ËøõË°åÁª¥Êä§ ‰∏∫ÊØè‰∏™ËäÇÁÇπËøõË°åÁºñÂè∑ÔºåÂÖ∂ÂÆûÂ∞±ÊòØDFSÂú®ÊâßË°åÊó∂ÁöÑÈ°∫Â∫èÔºàidÊï∞ÁªÑÔºâ ‰ª•ÂèäÂΩìÂâçËäÇÁÇπÊâÄÂú®ÈìæÁöÑËµ∑ÁÇπÔºàtopÊï∞ÁªÑÔºâÔºåËøòÊúâÂΩìÂâçËäÇÁÇπÂú®Ê†ë‰∏≠ÁöÑ‰ΩçÁΩÆÔºàrnkÊï∞ÁªÑÔºâ. 1234567891011121314//dfs1void dfs1(int u, int F, int depth) &#123; dep[u] = depth; fa[u] = F; siz[u] = 1; for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != fa[u]) &#123; //Â¶ÇÊûú‰∏çÊòØÁà∂ËäÇÁÇπÂ∞±ÁªßÁª≠Âêë‰∏ãÊâæËäÇÁÇπ dfs1(v, u, depth + 1); siz[u] += siz[v];//Âä†Â≠êÁªìÁÇπÁöÑsz if ((!hson[u]) || siz[v] &gt; siz[hson[u]]) hson[u] = v;//Â¶ÇÊûúÊ≤°ÊúâÈáçÂ≠©Â≠êÊàñËÄÖÊ≠§Â≠©Â≠êÁöÑszËæÉÂ§ßÂàôÊõ¥Êñ∞hson[u] &#125; &#125;&#125; 12345678910//dfs2void dfs2(int u, int t) &#123; dfn[u] = ++dfs_cnt; rnk[dfs_cnt] = u; top[u] = t;//Áª¥Êä§uÈ°∂ÁÇπÁöÑËäÇÁÇπt if (!hson[u]) return ;//‰∏çÊòØÈáçÂÑøÂ≠êÂ∞±return dfs2(hson[u], t);//ÁªßÁª≠Âêë‰∏ãÊâæÈáçÈìæ for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != hson[u] &amp;&amp; v != fa[u]) dfs2(v, v);//ÊâæÂÖ∂‰ªñÈùûu‰∏∫È°∂ÁÇπÁöÑÈìæ &#125;&#125; LUOGU P3384 Ê†ëÈìæÂâñÂàÜ[Ê®°Êùø] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define REP(i,a,b) for(int i=a;i&lt;=b;i++)#define PER(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long long#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1using namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 110000;struct Node &#123; int to, next;&#125; E[MAXN&lt;&lt;1];struct segmentTree &#123; int L, R; int sum, tag;&#125; tree[MAXN&lt;&lt;2];int head[MAXN], siz[MAXN], top[MAXN], hson[MAXN];int dep[MAXN], fa[MAXN], dfn[MAXN], rnk[MAXN];int N, M, R, A[MAXN], cnt = 0, dfs_cnt = 0,mod;inline void adde(int u, int v) &#123; E[++cnt].to = v; E[cnt].next = head[u]; head[u] = cnt;&#125;void dfs1(int u, int F, int depth) &#123; dep[u] = depth; fa[u] = F; siz[u] = 1; for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != fa[u]) &#123; dfs1(v, u, depth + 1); siz[u] += siz[v]; if ((!hson[u]) || siz[v] &gt; siz[hson[u]]) hson[u] = v; &#125; &#125;&#125;void dfs2(int u, int t) &#123; dfn[u] = ++dfs_cnt; rnk[dfs_cnt] = u; top[u] = t; if (!hson[u]) return ; dfs2(hson[u], t); for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != hson[u] &amp;&amp; v != fa[u]) dfs2(v, v); &#125;&#125;void Build(int o, int l, int r) &#123; tree[o].L = l; tree[o].R = r; if (l == r) tree[o].sum = A[rnk[l]]; else &#123; int mid = (l + r) &gt;&gt; 1; Build(lc, l , mid); Build(rc | 1, mid + 1, r); tree[o].sum = tree[lc].sum + tree[rc].sum; &#125;&#125;void pushdown(int o) &#123; tree[lc].sum += (tree[lc].R - tree[lc].L + 1) * tree[o].tag; tree[rc].sum += (tree[rc].R - tree[rc].L + 1) * tree[o].tag; tree[lc].tag += tree[o].tag; tree[rc].tag += tree[o].tag; tree[o].tag = 0;&#125;void update(int o, int x, int y, int z) &#123; if (tree[o].L &gt; y || tree[o].R &lt; x) return ; if (x &lt;= tree[o].L &amp;&amp; tree[o].R &lt;= y) &#123; tree[o].sum += (tree[o].R - tree[o].L + 1) * z; tree[o].tag += z; &#125; else &#123; if (tree[o].tag) pushdown(o); update(lc, x, y, z); update(rc, x, y, z); tree[o].sum = tree[lc].sum + tree[rc].sum; &#125;&#125;int query(int o, int x, int y) &#123; if (x &lt;= tree[o].L &amp;&amp; tree[o].R &lt;= y) return tree[o].sum; if (tree[o].L &gt; y || tree[o].R &lt; x) return 0; if (tree[o].tag) pushdown(o); return query(lc, x, y) + query(rc, x, y);&#125;void update_path(int u, int v, int z) &#123; int tu = top[u], tv = top[v]; while (tu != tv) &#123; if (dep[tu] &lt; dep[tv]) swap(u, v), swap(tu, tv); update(1, dfn[tu], dfn[u], z); u = fa[tu], tu = top[u]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); update(1, dfn[v], dfn[u], z);&#125;int query_path(int u, int v) &#123; int res = 0; int tu = top[u], tv = top[v]; while (tu != tv) &#123; if (dep[tu] &lt; dep[tv]) swap(u, v), swap(tu, tv); res += query(1, dfn[tu], dfn[u]); u = fa[tu], tu = top[u]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); return res + query(1, dfn[v], dfn[u]);&#125;signed main(signed argc, char *argv[]) &#123; N = read(), M = read(), R = read(), mod = read(); REP(i, 1, N) A[i] = read(); REP(i, 2, N) &#123; int u = read(), v = read(); adde(u, v); adde(v, u); &#125; dfs1(R, 0, 1); dfs2(R, R); //REP(i,1,N) printf("%d %d %d %d %d\n",i,fa[i],dfn[i],siz[i],dep[i]); Build(1, 1, N); while (M--) &#123; int opt = read(); switch (opt) &#123; case 1: &#123; int x = read(), y = read(); int z; scanf("%lld", &amp;z); update_path(x, y, z); break; &#125; case 2: &#123; int x = read(), y = read(); printf("%lld\n", query_path(x, y) % mod); break; &#125; case 3: &#123; int x = read(); int z; scanf("%lld", &amp;z); update(1, dfn[x], dfn[x] + siz[x] - 1, z); break; &#125; case 4: &#123; int x = read(); printf("%lld\n", query(1, dfn[x], dfn[x] + siz[x] - 1) % mod); &#125; &#125; &#125; return 0;&#125; POJ-2763 Âü∫‰∫éËæπÊùÉ‰øÆÊîπÁöÑÊ†ëÂâñ. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142//my vegetable has exploded. :(#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second// #define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;const int MAXN = 1e5+10;///------------------head------------------#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1int fa[MAXN],hson[MAXN],dep[MAXN],dfn[MAXN],rnk[MAXN],top[MAXN],sz[MAXN],val[MAXN];int head[MAXN],cnt=0,dfs_cnt=0;int n,m,s;struct Edge&#123; int u,v,val; inline void R()&#123; u=read();v=read();val=read(); &#125; Edge(int uu=0,int vv=0,int vval=0):u(uu),v(vv),val(vval)&#123;&#125;&#125;Edges[MAXN];struct E&#123; int to,next;&#125;E[MAXN&lt;&lt;1];struct SegmentTree&#123; int L,R,val;&#125;Tree[MAXN&lt;&lt;2];inline void adde(int u, int v) &#123; E[++cnt].to = v; E[cnt].next = head[u]; head[u] = cnt;&#125;void dfs1(int u, int father, int depth) &#123; dep[u] = depth; fa[u] = father; sz[u] = 1; for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != fa[u]) &#123; dfs1(v, u, dep[u]+1); sz[u] += sz[v]; if (hson[u] == -1 || sz[v] &gt; sz[hson[u]]) hson[u] = v; &#125; &#125;&#125;void dfs2(int u, int t) &#123; dfn[u] = ++dfs_cnt; rnk[dfs_cnt] = u; top[u] = t; if (!hson[u]) return ; dfs2(hson[u], t); for (int i = head[u]; i; i = E[i].next) &#123; int v = E[i].to; if (v != hson[u] &amp;&amp; v != fa[u]) dfs2(v, v); &#125;&#125;void pushup(int o)&#123;Tree[o].val = Tree[lc].val + Tree[rc].val;&#125;void build(int l,int r,int o)&#123; Tree[o].L = l; Tree[o].R = r; if (l == r) &#123;Tree[o].val = val[l]; return;&#125; int mid = (l + r) &gt;&gt; 1; build(l,mid,lc); build(mid+1,r,rc); pushup(o);&#125;void Update(int o,int v,int val)&#123; if (Tree[o].L == Tree[o].R) &#123;Tree[o].val = val; return ;&#125; int mid = (Tree[o].L + Tree[o].R) &gt;&gt; 1; if (v &lt;= mid) Update(lc,v,val); else Update(rc,v,val); pushup(o);&#125;int query(int o,int l,int r)&#123; if(Tree[o].L &gt;= l &amp;&amp; Tree[o].R &lt;= r) return Tree[o].val; int mid = (Tree[o].L + Tree[o].R) &gt;&gt; 1; if (r &lt;= mid) return query(lc,l,r); else if (l &gt; mid) return query(rc,l,r); else return query(lc,l,mid)+query(rc,mid+1,r);&#125;int Query(int u,int v)&#123; int tp1 = top[u],tp2 = top[v]; int ret = 0; while(tp1 != tp2)&#123; if (dep[tp1] &lt; dep[tp2]) &#123; swap(u,v); swap(tp1,tp2); &#125; ret += query(1,dfn[tp1],dfn[u]); u = fa[tp1]; tp1 = top[u]; &#125; if(u == v) return ret; if(dep[u] &gt; dep[v]) swap(u,v); ret += query(1,dfn[hson[u]],dfn[v]); return ret;&#125;signed main(signed argc, char *argv[])&#123; n=read(),m=read(),s=read(); rep(i,1,n-1)&#123;Edges[i].R();adde(Edges[i].u,Edges[i].v);adde(Edges[i].v,Edges[i].u);&#125; dfs1(1,0,1); dfs2(1,1); rep(i,1,n-1)&#123; if (dep[Edges[i].u] &lt; dep[Edges[i].v]) swap(Edges[i].u,Edges[i].v); val[dfn[Edges[i].u]] = Edges[i].val; &#125; build(1,dfs_cnt,1); rep(i,1,m)&#123; int op=read(),x,y; if(!op)&#123;x=read();printf("%d\n",Query(s,x));s=x;&#125; else&#123;x=read(),y=read();Update(1,dfn[Edges[x].u],y);&#125; &#125; return 0;&#125;/* Examples: *//*in3 3 11 2 12 3 20 21 2 30 3*//*out13*/ :Ôºâkarriganasta]]></content>
      <categories>
        <category>Âä®ÊÄÅÊ†ë</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåCodeforces„ÄçCF-Round485 Div2 Â§çÁõò]]></title>
    <url>%2F2018%2F05%2F30%2F%E3%80%8CCodeforces%E3%80%8DCF-Round485-Div2-%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[ÊàëËøôÁßçÂÇªÈÄºÈÄâÊâã‰πüÂè™ËÉΩÂÅöÂÅöDiv2ÁªÉÁªÉÊâã‰∫Ü‚Ä¶ ÈìæÊé•CF-Round485 Div2 ÊüêÂΩ©Á¨îÈÄâÊâãÁöÑRoom ÁÆóÊòØCFÊâìÂà∞Áé∞Âú®Ëá™Â∑±ÂèëÊå•ÁÆóÂ•ΩÁöÑÂêß..‰ΩÜÊòØ‰∏∫‰ªÄ‰πàÊâçÊ∂®‰∫Ü49ÂàÜÂïä‚Ä¶‰∏çËµÑÁì∑Âïä. ‰ª•ÂêéÊØèÊ¨°ÊØîËµõÈÉΩÂÜô‰∏ÄÊ¨°Â§çÁõòÂêß.ÔºàÊúâÂèØËÉΩÊàëÊáí‰∏çÊÉ≥ÂÜô ÂàíÊ∞¥ËÆ∞ËµõÂâçÂçäÂ§ú23:35ÂºÄÊâìÁöÑDiv2,ËÇùÂø´ÁàÜ‰∫Ü,ZhangZisuËøòÊúâGCC314Â§ßÁà∑Â∏¶ÊàëÈ£ûÂïäÂïäÂïäÂïäÂïä. ËµõÂâçÁñØÁãÇÊâìCodeSource(ÊªëÁ®Ω Â∞ùËØïÁùÄÁù°ÁùÄ‰ΩÜÊòØÊ≤°ÊàêÂäü,È≠îÁà™‰πüÊ≤°Âï¶,Êä±ÁùÄÂøÖÊéâ$rating$ÁöÑÂøÉÊâìÁöÑÊØîËµõ. Ëµõ‰∏≠A ‰∏ÄÁúãÂìáÁâπ‰πàÁöÑÊòØ Â§çËÅî3 ÁÅ≠Èú∏1ËÉåÊôØËØ∂!ÂÇªÈÄºÈ¢ò,ÊâãÈÄüËøòÊòØÊÖ¢ÂïäËä±‰∫Ü6min. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;string s[7] = &#123;"Reality","Power","Mind","Soul","Space","Time"&#125;;string wd[7] = &#123;"red","purple","yellow","orange","blue","green"&#125;;bool g[7];///------------------head------------------signed main(signed argc, char *argv[])&#123; MM(g,0); int n=read(),ans=0; while(n--)&#123; string s; cin &gt;&gt; s; rep(i,0,5) if (wd[i] == s) g[i] = 1; &#125; rep(i,0,5) ans += (!g[i]); cout &lt;&lt; ans &lt;&lt; endl; rep(i,0,5) if(!g[i]) cout &lt;&lt; s[i] &lt;&lt; endl; return 0;&#125; B. ÁªôÂá∫$x$,$y$,Ê±ÇÊØîËæÉ$x^y,y^x$ÁöÑÂ§ßÂ∞è. log‰∏Ä‰∏ã‰ªÄ‰πàÁöÑÂ∞±Â•Ω‰∫Ü.ÊÑöË†¢ÁöÑÊàëÂøò‰∫ÜÊç¢Â∫ïÂÖ¨Âºè. Âè™ËÉΩpow‰∫Ü.ÊàëËèúÁàÜ‰∫Ü. 1234567891011121314151617181920212223242526272829303132333435363738394041424344//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;const double eps = 1e-8;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;double x,y,r;///------------------head------------------signed main(signed argc, char *argv[])&#123; cin &gt;&gt; x &gt;&gt; y; if (x == 2 &amp;&amp; y == 4)&#123;puts("="); return 0;&#125; if (x == 4 &amp;&amp; y == 2)&#123;puts("="); return 0;&#125; if (x &lt; y)&#123; double a1 = x,a2 = pow(y,x/y); printf("%c\n",(a1-a2 &gt; eps) ? '&gt;' : '&lt;'); &#125; else if (x == y) &#123;puts("=");&#125; else &#123; double a1 = x,a2 = pow(y,x/y); printf("%c\n",(a1-a2 &gt; eps) ? '&gt;' : '&lt;'); &#125; return 0;&#125; C. ÁªôÂÆö$n,{ s_i} {c_i},1 \leq n \leq 3000$,Ê±Ç‰∏âÂÖÉÁªÑ$(i,j,k)$Êª°Ë∂≥$s_i &lt; s_j &lt; s_k,i&lt;j&lt;k$ Ê±ÇÂá∫ÊúÄÂ∞èÁöÑ$c_i+c_j+c_k$ ‰ºº‰πéÊòØ‰∏™DPÂïä,ÊÉ≥‰∫ÜÂ•Ω‰πÖÁöÑÂ•áÊÄ™ÂÅöÊ≥ï(‰∫åÂàÜ+RMQ) ÁÑ∂ÂêéÂèëÁé∞ÊòØ‰∏™$O(n^2)$ÁöÑDP ÂïäÂïäÂïäÂïäÂïä 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define INF 1000000000000001LLusing namespace std;const int maxn = 3003;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;int n,a[maxn],b[maxn],f[maxn][4];int d[maxn][100];void RMQ_init(int a[],int n)&#123; for (int i = 1; i &lt;= n; i++) d[i][0] = a[i]; for (int j = 1; (1&lt;&lt;j) &lt;= n; j++) for (int i = 0; i + (1&lt;&lt;j) - 1 &lt;= n; i++) //ÂèØ‰ª•‰ªéÁ¨¨0‰ΩçÁΩÆÂºÄÂßã d[i][j] = min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]);&#125; int RMQ_query(int l,int r)&#123; int k = 0; while((1&lt;&lt;(k+1)) &lt;= r-l+1) k++; return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(); int ans = 0x3F3F3F3F; for (int i=1;i&lt;=n;i++)a[i]=read(); for (int i=1;i&lt;=n;i++)b[i]=read(); a[0]=0x80000000; memset(f,0x3F,sizeof(f)); f[0][0] = 0; rep(i,1,n) rep(j,1,3) rep(k,0,i-1) &#123; if(a[k] &gt;= a[i]) continue; f[i][j] = min(f[i][j],f[k][j-1]+b[i]); &#125; rep(i,1,n) ans=min(ans,f[i][3]); printf("%d\n",ans&gt;300000001?-1:ans); return 0;&#125; D. È¢òÊÑè: Êúâ$n$‰∏™ÊùëÂ∫Ñ,$m$Êù°Ëæπ,ÊØèÊù°ËæπÈªòËÆ§ÁöÑËæπÊùÉ‰∏∫1,ÊØè‰∏™ÊùëÂ∫ÑÊúâ‰∏Ä‰∏™Ë¥ßÁâ©$x_i$,Ë¥ßÁâ©ÊúÄÂ§öÊúâ$min(100,k)$Áßç ÂàÜÂà´Ê±ÇÊØè‰∏™ÊùëÂ∫Ñ‰Ωú‰∏∫‰∏ªÂäûÊñπ(Ë¶Å‰ªéÂÖ∂‰ªñÊùëÂ∫ÑËé∑ÂèñË¥ßÁâ©),Ë¶ÅÂ±ïËßà$s$‰∏™Áâ©ÂìÅÁöÑÊúÄÂ∞èËä±Ë¥πÔºü (ÊØèÁßçË¥ßÁâ©ÁÆó1‰∏™) ÊÄùËÄÉ‰∫ÜÂæà‰πÖÂæà‰πÖÂïä..‰∏≠Èó¥‰∏Ä‰ºöÂÑøÁúãE‰∏Ä‰ºöÂÑøÁúãDÂπ∂Ë°åÂú∞ÂÜôÂïä.. ÂèëÁé∞ÊòØ‰∏™ÂÇªÈÄºÈ¢ò. ÂØπ‰∫éÊØèÁßçË¥ßÁâ©.ÈÄâÂèñÂΩìÂâçÁöÑË¥ßÁâ©ÁßçÁ±ª$x$,ÊâîÂà∞ÈòüÂàóÈáåÁ¨®Ê≥ïÂ∏à‰∏ÄÈÅç,ËÆ∞ÂΩï$F(i,x)$,Ë°®Á§∫Á¨¨xÁßçË¥ßÁâ©Êê¨Âà∞ÊùëÂ∫Ñ$i$ÁöÑÊúÄÂ∞èËä±Ë¥π.ËøôÊ†∑ÊòØ$O(nk)$ÁöÑ,ÈÇ£‰πàÊØèÊ¨°ÊØè‰∏™ÊùëÂ∫ÑÂú®$F(i)$ÈáåÁöÑ$x$,$sort$‰∏Ä‰∏ãÊ±ÇÂâç$s$‰∏™Â∞±ÂÆå‰∫ã‰∫Ü„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;const int maxn = 1e5+10;int n,m,s,k;bool vis[maxn];int f[maxn][101];int b[101],ans;int types[100010];queue&lt;pair&lt;int,int&gt; &gt;q;pair&lt;int,int&gt; pa; vector&lt;int&gt;lt[maxn];///------------------head------------------signed main(signed argc, char *argv[])&#123; MM(f,0x7f); n=read(),m=read(),k=read(),s=read(); rep(i,1,n) types[i]=read(); rep(i,1,m) &#123; int x=read(),y=read(); lt[x].push_back(y); lt[y].push_back(x); &#125; //system("pause"); for (int i = 1; i &lt;= min(100,k); i++)&#123; MM(vis,0); while(!q.empty())q.pop(); for (int j=1;j&lt;=n;j++) if(i==types[j])vis[j]=1,q.push(make_pair(j,0)); while(!q.empty()) &#123; pa = q.front(); q.pop(); f[pa.fi][i] = min(f[pa.fi][i],pa.se); for(int oo = 0; oo &lt; lt[pa.fi].size(); oo++) if(!vis[lt[pa.fi][oo]]) vis[lt[pa.fi][oo]]=1,q.push(make_pair(lt[pa.fi][oo],pa.se+1)); &#125; &#125; for (int i = 1; i &lt;= n; i++)&#123; ans=0; memcpy(b,f[i],sizeof(f[i])); sort(b+1,b+100+1); for(int p=1;p&lt;=s;p++) ans+=b[p]; cout &lt;&lt; ans &lt;&lt; " "; &#125; return 0;&#125; E. Áªô‰∏Ä‰∏™1~NÁöÑÊéíÂàó,PetrÊää‰∏§‰∏™‰∏çÂêåÂÖÉÁ¥†‰∫§Êç¢$3n$Ê¨°ÂæóÂà∞‰∏Ä‰∏™Êñ∞ÁöÑÂ∫èÂàó,Um_nikÊää‰∏§‰∏™‰∏çÂêåÂÖÉÁ¥†‰∫§Êç¢$7n+1$Ê¨°ÂæóÂà∞‰∏Ä‰∏™Êñ∞ÁöÑÂ∫èÂàó.Áé∞Âú®ÁªôÂá∫Ëøô‰∏™Êñ∞ÁöÑÂ∫èÂàó,Ê±ÇÊòØË∞ÅÊìç‰Ωú‰∫ÜËøô‰∏™Â∫èÂàó. Ê±ÇÈÄÜÂ∫èÂØπÂ∞±ÂÆå‰∫ã‰∫Ü.01:49ÊÉ≥Âà∞ÁöÑÂÅöÊ≥ï,1ÂèëÂÖ•È≠Ç. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;const int maxn = 1e6+10;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;int b[maxn],n;namespace getrev&#123; int a[maxn],c[maxn],ans=0; void x(int l,int r)&#123; int mid=(l+r)/2,i,j,tmp; if(r&gt;l) &#123; x(l,mid); x(mid+1,r); tmp=l; for(i=l,j=mid+1;i&lt;=mid&amp;&amp;j&lt;=r;) &#123; if(a[i]&gt;a[j]) &#123; c[tmp++]=a[j++]; ans+=mid-i+1; &#125; else c[tmp++]=a[i++]; &#125; if(i&lt;=mid) for(;i&lt;=mid;) c[tmp++]=a[i++]; if(j&lt;=r) for(;j&lt;=r;) c[tmp++]=a[j++]; for(i=l;i&lt;=r;i++) a[i]=c[i]; &#125; &#125; int sol(void)&#123; memcpy(a,b,sizeof(b)); x(1,n); return ans; &#125;&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; n=read(); rep(i,1,n) b[i]=read(); int petr=(n*3) &amp; 1; int cnt=getrev::sol(); cnt=cnt&amp;1; printf("%s\n",cnt==petr?"Petr":"Um_nik"); return 0;&#125; F.(ËÆ¢Ê≠£) ÁªôÂá∫n,ÁªôÂá∫m‰∏™$1\leq x \leq 2^n$ÁöÑÂÖÉÁ¥†,ÂÖ∂‰∏≠Êüê‰∏§‰∏™ÂÖÉÁ¥†$a,b$ÊúâËøûËæπÂΩì‰∏î‰ªÖÂΩì$a \&amp;b = 0$ Ê±ÇËÅîÈÄöÂø´ÁöÑ‰∏™Êï∞. Áúã‰∏äÂéªÂæà‰∏çÂèØÂÅöÔºÅ ckr:ÊàëÂá†ÁßíÈíüÂ∞±ÁßíÊéâ‰∫Ü Ë¢´DÁàÜ‰∫ÜÂïä‚Ä¶ È¶ñÂÖà$3^n$ÁöÑÊö¥ÂäõÊòØÂæàÊòæÁÑ∂ÁöÑ,‰ΩÜÊòØÈÄö‰∏çËøá,ËÄÉËôë‰ºòÂåñ. ckr:‚ÄùÊàë‰ª¨Â∞ùËØïÁùÄGayÊéâ1‰Ωç‚Äù Á±ª‰ºº‰∫éËÆ∞ÂøÜÂåñÁöÑËøáÁ®ã,Êàë‰ª¨Âú®dfsÊó∂ËÆ∞ÂΩïvis[x]Ë°®Á§∫ËÆøÈóÆËøáx. Êàë‰ª¨Âú®dfsÊó∂Êûö‰∏æ$0-n$,Â¶ÇÊûú$(2^i \&amp; x)$,Â∞±ÂèØ‰ª•GayÊéâ. ÁªßÁª≠‰∏ãÂéª$dfs(x^{2^i})$ Â¶ÇÊûúxÂú®ËØªÂÖ•ÁßçÂá∫Áé∞‰∫ÜÂ∞±dfsÂÆÉÁöÑË°•ÈõÜ. Âõ†‰∏∫xÁöÑË°•ÈõÜÁßçÊâÄÊúâÂ≠êÈõÜÂøÖÁÑ∂‰∏éxËÅîÈÄö,Âõ†Ê≠§Ê≠£Á°ÆÊÄßÊòæÁÑ∂. Âìá ÊàëÁâπ‰πàËøôÈÉΩÊ≤°ÊÉ≥Âà∞.ÊòØË¢´ÈöæÂ∫¶ÂêìÈÄÄ‰∫ÜÂïä. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//my vegetable has exploded. :(#include&lt;bits/stdc++.h&gt;#define max(x,y) (x&gt;y?x:y)#define min(x,y) (x&lt;y?x:y)#define MM(x,y) memset(x,y,sizeof(x))#define MCPY(a,b) memcpy(a,b,sizeof(b))#define pb push_back#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define per(i,a,b) for(int i=b;i&gt;=a;i--)#define fi first#define se second#define int long longusing namespace std;inline int quickpow(int m,int n,int p)&#123;int b=1;while(n)&#123;if(n&amp;1)b=b*m%p;n=n&gt;&gt;1;m=m*m%p;&#125;return b;&#125;inline int getinv(int x,int p)&#123;return quickpow(x,p-2,p);&#125;inline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x * f;&#125;int write(int x)&#123; if(x&lt;0) putchar('-'); x=-x; if(x&gt;=10) write(x/10); putchar(x%10+'0');&#125;const int N = 1&lt;&lt;23;int vis[N],ins[N],ans=0,x,n,m;void dfs(int u)&#123; if(vis[u]) return ;vis[u]=1; rep(i,0,n-1) if((1&lt;&lt;i)&amp;u) dfs((1&lt;&lt;i)^u); if(ins[u]) dfs((1&lt;&lt;n)-1-u);&#125;///------------------head------------------signed main(signed argc, char *argv[])&#123; MM(ins,0); n=read(),m=read(); while(m--)&#123; x=read(); ins[x]=1; &#125; if(n==1&amp;&amp;ins[1]) return puts("1"),0; rep(i,0,(1&lt;&lt;n)-1)&#123; if(!(vis[i]||!ins[i]))&#123; ++ans; dfs((1&lt;&lt;n)-i-1); &#125; &#125; printf("%d\n",ans); return 0;&#125; ÂêéËÆ∞ ÁÆóÊòØÁ¨¨‰∏ÄÊ¨°ÊâìÂà∞5È¢òÂêß.. ‰πãÂêéË¶ÅÂùöÊåÅÂïä‚Ä¶ ‚Äã karriganasta :P]]></content>
      <categories>
        <category>ELO Record</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊµÖË∞àÊ¨°Â∞èÁîüÊàêÊ†ë]]></title>
    <url>%2F2018%2F05%2F08%2F%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91-%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Ê¨°Â∞èÁîüÊàêÊ†ëÂÆö‰πâÈ°æÂêçÊÄù‰πâ,Âú®‰∏Ä‰∏™Âõæ$G=(V,E)$‰∏≠Â¶ÇÊûúÂ≠òÂú®ÊúÄÂ∞èÁîüÊàêÊ†ë$T$ÔºåÂ¶ÇÊûúÊúâ‰∏Ä‰∏™ÁîüÊàêÊ†ë$T‚Äô \not= T $‰∏îÂØπ‰∫é$\forall T_x &gt; T‚Äô$,ÂàôÁß∞ÁîüÊàêÊ†ë$T‚Äô$‰∏∫$G$ÁöÑÊ¨°Â∞èÁîüÊàêÊ†ë. ÁÆóÊ≥ï0Êûö‰∏æÂéüÊù•$T$‰∏≠ÊØè‰∏ÄÊù°ËæπÂ∞ÜÂÖ∂Âà†Âéª,ÊØèÊ¨°Ê±Ç‰∏ÄÈÅçMST. Â§çÊùÇÂ∫¶:$O(n*mlog_2m)$ ÊòæÁÑ∂Èöæ‰ª•Êé•Âèó. Â∫îËØ•ËøòÊòØÊå∫Â•ΩÂÜôÁöÑ(‰ΩÜÊòØÂπ∂‰∏ç‰øùËØÅ‰∏•Ê†º) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;struct Node&#123; int u,v,c; bool operator &lt; (const Node &amp;b) const &#123; return c &lt; b.c; &#125; bool sel;&#125;a[maxn];int fa[maxn],sell[maxn],cnt = 0,n,m,ans = INT_MAX;void Pre(void)&#123;for(int i = 1; i &lt; maxn; i++) fa[i] = i;&#125;int getf(int x)&#123;return x==fa[x]?x:fa[x]=getf(fa[x]);&#125;inline int read(void)&#123; int x=0,f=1;char c=getchar(); while(!isdigit(c))&#123;f=c=='-'?-1:1;c=getchar();&#125; while(isdigit(c))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';c=getchar();&#125; return x * f;&#125;int main(int argc, char *argv[])&#123; n = read(), m = read(); for (int i = 1; i &lt;= m; i++) a[i].u = read(),a[i].v = read(),a[i].c = read(),a[i].sel = 1; Pre(); sort(a+1,a+m+1); int ltotal = 0; for (int i = 1; i &lt;= m; i++) &#123; if (ltotal == n - 1) break; int fax = getf(a[i].u),fay = getf(a[i].v); if (fax == fay) continue; fa[fax] = fay; ++ltotal; sell[++cnt] = i; &#125; for (int i = 1; i &lt;= cnt; i++) &#123; Pre(); int ret = 0; a[sell[i]].sel = 0; int lt = 0; for (int j = 1; j &lt;= m; j++) &#123; if (!a[j].sel) continue; if (lt == n - 1) break; int fax = getf(a[j].u),fay = getf(a[j].v); if (fax == fay) continue; fa[fax] = fay; ++lt; ret += a[j].c; &#125; if (lt == n - 1) ans = min(ans,ret); a[sell[i]].sel = 1; &#125; printf("%d\n",ans); return 0;&#125; ÔºàËøòËÉΩÊé•ÂèóÁöÑÔºâÁÆóÊ≥ïÂÄçÂ¢ûLCAÔºà‰ºº‰πéSTË°®‰πüÂèØ‰ª•Ôºâ + MST ÂÆöÁêÜ:Â¶ÇÊûúÂõæGÁöÑËæπÁöÑ‰∏™Êï∞EÂíå‰∏™ÁÇπÁöÑ‰∏™Êï∞N‰∏çÊª°Ë∂≥ÂÖ≥Á≥ªE + 1 = N,ÈÇ£‰πàÂ≠òÂú®Ëæπ(u,v) Â±û‰∫é T Âíå(x, y)‰∏çÂ±û‰∫éTÊª°Ë∂≥T \ (u, v) U (x, y)ÊòØÂõæÁöÑ‰∏ÄÈ¢óÊ¨°Â∞èÁîüÊàêÊ†ë. Ê†πÊçÆËøô‰∏™ÂÆöÁêÜ,ËÆ∞ÂΩï‰∏ãÂéüÊúÄÂ∞èÁîüÊàêÊ†ë‰∏≠ÁöÑËæπ, ÁÑ∂ÂêéÊûö‰∏æÂÆÉÁöÑÈÇªËæπÂπ∂Â∞ùËØïÊ∑ªÂÖ•Âπ∂Âà†ÂéªÁéØ‰∏≠ÔºàÂ¶ÇÊûúÊúâÔºâÊúÄÈïøÁöÑËæπ,ÂèñÊùÉÂÄºÁöÑÊúÄÂ∞èÂÄºÂç≥ÂèØ. ÁΩÆ‰∫éÊÄé‰πàÊ±ÇÊúÄÂ∞èÁîüÊàêÊ†ë‰∏≠$X \ to \ Y$ÁöÑÊúÄÁü≠Ë∑ùÁ¶ª,ÂèØ‰ª•Ê†ëÂΩ¢dpÊàñËÄÖLCA. Ëæ£È∏°ÁöÑÊàëÔºàÊãâÊãâÊùøÂ≠êÔºâÂÜô‰∫Ü‰∏™ÂÄçÂ¢û,Ë∑ëÁöÑËøòË°åÂêß‚Ä¶ LUOGUÊ®°Êùø‰º†ÈÄÅ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int SIZE = 1e5+10;vector&lt;int&gt;a[SIZE];int f[SIZE],fa[25][SIZE],dep[SIZE];int d[2][25][SIZE],n,m,ret,ans = LLONG_MAX,mx;bool used[SIZE &lt;&lt; 2],vis[SIZE];struct Edge&#123; int from,to,val; bool operator &lt; (const Edge y)&#123; return val &lt; y.val; &#125;&#125;e[SIZE&lt;&lt;2];inline int read(void) &#123; int x = 0,f = 1; char c = getchar(); while(!isdigit(c)) &#123; f = c == '-' ? -1 : 1; c = getchar(); &#125; while(isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * f;&#125;int F(int x)&#123;return x==f[x]?x:f[x]=F(f[x]);&#125; void kruskal() &#123; sort(e,e+m); int Lfs=n-1; for(int i=1; i&lt;=n; ++i) f[i]=i; for(int i=0; i&lt;m &amp;&amp; Lfs; ++i) &#123; int x=F(e[i].from),y=F(e[i].to); if(x!=y) &#123; f[x]=y;ret+=e[i].val;used[i]=1; --Lfs;mx=max(mx,e[i].val); &#125; &#125;&#125;void dfs(int x) &#123; vis[x]=true; for(int i=1; i&lt;=23; ++i) &#123; fa[i][x]=fa[i-1][fa[i-1][x]]; int t1=d[0][i-1][x], t2=d[0][i-1][fa[i-1][x]]; d[0][i][x]=max(t1 ,t2); d[1][i][x]=max(d[1][i-1][x] , d[1][i-1][fa[i-1][x]]); if(t1!=t2) d[1][i][x]=max(d[1][i][x] , min(t1 , t2)); &#125; for(int i=0; i&lt;a[x].size(); ++i) &#123; int t=e[a[x][i]].to+e[a[x][i]].from-x; if(vis[t]) continue; dep[t]=dep[x]+1; fa[0][t]=x; d[0][0][t]=e[a[x][i]].val; dfs(t); &#125;&#125;int lca(int u,int v) &#123; if(dep[u]&lt;dep[v]) swap(u,v); if(dep[u]!=dep[v]) &#123; for(int i=23,h=dep[u]-dep[v]; i&gt;=0; --i) if(h&amp;(1&lt;&lt;i)) u=fa[i][u]; &#125; if(u == v) return u; for(int i=23; i&gt;=0; --i) if(fa[i][u]!=fa[i][v]) u=fa[i][u] , v=fa[i][v]; return fa[0][u];&#125;int get(int u,int v,int c) &#123; int fht=lca(u,v); int m1=-1,m2=-1; for(int i=23,h1=dep[u]-dep[fht],h2=dep[v]-dep[fht]; i&gt;=0; --i) &#123; if(h1&amp;(1&lt;&lt;i)) &#123; if(d[0][i][u]&gt;m1) m2=m1,m1=d[0][i][u]; m2=max(m2 , d[1][i][u]); &#125; if(h2&amp;(1&lt;&lt;i)) &#123; if(d[0][i][v]&gt;m1) m2=m1,m1=d[0][i][v]; m2=max(m2 , d[1][i][v]); &#125; &#125; //‰∏•Ê†ºÂ§ß‰∫éÁöÑÂÖ≥ÈîÆ,ËøôÈáåËã•ÊòØreturnÊ≤°ÊúâÂ§ÑÁêÜÂ•ΩÊûÅÂÖ∂ÂÆπÊòìË¢´Hack if(m1!=c) return c-m1; if(m2!=-1) return c-m2; return 0; &#125;signed main(signed argc, char *argv[]) &#123; n = read(), m = read(); for(int i=0; i&lt;m; ++i) &#123; int u,v,w; u = read(),v = read(),w = read(); e[i]=(Edge)&#123;u,v,w&#125;; &#125; kruskal(); for(int i=0; i&lt;m; ++i) if(used[i]) &#123; a[e[i].from].push_back(i); a[e[i].to].push_back(i); &#125; dep[1]=1;dfs(1); for(int i=0; i&lt;m; ++i) if(!used[i]) &#123; if(e[i].val-mx&gt;ans) break; int t=get(e[i].from,e[i].to,e[i].val); if(t) ans=min(ans,t); &#125; printf("%lld\n",ret+ans); return 0;&#125; Âê¨ËØ¥Â•ΩÂÉèÊúâÂ§ßÁà∑ËøòÁî®LCTÊù•Áª¥Êä§Ëøô‰∏™XÂà∞YÁöÑÊúÄÂ§ßÂÄº,ÁªôË∑™‰∫ÜÂïä]]></content>
      <categories>
        <category>ÁîüÊàêÊ†ë</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ËµÑÁì∑Êñ∞ÂüüÂêçËæ£ÔºÅÊ¨¢Ëøé‰ΩøÁî®karriganasta.xyzËÆøÈóÆ]]]></title>
    <url>%2F2018%2F05%2F03%2F%E8%B5%84%E7%93%B7%E6%96%B0%E5%9F%9F%E5%90%8D%E8%BE%A3%EF%BC%81%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8karriganasta-xyz%E8%AE%BF%E9%97%AE-md%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2018ÈÖ±Ê≤πËÆ∞]]></title>
    <url>%2F2018%2F04%2F26%2FZJOI2018%E9%85%B1%E6%B2%B9%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[‰∏äÊ¨°ÁöÑÊ∏∏ËÆ∞Â•ΩÂÉèÂøò‰∫ÜÂÜô‰∫ÜÂ∞±ÂΩì‰∏ÄËµ∑Ë°•‰∏äÂêßqwq ËØæ‰ª∂Âú®Ëøô Series 1 Series 2 ZJOI Day 1 Statement &amp; Solution ZJOI Day 2 Statement &amp; Solution ZJOI 2018 @ Ë°¢Â∑û 2018.3.18-2018.3.21Day 0Êíû‰∏ä‰ΩìËÇ≤‰∏≠ËÄÉÂ•ΩÊ∞îÂì¶‰∏çËÉΩÊê≠Â§ßÂ∑¥ÂéªÂï¶,ÊªöÂõûÊù≠Â∑ûÊêû‰∫Ü‰∏Ä‰∏äÂçàÊãø‰∫Ü30ÂàÜÊª°ÂàÜ.ÂóØËµÑÁì∑Âïä. ‰∏ãÂçàÂ∞±Ëµ∂ÁùÄÁÅ´ËΩ¶È£ûÂà∞Ë°¢Â∑ûÂéªÂï¶ Âà∞‰∫ÜÂÆæÈ¶ÜÂçßÊßΩËøòÊúâÁîµËÑëÂïäËøô‰πàÈ´òÁ´Ø,ÁÑ∂Âêé‰ºº‰πéÂõ†‰∏∫‰∫∫Êï∞ÊòØÂ•áÊï∞‰∏™,ËÄå‰∏îÊàëÂèàÊòØÊúÄÂêé‰∏Ä‰∏™Âà∞ÁöÑ.ÊâÄ‰ª•Êàë‰∏Ä‰∏™‰∫∫Âç†‰∫Ü‰∏Ä‰∏™Â§ßÂ∫ä?!ÊâÄ‰ª•ËØ¥Âà∞ÁöÑËøüËøòÊúâÁ¶èÂà©?ÊÉä‰∫Ü. Êôö‰∏äÊ®°ÊùøÈ¢òÊï≤Êï≤‰∫∫ÁîüÂ§ßÊúâÂ∏åÊúõ. Áù°ËßâÂâçÁúã‰∫ÜÂá†ÈõÜÁï™,ËàíÊúç. Day 1‰∏äÂçàrxdÂ§ßÁà∑Á•ûÁ∫ßËÆ≤È¢ò,ÊåëÁöÑÈÉΩÊòØCFÊàë‰∏çÊ†πÊú¨‰∏çÊï¢ÂºÄÁöÑÈ¢ò,Âú®Á∫ø‰∫Ü‰∏Ä‰∏™Â∞èÊó∂Â∑¶Âè≥Â∞±ÊéâÁ∫ø‰∫Ü,ÊàëÂ•ΩËèúÂïä. ‰∏≠ÂçàË°¢Â∑û‰∫å‰∏≠‰ºôÈ£üÊÄé‰πàËøô‰πàËæ£Âïä‚Ä¶ ‰∏ãÂçàHEZÁöÑÈôàÂòâ‰πêÂíåÈôÜÂÆáÊöÑÁΩëÊ†ºÂõæËøòÊå∫ÊúâÊÑèÊÄùÁöÑ.ËµÑÁì∑‰∏ÄÊ≥¢.‰ΩÜÊòØÊÑüËßâÊÄùËÄÉÊó∂Èó¥Â§™Â∞ë‰∫ÜÂïäÂïäÂïä. Êôö‰∏äpogemo. Day 2‰∏äÂçàÁªç‰∏ÄÂ≠£Èõ®Áî∞ËÆ≤CFÊ∞¥È¢ò ÁªìÊûú‰∏çÂ§™Âê¨ÂæóÊáÇ,Âú∫ÂÜÖÊúâ‰∏™Â∞èÂì•Â•ΩÈ™öÂïäÂá†‰πéÊØèÊ¨°ÈÉΩË¶Å‰∏äÂéª Êµ™ ÂàáÈ¢ò. ÁúüÁöÑÊòØÂ§ßÂà∞‰∏çË°å. ‰∏ãÂçàlych_cysÊ¢ÅÂ§ßËÆ≤ËØæ!ËµÑÁì∑!JOIsc‰ªÄ‰πàÁöÑÂ§™Â§ß‰∫Ü.ÂêéÂçäÁ®ãÊòØÁúüÁöÑÂê¨‰∏çÂä®‰∫Ü. Êôö‰∏äÊï≤Ë£∏È¢ò+pogemo. PAÊü•ÊàøÁúüÁöÑÁ•ûÂá∫È¨ºÊ≤° Day 3Âïä‰∫∫ÁîüÁ¨¨‰∏ÄÂú∫ÁúÅÈÄâ(ËøòÊòØÈùûÊ≠£ÂºèÈÄâÊâã).Âà´ÁàÜÈõ∂Â∞±Ë°å. ÂºÄÂú∫ÁúãT1. Ëä±‰∏Ä‰∏™ÂçäÂ∞èÊó∂Êí∏Âá∫Â§ßÊö¥Âäõ.ËØ∂!Â•ΩÂÉèÂèØ‰ª•Êãø20ÂàÜ! ‰ºº‰πéÂÜçÂú®20ÂàÜÂü∫Á°Ä‰∏äÊêû‰∏Ä‰∏ãÁÇπÁÇπÂ∫¶Êï∞ÂèØ‰ª•Êãø30ÂàÜ!ÂèàËä±‰∫Ü‰∏Ä‰∏™Â∞èÊó∂ÂÜôÈÇ£‰∏™10ÂàÜ. ÁúãT2,Êï∞ÊçÆÁªìÊûÑÈ¢òÂïäÊ≤°‰ø°‰ª∞ÁöÑ,ÈÇ£‰∏™ÂçÅÂàÜÂ•ΩÂÉèÁúãËµ∑Êù•Êå∫Â•ΩÂêÉÁöÑ. next_permutation()ÂçäÂ∞èÊó∂ÂÜôÊéâ10ÂàÜ ÁúãT3‰ºº‰πéÊòØÁªìËÆ∫È¢ò‚Ä¶ Êö¥ÂäõÊâæËßÑÂæã‰∏§Â∞èÊó∂ÊØ´Êó†ÂçµÁî®. ÊúÄÂêéÁªùÊúõ‰πã‰∏≠srand(19260817) gg wp ËµõÂêéÂ•ΩÂÉèËØÑÊµãÂá∫ÈîÖ‰∫Ü! Êúâ‰∫∫ÊääÊàëÁöÑÁºñÂè∑Âç†‰∫Ü! ÊâÄ‰ª•ÂÖ®Êú∫ÊàøÂ•ΩÂÉèÂ∞±Êàë‰∏Ä‰∏™‰∏çÁü•ÈÅìËá™Â∑±Âá†ÂàÜ! qnmd! Âê¨ËØ¥30ÂàÜÔºà20+10+0Ôºâ ZJOI 2018 @ Ë°¢Â∑û 2018.4.24-2018.4.26Day 0ÁúÅÈÄâÂâçÊú∫ÊàøÂ•ΩÂÉèÈÉΩÂú®ÂàáÈ¢òÂïä,ÂçÅÂàÜÊÖåÂº†,Â§ßÁà∑‰ª¨Ë¶ÅËøõÈòü‰∫ÜÂïä. (‰ºº‰πéÊ≤°ÁúãÂà∞Ê±™Â§ßÂíåÊ¢ÅÂ§ß) ‰∏ãÂçà‰ºº‰πéÂú®ÁàÜStupid OJËÆ≠ÁªÉÂéãË°å?! ÁΩóÂ§ßÂéãË°åÁúüÁöÑÂá∂Âïä. ‰∏§ÁÇπÂõõÂçÅÂàÜPAÊù•Êú∫ÊàøÂè´‰∫∫Âï¶. Âá∫Ê†°Èó®ÂùêÂ§ßÂ∑¥ËΩ¶1H30minÂà∞ÈÖíÂ∫ó. ÂìáËøôÊ¨°‰∏â‰∫∫Èó¥! ‰∏Ä‰∏™Â§ßÂ∫äÂä†‰∏§‰∏™Â∞èÂ∫ä!ÂÖ∂ÂÆûÊòØÂèØ‰ª•Áù°Âõõ‰∏™ÁöÑ,‰ΩÜÊòØ‰∏∫‰∫ÜÈò≤Ê≠¢Êàë‰ª¨Êôö‰∏äÁé©‚ôÇÊ∏∏Êàè,ÊâÄ‰ª•Â∞±Ê≤°ÊúâÂõõ‰∫∫‰∏ÄÈó¥Âï¶. ÊèíÂè£Ëøô‰πàÂ§öÊàëÂ∏¶‰∏™Â±ÅÊèíÁ∫øÊùøÂïä ÁéØÂ¢ÉË∂ÖÂ•ΩÁöÑ!ËµÑÁì∑!ÊûïÂ§¥Ë¥ºËàíÊúç!Â∞±ÊòØÁΩëÁªúÁúüÁöÑ‰∏çÁ®≥ÂÅ•. Êôö‰∏äpoÈ≠îÁ¶Å Day 1‰∏äÂçàÂ≠¶ËΩ¶cbhÁ•û‰ªôËÆ≤È¢ò,Â•ΩÈ´òÁ´ØÂïä.‰∏çÊòØÂæàÂê¨ÁöÑÊáÇ.ÂßøÂäøÊ∞¥Âπ≥‰∏çÂ§üÂïä. ‰ΩôÂßö‰∏≠Â≠¶ÂçàÈ•≠ËµÑÁì∑!Â∞èÂçñÈÉ®Â±ÖÁÑ∂Ë¢´Êàë‰ª¨‰∫îÂàÜÈíüÊâæÂà∞,ÈúáÊÉä! ‰∏≠ÂçàÊÉ≥Êâæ‰∏™ÁØÆÁêÉÊâì‰ΩÜÊòØÊâæ‰∏çÂà∞Âïä,‰ΩôÂßö‰∏≠Â≠¶ÈÉΩÊ≤°‰∫∫ÊääÁêÉËóèÁÅåÊú®‰∏õÈáåÁöÑÂêó?ÈúáÊÉä! ‰∏ãÂçàÊØõËÄÅÂ∏àmjyÊù•Âï¶! ÊûúÁÑ∂dlsÂ¶πÂ≠êÂ∞±ÊòØÂ•ΩÁúã È¢òÁõÆËøòÊå∫ÂèãÂñÑÁöÑ,‰∏çÊòØÂºÄÂú∫Â∞±ÊòØÊØíÁò§È¢ò,ËµÑÁì∑! ÊúâÈÅìÈ¢òÂ•ΩÂÉèÂà∑Âá∫‰∫ÜZJOChÁöÑÊ¢óÔºàZJOIÁæ§ÈáåÂà∑ÁöÑÔºâ. ÂêêÊßΩ:Êúâ‰∏™Â∞èÂì•‰∏ÄÁõ¥ÊääÈÇ£ÁßçËìùÂ°ëÊñôÂá≥Â≠êÂÄíÊâ£Âú®Ëá™Â∑±Â§¥‰∏äÁÑ∂ÂêéÁ´ôÁùÄÊí∏‰ª£Á†Å,Â•ΩÂ§ßÁà∑ÂïäÂèØÂ∞±ÊòØÊå°ÁùÄÊàëÁúãÂ±èÂπï‰∫Ü. ÊØõËÄÅÂ∏àÂêéÈù¢ÁöÑÈ¢òÊúâ‰∫õ‰∏çÊòØÂæàÊáÇÂïä.. Êôö‰∏äpogemo Day 2‰∏äÂçàÊûúÁÑ∂ËøòÊòØÈôàÂòâ‰πêÂíåÈôÜÂÆáÊöÑÂ§ßÁà∑ÁöÑÊØíÁò§ËÆ≤È¢ò. ËµÑÁì∑‰∏ÄÊ≥¢. Âê¨‰∏çÂä®ÂïäÈõÜËÆ≠ÈòüËÉ°Á≠ñÊòØÁªô‰∫∫ÂÅöÁöÑÂêó‚Ä¶ Âá†‰πéÂÖ®Á®ãÊéâÁ∫ø. ‰∏ãÂçàmiaomËÆ≤ËØæÂïä!ËµÑÁì∑!miaomËÆ≤ËØæ‰∏ÄÁõ¥Á¨ëÁùÄÂ∏ÖÊ≠ª‰∫ÜÂïä! ÂèØËÉΩËøòÊòØÂê¨‰∏çÂ§™ÊáÇÂïä.QAQ È´òÊ†°ÂÆ£ËÆ≤ÔºàÊíïbÂ§ß‰ºöÔºâÂ•ΩÂ§ö‰∫∫Ê≤°Êù•Âê¨Âïä,ckrÂíåpcÈÉΩËµ∞‰∫Ü.ÊÑüËßâÁ¨¨‰∏ÄÊ¨°Êù•ÁúÅÈÄâÂºÄÂºÄÁúºÁïå‰πüÂ•ΩÂïä. ÔºàÈ°∫‰æø‰∏ã‰∏™ÂÜ≥ÂøÉÔºâ ÊûúÁÑ∂DËµ∑Êù•‰∫Ü,ÊàëÁúãÁùÄÊµôÂ§ßËØ¥Ëá™Â∑±ËÆ°ÁÆóÊú∫ÂíåËΩØ‰ª∂Â∫îÁî®ÈÉΩÊòØA+ËÄåÊ∏ÖÂåóÈÉΩÊ≤°Êúâ. ÁªìÊûúÊàë‰∏ÄÁøªÊâãÊú∫ÁúãACM-ICPC2018ÁöÑRanklist. ÂëÄZhejiang University‰ºº‰πéÈÉΩÂÄíÊï∞‰∫Ü.. ÊÑüËßâÊ≤°ÊúâÂØπÊØîÂ∞±Ê≤°Êúâ‰º§ÂÆ≥Âïä‚Ä¶ ‰∏≠ÁßëÂ§ßÁúã‰∏äÂéªÊå∫È´òÁ´ØÁöÑ. THUÂíåPKUËÆ≤ÁöÑÁúüÁöÑËµ∞ÂøÉ. Êù≠ÁîµÁöÑÊïôÁªÉÈÄóÊ≠ªÊàë‰∫Ü‰ªñÂ±ÖÁÑ∂ÊãøÂá∫‰∫Ü‚ÄúÂåÖÂàÜÈÖçÂ¶πÂ≠ê‚ÄùÁöÑÊùÄÂô®!ÈúáÊÉä! ÊôöÈ•≠Âéª‰∏áËææÂêîÈ∫¶,Ê¨°‰∫ÜÂ•ΩÂ§ö‰∏úË•ø. skyleeÊèêËÆÆÂéªÊ∏∏ÊàèÂéÖ‰ΩÜÊòØËßâÂæóÁé©Â®ÉÂ®ÉÊú∫ÊòéÂ§©‰ºöWA WAÊú∫Âïä. ‰∫éÊòØÊ≤°Âéª. Êôö‰∏ä‰∏çÊòØÂæàÊÉ≥po‰ΩÜËøòÊòØpo‰∫Ü‰∏Ä‰ºöÂÑø. Áù°ÂæóËøòÁÆóÊó©Âêß,È°∫‰æøÁêÜ‰∫Ü‰∏ã‰∏úË•ø. ÂÆâ. Day 3ÊØî‰∏äÊ¨°ÊÑüËßâEZ‰∏ÄÁÇπÂïä,‰∏çËøáÂèØËÉΩÂØπÊàëËøôÁßçÂº±È∏°ËøòÊòØÊö¥ÂäõÂàÜÂÜôÂÜô. T1‰∏äÊù•ÊÑüËßâ‰∏çÂèØÂÅö,ÂÜô‰∫Ü‰∏™O(n!)ÁöÑÊö¥ÂäõÂ±ÖÁÑ∂Ëä±‰∫Ü‰∏Ä‰∏™Â∞èÊó∂!ÈúáÊÉä!ÊàëËèúÊ≠ª‰∫Ü! $N = 10$Ê≤°ËøáÂïä,ÈöæËøá!ÊàëÂ∏∏Êï∞Ëøô‰πàÊå´ÁöÑ? Âá∫Êù•‰ºº‰πéËøûÊö¥Âäõ‰πüÂÜôÈîô‰∫Ü?! GCC314Êö¥ÂäõÂíåboomÊâãÁÆóÁªìÊûú‰∏ÄÊ†∑?! ËçØ‰∏∏.Á•àÁ•∑$N = 5$ÁöÑÊó∂ÂÄôÊàëÊòØÂØπÁöÑÂïä.QAQ T2ÂèØËÉΩÂÜô‰∫Ü‰∏™ÂÅáÁÆóÊ≥ï‚Ä¶‚Ä¶‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πàÊÑüËßâ‰∏äÂçàÊØ´Êó†Á†ÅÂäõÂïä. (ÊàëÊÄé‰πàÊÑüËßâÊàëÂ•ΩÂÉèÊèê‰∫§Êñá‰ª∂Êó∂ÂÄôÂá∫ÈîÖ‰∫Ü) UPD : ‰ºº‰πéÁúüÁöÑÂá∫ÈîÖ‰∫Ü. ÂáâÂáâ T3ÁÆóÂá†ÂºÉÂùë.rand()‰∏ÄÂèëÂÆå‰∫ã. Ë¶ÅÁàÜËõãÂï¶Day2! ÊªöÂõûÂéªÊèêÈ´òÂßøÂäøÊ∞¥Âπ≥! ZJOI2019ÂÜçÊàò! ‚Äã Edited By karriganasta ‚Äã 2018.04.26 ‚Äã]]></content>
      <categories>
        <category>Ê∏∏ËÆ∞</category>
      </categories>
      <tags>
        <tag>Ê∏∏ËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåÊ®°Êùø„ÄçÂ∏∏Áî®ÊùøÂ≠ê]]></title>
    <url>%2F2018%2F04%2F12%2F%E3%80%8C%E6%A8%A1%E6%9D%BF%E3%80%8D%E5%B8%B8%E7%94%A8%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[Áªà‰∫éÊòØÊÑüËßâ‰∏úË•øÂ§ö‰∫ÜË¶ÅËÖæ‰∏™Âú∞ÊñπÂá∫Êù•ÊåÇÊùøÂ≠ê‰∫Ü To be continued‚Ä¶ È°∫‰æøÁΩÆÈ°∂‰∏ÄÊ≥¢ ÊùøÂ≠êÂÖ®ÂÆ∂Ê°∂ Â≠óÁ¨¶‰∏≤ AC AutomatonÈùûÊåáÈíà AC Automaton kmp Trie Êï∞Â≠¶ CRT Extended Euclid FFTÈÄíÂΩí FFTËø≠‰ª£ NTTÊ®°Ë¥πÈ©¨Ë¥®Êï∞ NTT‰ªªÊÑèÊ®° Â§öÈ°πÂºèÊ±ÇÈÄÜ SGÂáΩÊï∞ Áü©Èòµ‰πòÊ≥ï&amp;Âø´ÈÄüÂπÇ Êï∞ËÆ∫ÂáΩÊï∞Á∫øÁ≠õ Á∫øÁ≠õ‰πòÊ≥ïÈÄÜÂÖÉ ÂõæËÆ∫ LCA MST-Kruskal SPFA Êï∞ÊçÆÁªìÊûÑ ScapegoatÊõøÁΩ™ÁæäÊ†ë Âπ∂Êü•ÈõÜ SplayÂå∫Èó¥ÂèçËΩ¨ÊñáËâ∫Âπ≥Ë°°Ê†ë Treap Á∫øÊÆµÊ†ëÂå∫Èó¥Êìç‰Ωú Ê†ëÁä∂Êï∞ÁªÑFenwickTree ÊùÇ Fast IO 1 Fast IO 2 Âø´ÈÄüÂπÇ ‰∏âÂàÜÊ≥ï ‰∏âÁª¥ÂÅèÂ∫èCDQÂàÜÊ≤ª]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄåHR(HackerRank)„ÄçÊñØÊ≥¢È¢òÂàáÈ¢òËÆ∞]]></title>
    <url>%2F2018%2F04%2F10%2F%E3%80%8CHR-HackerRank-%E3%80%8D%E6%96%AF%E6%B3%A2%E9%A2%98%E5%88%87%E9%A2%98%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ÂºïË®ÄÂàá‰∫Ü‰∏ÄÊ≥¢ÊñØÊ≥¢È¢òhjqÁ¥†Ë¥®‰∏çËÉΩÊõ¥Â∑ÆÈöè‰æøÁé©Áé©,ËøòÊòØÊúâÁÇπÊî∂Ëé∑ÁöÑÂêß.. K Candy StoreLinks there:HR-K Candy Store Â§ßÊÑè:ÊúâN‰∏™‰∫∫,ÂàÜ‰∏çÂêåÁöÑKÁßçÁ≥ñÊûú,ÂêÑ‰∏™Á≥ñÊûúÂèØ‰ª•ÈÄâÊó†Êï∞‰∏™,Ê±ÇÊñπÊ°àÊï∞. solution:ÂÖ∏ÂûãÁöÑÊèíÊùøÊ≥ï.Á≠îÊ°à‰∏∫$C(n+m-1,n-1)$ 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int mod = 1e9; int T,n,m,C[5003][5003];inline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;signed main(signed argc, char *argv[])&#123; for (int i = 0; i &lt;= 5000; i++) for (int j = 0; j &lt;= i; j++) &#123; if (i == j || i == 0) C[i][j] = 1; else C[i][j] = (C[i-1][j-1]+C[i-1][j]) % mod; &#125; T = read(); while(T--) &#123; int n = read(), m = read(); printf("%lld\n",C[n+m-1][n-1]); &#125; return 0;&#125; Special MultipleLinks there:HR-Special Multiple Â§ßÊÑè:ÁªôÂá∫‰∏Ä‰∏™N,Ê±ÇÊúÄÂ∞èÁöÑÂè™Áî±0,9ÁªÑÊàêÁöÑÊï∞Â≠ó‰∏≤‰ΩøÂæóÂÖ∂‰∏∫ÁªôÂÆöNÁöÑÂÄçÊï∞.$N \leq 500$ solution: ËÄÉËôë01‰∏≤‰∫åËøõÂà∂ÁöÑËΩ¨Êç¢,[1,2,3,4] $-&gt;$ [1,10,11,100]ÂΩìÊàë‰ª¨ÊääÂè≥Ëæπ‰πò9Âç≥ÂèØÂæóÂà∞0-9‰∏≤. ÈÄê‰ΩçÊûÑÈÄ†Âç≥ÂèØ. 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longlong long binar(long long n) &#123; if (n == 1) return 1LL; if (n &amp; 1) return 1LL * 10*binar(n/2)+1; else return 1LL * 10*binar(n/2);&#125;signed main(signed argc, char *argv[]) &#123; int t; cin&gt;&gt;t; while(t--) &#123; long long n,a=1,b=9; cin&gt;&gt;n; while(b % n) &#123; a++; b = binar(a); b *= 9; &#125; cout&lt;&lt;b&lt;&lt;endl; &#125; return 0;&#125; ÊÑüËßâÂíåSOJ‰∏äÈ©¨‰∏âÁöÑ‰∫åËøõÂà∂Êï∞‰∏ÄÈ¢òÂæàÂÉè.ËÄå‰∏î‰ºº‰πéÂä†‰∏™È´òÁ≤æÂ∞±ÂèØ‰ª•AÊéâ. ÂΩìÊó∂Êú¨ËíüËíªÂÅöËøôÈ¢òËøòÁî®ÁöÑdpÂìàÂìà. Matrix RacingLinks there:HR-Matrix Racing Â§ßÊÑè:ÁªôÂá∫‰∏Ä‰∏™$N \times M$ÁöÑÁü©Èòµ,Ê±Ç‰ªéÂ∑¶‰∏äËßí$(1,1)$Âà∞Âè≥‰∏ãËßí$(N,M)$ÁöÑÊñπÊ°àÊï∞ ÂèòÁõ∏ÁöÑÊù®Ëæâ‰∏âËßí. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int mod = 1e9+7; int T,n,m,jc[2000010];int quickpow(int m,int n)&#123; int b = 1; while(n) &#123; if (n &amp; 1) b = b * m % mod; n /= 2; m = m * m % mod; &#125; return b;&#125;int C(int n,int r)&#123; int i1 = quickpow(jc[n-r],mod-2); int i2 = quickpow(jc[r],mod-2); int ret = 1LL * i1 * i2 % mod * jc[n] % mod; return ret;&#125;inline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;signed main(signed argc, char *argv[])&#123; jc[0] = 1; for (int i = 1; i &lt;= 2000004; i++) jc[i] = 1LL * jc[i-1] * i % mod; T = read(); while(T--) &#123; int n = read(), m = read(); printf("%lld\n",C(n+m-2,n-1)); &#125; return 0;&#125; Ââ©‰∏ãÁöÑÂ•ΩÂÉèÈÉΩÊå∫ÂÇªÈÄºÁöÑÂ∞±‰∏çÂÜôÈ¢òÈù¢‰∫Ü 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//SherlockÂíåÁ∫¶Êï∞#include&lt;bits/stdc++.h&gt;using namespace std;int t,n;inline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;int main(int argc, char *argv[])&#123; t = read(); while(t--) &#123; n = read(); int ans = 0; for (int i = 1; i &lt;= sqrt(n+0.5); i++) if (!(n % i)) &#123;if(!(i%2))++ans; if(i*i == n) continue; if(!((n/i)%2)) ++ans;&#125; printf("%d\n",ans); &#125; return 0;&#125;//Diwali Lights#include&lt;bits/stdc++.h&gt;const int mod = 1e5;const int maxn = 1e4;using namespace std;int T,n;inline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;int main(int argc, char *argv[])&#123; int T = read(); while(T--) &#123; int n = read(),prod = 1; for (int i = 0; i &lt; n; i++) prod *= 2,prod %= mod; prod = ((prod-1) % mod + mod) % mod; printf("%d\n",prod); &#125; return 0;&#125;//Summing N Series#include&lt;bits/stdc++.h&gt;using namespace std;int T;long long n;const int mod = 1e9+7;int main(int argc, char *argv[])&#123; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; n; n %= mod; n = n * n % mod; cout &lt;&lt; n &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>HackerRank</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Â•áÊäÄÊ∑´Â∑ß] bitsetÂ§ßÊ≥ïÂêºÂïä]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-bitset%E5%A4%A7%E6%B3%95%E5%90%BC%E5%95%8A%2F</url>
    <content type="text"><![CDATA[ÂâçË®Äbitset‰∏çÊ≠¢‰∏ÄÊ¨°Âê¨Â§ßÁà∑‰ª¨ÂÆâÂà©Ëøá‰∫Ü‚Ä¶ ‰ºº‰πé Êå∫ÂéâÂÆ≥ÁöÑ.Âõ†‰∏∫boolÊï∞ÁªÑÂú®Áî®ÁöÑÊó∂ÂÄôÂè™ËÉΩÂ§üÁî®‰∏Ä‰∏™byte‰ΩÜÊòØbyteÊúâ8‰∏™bit,0/1Âè™Ë¶Å1‰∏™Â∞±Â§ü‰∫Ü.. ÊâÄ‰ª•Êµ™Ë¥π‰∫Ü7‰∏™bit. Reference: bitset/zh-cpp-reference bitset/cppcontainer hfq is so toxic.! 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#include&lt;bitset&gt;using namespace std;int main(int argc, char *argv[])&#123; //Ê≠£Â∏∏ÁöÑÊûÑÈÄ† bitset&lt;8&gt;a(42); //[0,0,1,0,1,0,1,0] cout &lt;&lt; a &lt;&lt; endl; bitset&lt;70&gt;b(LLONG_MAX); cout &lt;&lt; b &lt;&lt; endl; //Â≠óÁ¨¶‰∏≤stringÊûÑÈÄ† string bit_s = "110010"; bitset&lt;8&gt;c(bit_s); cout &lt;&lt; c &lt;&lt; endl; // bitset&lt;sz&gt;b(bit_string,x,(y)); bitset&lt;8&gt;d(bit_s,2); //Â≠óÁ¨¶‰∏≤ÁöÑÁ¨¨ x+1(‰∏ãÊ†á‰∏∫x)‰∏™Âèä‰πãÂêéÁöÑÁî©Ëøõbitset. cout &lt;&lt; d &lt;&lt; endl; bitset&lt;8&gt;e(bit_s,0,3); //Â≠óÁ¨¶‰∏≤ÁöÑÁ¨¨ x+1(‰∏ãÊ†á‰∏∫x) ÂèäÂÖ±y‰∏™Áî©Ëøõbitset. cout &lt;&lt; e &lt;&lt; endl; // stringÁöÑËá™ÂÆö‰πâÊûÑÈÄ†0,1‰∏≤ string bit_as = "HHHJJJHHJH"; bitset&lt;10&gt;f(bit_as,0,bit_as.size(),'H','J'); //ÊääHËÆæ‰∏∫0ÔºåJËÆæ‰∏∫1,Â¶ÇÊûúÂá∫Áé∞‰∫ÜÂÖ∂‰ªñÁöÑÂ≠óÁ¨¶Â∞±ËøîÂõûÈîôËØØ cout &lt;&lt; f &lt;&lt; endl; return 0;&#125; Atcoder Grand Contest AGC 020 C Median SumAGC 020C Ê∞¥È¢ò(ÊàëËøòÊòØ‰∏ç‰ºöÂÅö) Áî®bitsetÁª¥Êä§‰∏Ä‰∏™Á±ª‰ººËÉåÂåÖÁöÑ‰∏úË•ø.. 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int n,ret = 0;bitset&lt;4000010&gt;f;inline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x*f;&#125;int main(int argc, char *argv[])&#123; n = read(); f[0] = 1; while(n--) &#123; int x = read(); f = f|(f&lt;&lt;x); ret += x; &#125; int i; for (i = (ret+1)/2; !f[i]; i++); cout &lt;&lt; i; return 0;&#125;]]></content>
      <categories>
        <category>bitset</category>
      </categories>
      <tags>
        <tag>Â•áÊäÄÊ∑´Â∑ß</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Treap/Splay/Scapegoat Â≠¶‰π†Á¨îËÆ∞&ÊùøÂ≠ê]]></title>
    <url>%2F2018%2F03%2F28%2FTreap-Splay-Scapegoat-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[Treap/Splay/ScapegoatÊùøÂ≠ê ÂÖ®ÊåáÈíà ÊØïÁ´üÊåáÈíàÂ•ΩÂÜôÂ•ΩË∞ÉÔºàËôΩÁÑ∂Âç†Â§ö‰∫ÜÁÇπM Treap(LUOGU P3369/BZOJ 3224ÂèØÈ£üÁî®)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// m Êìç‰ΩúÊúâm‰∏™// 1 x ÊèíÂÖ•ÂÖÉÁ¥†x// 2 x Âà†Èô§ÂÖÉÁ¥†x„ÄÇÂ¶ÇÊûúÊàêÂäüÔºåËæìÂÖ•1ÔºåÂê¶ÂàôËæìÂá∫0// 3 k ËæìÂá∫ÂÄºxÁöÑ‚ÄúÂêçÊ¨°‚ÄùÔºåÂç≥ÊØîxÂ∞èÁöÑÁªìÁÇπ‰∏™Êï∞Âä†1// 4 x Á¨¨kÂ∞èÂÖÉÁ¥†„ÄÇk=1‰∏∫ÊúÄÂ∞èÂÖÉÁ¥†// 5 x prefix of x// 6 x suffix of x// ... to be continued ...#include&lt;bits/stdc++.h&gt;using namespace std;struct Node &#123; Node *ch[2]; // Â∑¶Âè≥Â≠êÊ†ë int r; // ÈöèÊú∫‰ºòÂÖàÁ∫ß int v; // ÂÄº int s; // ÁªìÁÇπÊÄªÊï∞ Node(int v = 0):v(v) &#123; ch[0] = ch[1] = NULL; r = rand(); s = 1; &#125; int cmp(int x) const &#123; if (x == v) return -1; return x &lt; v ? 0 : 1; &#125; void maintain() &#123; s = 1; if(ch[0] != NULL) s += ch[0]-&gt;s; if(ch[1] != NULL) s += ch[1]-&gt;s; &#125;&#125;;void rotate(Node* &amp;o, int d) &#123; Node* k = o-&gt;ch[d^1]; o-&gt;ch[d^1] = k-&gt;ch[d]; k-&gt;ch[d] = o; o-&gt;maintain(); k-&gt;maintain(); o = k;&#125;void insert(Node* &amp;o, int x) &#123; if(o == NULL) o = new Node(x); else &#123; int d = (x &lt; o-&gt;v ? 0 : 1); insert(o-&gt;ch[d], x); if(o-&gt;ch[d]-&gt;r &gt; o-&gt;r) rotate(o, d^1); &#125; o-&gt;maintain();&#125;Node* find(Node* o, int x) &#123; if(o == NULL) return NULL; if(x == o-&gt;v) return o; return x &lt; o-&gt;v ? find(o-&gt;ch[0], x) : find(o-&gt;ch[1], x);&#125;void remove(Node* &amp;o, int x) &#123; int d = o-&gt;cmp(x); if(d == -1) &#123; Node* u = o; if(o-&gt;ch[0] != NULL &amp;&amp; o-&gt;ch[1] != NULL) &#123; int d2 = (o-&gt;ch[0]-&gt;r &gt; o-&gt;ch[1]-&gt;r ? 1 : 0); rotate(o, d2); remove(o-&gt;ch[d2], x); &#125; else &#123; if(o-&gt;ch[0] == NULL) o = o-&gt;ch[1]; else o = o-&gt;ch[0]; delete u; &#125; &#125; else remove(o-&gt;ch[d], x); if(o != NULL) o-&gt;maintain();&#125;int kth(Node* o, int k) &#123; if(o == NULL || k &lt;= 0 || k &gt; o-&gt;s) return 0; int s = (o-&gt;ch[0] == NULL ? 0 : o-&gt;ch[0]-&gt;s); if(k == s+1) return o-&gt;v; else if(k &lt;= s) return kth(o-&gt;ch[0], k); else return kth(o-&gt;ch[1], k-s-1);&#125;int rank(Node* o, int x) &#123; if(o == NULL) return 1; if(x &lt;= o-&gt;v) return rank(o-&gt;ch[0], x); return rank(o-&gt;ch[1], x) + (o-&gt;ch[0] == NULL ? 0 : o-&gt;ch[0]-&gt;s) + 1;&#125;int prefix(Node *o, int k,int c) &#123; if (o == NULL) return c; if (k &gt; o-&gt;v) return prefix(o-&gt;ch[1],k,o-&gt;v); else return prefix(o-&gt;ch[0],k,c);&#125;int suffix(Node *o, int k,int c) &#123; if (o == NULL) return c; if (k &lt; o-&gt;v) return suffix(o-&gt;ch[0],k,o-&gt;v); else return suffix(o-&gt;ch[1],k,c);&#125;const int INF = INT_MAX &gt;&gt; 1;/*void dfs(Node *o)&#123; if (o == NULL) return ; printf("%d\n",o-&gt;v); printf("LC of %d:\n",o-&gt;v);dfs(o-&gt;ch[0]); printf("RC of %d:\n",o-&gt;v); dfs(o-&gt;ch[1]); printf("EO %d!\n\n",o-&gt;v); &#125;*/int main(int argc, char *argv[]) &#123; srand(int(time(NULL))); int m, c, v; Node* root = new Node(INF); scanf("%d", &amp;m); while(m--) &#123; scanf("%d%d", &amp;c, &amp;v); if(c == 1) insert(root, v); else if(c == 2) &#123; Node* o = find(root, v); if(o != NULL) remove(root, v); &#125; else if(c == 3) printf("%d\n", rank(root, v)); else if(c == 4) printf("%d\n", kth(root,v)); else if(c == 5) printf("%d\n",prefix(root,v,0)); else printf("%d\n",suffix(root,v,0)); &#125; return 0;&#125; Splay(LUOGU P3391/BZOJ 3223ÂèØÈ£üÁî®)(Â•ΩÂÉèÂè´SpalyÁöÑ‰πüÊúâ Â§ßÈõæ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5+10; struct Node &#123; Node* ch[2]; int v,s,flip; int cmp(int k) &#123; int d=k-ch[0]-&gt;s; if(d==1) return -1; return d&lt;=0? 0:1; &#125; void maintain() &#123; s=ch[0]-&gt;s+ch[1]-&gt;s+1; &#125; void pushdown() &#123; if(flip) &#123; flip=0; swap(ch[0],ch[1]); ch[0]-&gt;flip^=1; ch[1]-&gt;flip^=1; &#125; &#125;&#125;;Node* null=new Node();void rotate(Node* &amp;o,int d) &#123; Node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o-&gt;maintain(),k-&gt;maintain(); o=k;&#125;void splay(Node* &amp;o,int k) &#123; o-&gt;pushdown(); int d=o-&gt;cmp(k); if(d==1) k-=o-&gt;ch[0]-&gt;s+1; if(d!=-1) &#123; Node* p=o-&gt;ch[d]; p-&gt;pushdown(); int d2=p-&gt;cmp(k); int k2=d2==0? k:k-p-&gt;ch[0]-&gt;s-1; if(d2!=-1) &#123; splay(p-&gt;ch[d2],k2); if(d==d2) rotate(o,d^1); else rotate(o-&gt;ch[d],d); &#125; rotate(o,d^1); &#125;&#125;Node* merge(Node* left,Node* right) &#123; splay(left,left-&gt;s); left-&gt;ch[1]=right,left-&gt;maintain(); return left;&#125;void split(Node* o,int k,Node* &amp;left,Node* &amp;right) &#123; splay(o,k); left=o,right=left-&gt;ch[1],left-&gt;ch[1]=null; left-&gt;maintain();&#125;struct SplaySequence &#123; int n; Node seq[maxn]; Node* root; Node* build(int sz) &#123; if(!sz) return null; Node* l=build(sz/2); Node* o=&amp;seq[++n]; o-&gt;v=n; o-&gt;ch[0]=l; o-&gt;ch[1]=build(sz-sz/2-1); o-&gt;flip=o-&gt;s=0; o-&gt;maintain(); return o; &#125; void init(int sz) &#123; n=null-&gt;s=0; root=build(sz); &#125;&#125; spaly;vector&lt;int&gt; ans;void print(Node* o) &#123; if(o!=null) &#123; o-&gt;pushdown(); print(o-&gt;ch[0]); ans.push_back(o-&gt;v); print(o-&gt;ch[1]); &#125;&#125;int read() &#123; char c=getchar(); while(!isdigit(c)) c=getchar(); int x=0; while(isdigit(c)) &#123; x=x*10+c-'0'; c=getchar(); &#125; return x;&#125;int n,m;int main(int argc, char *argv[]) &#123; n=read(),m=read(); spaly.init(n+1); int l,r; Node *left,*right,*mid; while(m--) &#123; l=read(),r=read(); split(spaly.root,l,left,right); split(right,r-l+1,mid,right); mid-&gt;flip^=1; spaly.root = merge(merge(left,mid),right); &#125; print(spaly.root); for(int i=1; i&lt;ans.size(); i++) printf("%d ",ans[i]-1); return 0;&#125; Scapegoat(LUOGU P3369/BZOJ 3224ÂèØÈ£üÁî®)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;#include&lt;vector&gt;using namespace std;const double alpha=0.7;struct scapegoat&#123; scapegoat *l,*r; int val,size,cnt; bool deleted; bool is_bad()&#123;return (l-&gt;cnt &gt; alpha*cnt+5 || r-&gt;cnt &gt; alpha*cnt+5);&#125; void maintain()&#123;size=!deleted+l-&gt;size+r-&gt;size; cnt=1+r-&gt;cnt+l-&gt;cnt;&#125;&#125;;scapegoat *null;void dfs(scapegoat *o,vector&lt;scapegoat*&gt; &amp;v)&#123; if(o == null) return; dfs(o-&gt;l,v); if(!o-&gt;deleted) v.push_back(o); dfs(o-&gt;r,v); if(o-&gt;deleted) delete o;&#125;scapegoat *build(vector&lt;scapegoat*&gt; &amp;v,int l,int r)&#123; if(l &gt;= r) return null; int mid = (l+r) &gt;&gt; 1; scapegoat *o = v[mid]; o-&gt;l = build(v,l,mid); o-&gt;r = build(v,mid+1,r); o-&gt;maintain(); return o;&#125;void rebuild(scapegoat* &amp;o)&#123; vector&lt;scapegoat*&gt; v; dfs(o,v); o = build(v,0,v.size());&#125;void insert(int x,scapegoat* &amp;o)&#123; if(o==null) &#123; o=new scapegoat; o-&gt;l=o-&gt;r=null; o-&gt;deleted=false; o-&gt;size=o-&gt;cnt=1; o-&gt;val=x; return; &#125; else &#123; ++o-&gt;size; ++o-&gt;cnt; if(x&gt;=o-&gt;val) insert(x,o-&gt;r); else insert(x,o-&gt;l); if(o-&gt;is_bad())rebuild(o); &#125;&#125;int rank(scapegoat *now,int x) &#123; int ans=1; while(now!=null) &#123; if(now-&gt;val&gt;=x)now=now-&gt;l; else &#123; ans+=now-&gt;l-&gt;size+!now-&gt;deleted; now=now-&gt;r; &#125; &#125; return ans; &#125;int kth(scapegoat *now,int x)&#123; while(now!=null) &#123; if(!now-&gt;deleted &amp;&amp; now-&gt;l-&gt;size+1==x) return now-&gt;val; if(now-&gt;l-&gt;size&gt;=x)now=now-&gt;l; else &#123; x-=now-&gt;l-&gt;size+!now-&gt;deleted; now=now-&gt;r; &#125; &#125;&#125;void erase(scapegoat *o,int rk)&#123; if(!o-&gt;deleted &amp;&amp; rk==o-&gt;l-&gt;size+1) &#123; o-&gt;deleted=1; --o-&gt;size; return; &#125; --o-&gt;size; if(rk&lt;=o-&gt;l-&gt;size+!o-&gt;deleted) erase(o-&gt;l,rk); else erase(o-&gt;r,rk-o-&gt;l-&gt;size-!o-&gt;deleted);&#125;inline void read(int &amp;a)&#123; int negativ = 1; a = 0; char c = getchar(); while(!isdigit(c))&#123;if(c == '-') negativ = -1; c = getchar();&#125; while(isdigit(c)) &#123;a = a*10+c-'0';c = getchar();&#125; a *= negativ;&#125;scapegoat *root;int main(int argc, char *argv[])&#123; null = new scapegoat; root = null; int n; read(n); while(n--) &#123; int op,x; read(op); read(x); if(op==1)insert(x,root); if(op==2)erase(root,rank(root,x)); if(op==3)printf("%d\n",rank(root,x)); if(op==4)printf("%d\n",kth(root,x)); if(op==5)printf("%d\n",kth(root,rank(root,x)-1)); if(op==6)printf("%d\n",kth(root,rank(root,x+1))); &#125; return 0; &#125;]]></content>
      <categories>
        <category>Âπ≥Ë°°Ê†ë</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Regular Contest arc 091-092 Âàá(W)È¢ò(A)ËÆ∞]]></title>
    <url>%2F2018%2F03%2F27%2FAtcoder-Regular-Contest-arc-091-092-%E5%88%87-W-%E9%A2%98-A-%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Ê¶ÇËø∞‰∏äÂçàÈó≤ÁùÄÊ≤°‰∫ãÂ∞±Êâæ‰∫ÜÁÇπAtcoderÁöÑÔºàÊ∞¥ÔºâÈ¢òÂàáÂàá, È°∫‰æøËøá‰∏Ä‰∏ãÂçöÂºàÂíåSGÂáΩÊï∞„ÄÇ Atcoder Regular Contest 091 C Flip,Flip,and FlipARC 091C ÂïèÈ°åÊñá Á∏¶Ê®™„Å´ÁÑ°Èôê„Å´Â∫É„Åå„Çã„Éû„ÇπÁõÆ„Åå„ÅÇ„Çä„ÄÅ„Åù„ÅÆ„ÅÜ„Å°„ÅÆÈÄ£Á∂ö„Åô„Çã N Ë°å M Âàó„ÅÆÈ†òÂüü„ÅÆ„Åô„Åπ„Å¶„ÅÆ„Éû„Çπ„Å´Ë°®Ë£è„ÅÆÂå∫Âà•„Åß„Åç„Çã„Ç´„Éº„Éâ„ÅåÁΩÆ„Åã„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ ÊúÄÂàù„ÅØ„Åô„Åπ„Å¶„ÅÆ„Ç´„Éº„Éâ„ÅåË°®„ÇíÂêë„ÅÑ„Å¶„ÅÑ„Åæ„Åô„ÄÇ ‰ª•‰∏ã„ÅÆÊìç‰Ωú„Çí„ÄÅ„Ç´„Éº„Éâ„ÅåÁΩÆ„Åã„Çå„Å¶„ÅÑ„ÇãÂÖ®„Å¶„ÅÆ„Éû„Çπ„Å´„Å§„ÅÑ„Å¶ 1 Â∫¶„Åö„Å§Ë°å„ÅÑ„Åæ„Åô„ÄÇ „Åù„ÅÆ„Éû„Çπ„Å®Ëæ∫„Åæ„Åü„ÅØÁÇπ„ÅßÊé•„Åô„Çã 8 „Å§„ÅÆ„Éû„Çπ„Å®„ÄÅ„Åù„ÅÆ„Éû„Çπ„ÅÆÂêàË®à 9 „Éû„Çπ„Å´„Å§„ÅÑ„Å¶„ÄÅ„Ç´„Éº„Éâ„ÅåÂ≠òÂú®„Åô„Çã„Å™„ÇâË£èËøî„Åô„ÄÇ „Åô„Åπ„Å¶„ÅÆÊìç‰Ωú„ÇíË°å„Å£„ÅüÂæå„ÅÆÂêÑ„Ç´„Éº„Éâ„ÅÆÁä∂ÊÖã„ÅØÊìç‰Ωú„ÇíË°å„ÅÜÈ†ÜÁï™„Å´‰æù„Çâ„Å™„ÅÑ„Åì„Å®„ÅåË®ºÊòé„Åß„Åç„Åæ„Åô„ÄÇ „Åô„Åπ„Å¶„ÅÆÊìç‰Ωú„ÇíË°å„Å£„ÅüÂæå„ÄÅË£è„ÇíÂêë„ÅÑ„Å¶„ÅÑ„Çã„Ç´„Éº„Éâ„ÅÆÊûöÊï∞„ÇíÊ±Ç„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ Â§ßÊÑè ÈóÆÈ¢òÈôàËø∞ÊúâÊó†ÈôêÈïøÂ∫¶ÂíåÂÆΩÂ∫¶ÁöÑÊ≠£ÊñπÂΩ¢Â±ïÂºÄÔºåÂπ∂‰∏îÂèØ‰ª•Âå∫ÂàÜÊ≠£Èù¢ÂíåËÉåÈù¢ÁöÑÁâåË¢´ÊîæÁΩÆÂú®ËøûÁª≠ÁöÑnË°åÂíåmÂàó‰∏≠ÁöÑÊâÄÊúâÂçïÂÖÉ‰∏≠„ÄÇÊúÄÂàùÊâÄÊúâÁâåÈÉΩÈù¢ÊúùÊ°åÂ≠ê„ÄÇÂØπ‰∫éÊîæÁΩÆÂç°ÁöÑÊØè‰∏™ÊñπÂùóÊâßË°å‰∏ÄÊ¨°‰ª•‰∏ãÊìç‰Ωú„ÄÇÂ¶ÇÊûúÊúâ8‰∏™ÊñπÊ†ºÈÇªÊé•ÈÇ£‰∏™Ê≠£ÊñπÂΩ¢ÂíåËæπÊàñËÄÖÁÇπÔºåÂπ∂‰∏îÂ¶ÇÊûúÊúâ‰∏ÄÂº†Âç°ÔºåÂàôÊÄªÂÖ±9‰∏™ÊñπÊ†º„ÄÇÊÇ®ÂèØ‰ª•ËØÅÊòéÊâßË°åÊâÄÊúâÊìç‰ΩúÂêéÊØèÂº†Âç°ÁöÑÁä∂ÊÄÅ‰∏çÂèñÂÜ≥‰∫éÊìç‰ΩúÈ°∫Â∫è„ÄÇÂÆåÊàêÊâÄÊúâÊìç‰ΩúÂêéÔºåËØ∑ÊâæÂà∞ËÉåÈù¢ÁöÑÂç°ÁâáÊï∞Èáè„ÄÇ Ê≥®ÊÑèÁªÜËäÇÁâπÂà§1,1ÁöÑÊÉÖÂÜµ. 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longinline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;signed main(signed argc, char *argv[])&#123; int n = read(), m = read(); if (n == 1 &amp;&amp; m == 1) printf("1\n"); else if (n == 1) printf("%lld\n",m-2); else if (m == 1) printf("%lld\n",n-2); else printf("%lld\n",n*m-(n+m)*2+4); return 0;&#125; Atcoder Regular Contest 091 D Remainder ReminderARC 091D ÂïèÈ°åÊñáÈ´òÊ©ãÂêõ„ÅØ„ÄÅN ‰ª•‰∏ã„ÅÆÊ≠£„ÅÆÊï¥Êï∞„ÅÆ 2 „Å§ÁµÑ (a,b) „ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åó„Åü„Åå„ÄÅÂøò„Çå„Å¶„Åó„Åæ„ÅÑ„Åæ„Åó„Åü„ÄÇ È´òÊ©ãÂêõ„ÅØ„ÄÅa „Çí b „ÅßÂâ≤„Å£„Åü„ÅÇ„Åæ„Çä„Åå K ‰ª•‰∏ä„Åß„ÅÇ„Å£„Åü„Åì„Å®„ÇíË¶ö„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ È´òÊ©ãÂêõ„ÅåÊåÅ„Å£„Å¶„ÅÑ„ÅüÁµÑ„Å®„Åó„Å¶„ÅÇ„Çã„ÅÜ„Çã„ÇÇ„ÅÆ„ÅÆÂÄãÊï∞„ÇíÊ±Ç„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ Âà∂Á¥Ñ 1‚â§N‚â§105 0‚â§K‚â§N‚àí1 ÂÖ•Âäõ„ÅØÂÖ®„Å¶Êï¥Êï∞„Åß„ÅÇ„Çã Â§ßÊÑè ÁªôÂá∫ÈôêÂà∂$N,K$,Ê±ÇÊª°Ë∂≥ a,b \leq N,‰ª§a\equiv x(mod \space b),K\leq x\leq b-1ÁöÑÊñπÊ°àÊï∞ËÄÉËôëbÁöÑËåÉÂõ¥‰∏∫$[K+1,N]$ Áõ¥Êé•Êûö‰∏æb,ÁÑ∂ÂêéÁÆóÂá∫ÂØπÂ∫îËåÉÂõ¥‰∏ãÁöÑ$x$‰∏™Êï∞Ôºå‰ΩÜÊòØÊ≥®ÊÑèxmaxÂêéÊúâ‰∏ÄÈÉ®ÂàÜÂâ©‰Ωô. Ê≥®ÊÑèÁªÜËäÇ„ÄÇÔºàÊàëÁâπ‰πàWA‰∫Ü‰∏§Ê¨°ÂïäÁúüÂΩ©Á¨îÔºâ 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longinline int read(void)&#123; int x = 0,f = 1; char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x * f;&#125;signed main(signed argc, char *argv[])&#123; int ans = 0; int N = read(),K = read(); if (K == 0) &#123; N *= N; cout &lt;&lt; N; return 0; &#125; for (int b = K+1; b &lt;= N; b++) &#123; int xmax = (N)/(b); //cout &lt;&lt; xmax &lt;&lt; " # " &lt;&lt; "\n"; ans += xmax * (b-K); ans += max(0LL,(N - b * xmax) - K + 1); //cout &lt;&lt; ans &lt;&lt; endl; &#125; cout &lt;&lt; ans; return 0;&#125; Atcoder Regular Contest 091 F Strange NimARC 091F ÂïèÈ°åÊñáÈ´òÊ©ãÂêõ„Å®ÈùíÊú®Âêõ„ÅØ„ÄÅÁü≥Âèñ„Çä„Ç≤„Éº„É†„Çí„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÊúÄÂàù„ÄÅÂ±±„Åå N ÂÄã„ÅÇ„Çä„ÄÅi ÂÄãÁõÆ„ÅÆÂ±±„Å´„ÅØ A**i ÂÄã„ÅÆÁü≥„Åå„ÅÇ„Çä„ÄÅÊï¥Êï∞ K**i „ÅåÂÆö„Åæ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ È´òÊ©ãÂêõ„Å®ÈùíÊú®Âêõ„ÅØ„ÄÅÈ´òÊ©ãÂêõ„Åã„ÇâÂßã„ÇÅ„Å¶„ÄÅ‰∫§‰∫í„Å´‰ª•‰∏ã„ÅÆÊìç‰Ωú„ÇíÁπ∞„ÇäËøî„Åó„Åæ„Åô„ÄÇ Â±±„Çí 1 „Å§ÈÅ∏„Å∂„ÄÇi ÂÄãÁõÆ„ÅÆÂ±±„ÇíÈÅ∏„Å≥„ÄÅ„Åù„ÅÆÂ±±„Å´ X ÂÄã„ÅÆÁü≥„ÅåÊÆã„Å£„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅ1 ÂÄã‰ª•‰∏ä floor(X‚ÅÑK**i) ÂÄã‰ª•‰∏ã„ÅÆ‰ªªÊÑè„ÅÆÂÄãÊï∞„ÅÆÁü≥„Çí i ÂÄãÁõÆ„ÅÆÂ±±„Åã„ÇâÂèñ„ÇäÈô§„Åè„ÄÇ ÂÖà„Å´Êìç‰Ωú„Åå„Åß„Åç„Å™„Åè„Å™„Å£„Åü„Éó„É¨„Ç§„É§„Éº„ÅåË≤†„Åë„Åß„Åô„ÄÇ‰∏°ËÄÖÊúÄÂñÑ„ÇíÂ∞Ω„Åè„Åó„Åü„Å®„Åç„ÄÅ„Å©„Å°„Çâ„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅåÂãù„Å§„ÅãÂà§ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ „Åü„Å†„Åó„ÄÅfloor(x) „Åß x ‰ª•‰∏ã„ÅÆÊúÄÂ§ß„ÅÆÊï¥Êï∞„ÇíË°®„Åó„Åæ„Åô„ÄÇ Â§ßÊÑè: ÁªônÂ†ÜÁü≥Â≠êÔºåÊØèÂ†ÜÊúâ‰∏ÄÂºÄÂßãÊúâai‰∏™Âíå‰∏Ä‰∏™Â∏∏Êï∞ki„ÄÇ‰∏§‰∏™‰∫∫ËΩÆÊµÅÊìç‰ΩúÔºåÊØè‰∏™‰∫∫ÊØèËΩÆÂèØ‰ª•ÈÄâ‰∏ÄÂ†ÜÁü≥Â≠êÔºåÁÑ∂ÂêéÂú®ÂÖ∂‰∏≠ÂèñËµ∞1Âà∞$\large\frac{a_i}{k_i}$,Ë∞Å‰∏çËÉΩÊìç‰ΩúÂ∞±ÁÆóËæìÔºåÈóÆÂÖàÊâãÂøÖËÉúËøòÊòØÂêéÊâãÂøÖËÉú„ÄÇ SGÂáΩÊï∞+Êö¥Âäõ ‰∏çÈöæÂèëÁé∞SGÂáΩÊï∞ÈÄíÊé®Âºè$SG(x) = SG(x-x/k-1)$ Âõ†‰∏∫ÊØè‰∏ÄÊ¨°kÈÉΩÊòØÊÅíÁ≠âÁöÑÔºåËÄÉËôëÁõ¥Êé•‰∏ÄÊ≠•Áî®ÂèñÊ®°Ë∑≥Âà∞Â∞±Ë°åÔºå‰∏çÁÑ∂TÈ£û„ÄÇ 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 210;string s1 = "Takahashi",s2 = "Aoki";inline int read(void)&#123; int x = 0,f = 1; char ch = cin.get(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = cin.get();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = cin.get();&#125; return x * f;&#125;int main(int argc, char *argv[])&#123; ios::sync_with_stdio(false); int n = read(); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int x = read() , k = read(); while((x%k)) x -= ((x%k-1)/(x/k+1)+1) * (x/k+1); ans ^= x/k; &#125; if (ans) cout &lt;&lt; s1; else cout &lt;&lt; s2; return 0;&#125;]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁîüÊàêÂáΩÊï∞Â≠¶‰π†Á¨îËÆ∞[Âπ≤Ë¥ß]]]></title>
    <url>%2F2018%2F03%2F09%2F%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B9%B2%E8%B4%A7%2F</url>
    <content type="text"><![CDATA[Ê¶ÇËÆ∫ÁîüÊàêÂáΩÊï∞ÁÆóÊòØ‰∏ÄÁßçÊó¢ÁÆÄÂçïÂèàÊúâÁî®ÁöÑÊï∞Â≠¶ÊñπÊ≥ï,‰∏ÄËà¨Áî®Êù•Ëß£ÂÜ≥ÁªÑÂêàÊäÄÊúØÈóÆÈ¢ò,ËÄå‰∏îÊòØ‰∏ÄÁßçÊúÄÈáçË¶ÅÁöÑ‰∏ÄËà¨ÊÄßÂ§ÑÁêÜÊñπÊ≥ï. Â°´ÂÆåÂùëÂÜçÂàí ‰∏ªË¶ÅÂèÇËÄÉËµÑÊñô:&lt;ÁªÑÂêàÊï∞Â≠¶ÂºïËÆ∫(‰∏≠ÁßëÂ§ß)&gt; ÂºïËÆ∫ÂØπ‰∫é‰∏Ä‰∏™ÊúâÈôêÊï∞ÂàóÊàñËÄÖÊó†ÈôêÊï∞Âàó \{ a_0,a_1,a_2,... \}Êàë‰ª¨Áî®ÂπÇÁ∫ßÊï∞ A(x) = a_0+a_1x+a_2x^2+...\\\\ =\sum_{i=0}^{\infty}a_ix^iÊù•‰Ωø‰πã‰∏∫‰∏Ä‰∏™Êï¥‰ΩìÔºåÊàë‰ª¨Áõ∏ÂΩì‰∫éÁî®ËøôÊ†∑ÁöÑ‰∏Ä‰∏™Êàë‰ª¨Ëá™Â∑±ÊûÑÈÄ†Âá∫Êù•ÁöÑÂáΩÊï∞ÂéªÁ†îÁ©∂Êï¥‰∏™ÂáΩÊï∞ÁöÑÊÄßË¥®„ÄÇ ËÄå‰∏çÂøÖÂçï‰∏™Âú∞Á†îÁ©∂.ÁâπÂà´Âú∞,Êàë‰ª¨Êää$A(x)$Áß∞‰∏∫ËØ•Â∫èÂàóÁöÑÁîüÊàêÂáΩÊï∞,ËÆ∞‰∏∫$G{a_n }$. ÂØπ‰∫éÁâπÊÆäÊÉÖÂÜµÊØîÂ¶ÇÁªÑÂêàÊï∞Âàó \{ \binom{n}{0}\binom{n}{1},\cdot\cdot\cdot,\binom{n}{n}\}Ê†πÊçÆ‰∏äËø∞ÁöÑÂÆö‰πâ,‰ª§ÂÖ∂ÁîüÊàêÂáΩÊï∞‰∏∫$f_n(x)$,ÂàôÊúâ f_n(x)=\binom{n}{0}+\binom{n}{1}x+\cdot\cdot\cdot+\binom{n}{n}x^nÁî±‰∫åÈ°πÂºèÂÆöÁêÜ‰∏çÈöæÂæóÂà∞ f_n(x)=(1+x)^nÈÇ£‰πàÂ∞±ÂèØ‰ª•ÂØπËøô‰∏™Áé©ÊÑèËøõË°åÂçïÁã¨Á†îÁ©∂‰∫ÜÊØîÂ¶ÇÊàë‰ª¨ÂÅáËÆæË¶ÅÊ±Ç ‚Äã \sum_{i=0}^n\binom{n}{i}ÂÆûÈôÖ‰∏äÂ∞±ÊòØ$x=1$ÁöÑÊÉÖÂÜµ.‰ª£ÂÖ•ÂêéÂ∞±ÊòØ$2^n$. ÊàñËÄÖÂÜçÊØîÂ¶ÇÊ±Ç \sum_{i=1}^ni\binom{n}{i}\\\\hjqÁû¨Èó¥Áî®ÁªÑÂêàÊÑè‰πâÁßíÊéâ.%%%%% Ëøô‰∏™ÂºèÂ≠ê,Áõ∏ÂΩì‰∫éÂú®$n$‰∏™ÁêÉ‰∏≠ÈÄâÂá∫$i$‰∏™Âπ∂‰∏îÁªô‰πã‰∏≠ÁöÑ‰∏Ä‰∏™ÊüìËâ≤ÁöÑÊï∞Èáè ÈÇ£‰πàÂÖàÊüì‰∏Ä‰∏™ÂÜçÈÄâÊã©ÊòæÁÑ∂ÊòØÁ≠â‰ª∑ÁöÑ.ÊâÄ‰ª•Â∞±ÊòØ‰∏ãÈù¢ÁöÑÂºèÂ≠ê‰∫Ü. Áî®‰∫åÈ°πÂºèÁöÑËØùÁî®ÂÆπÊñ•ÂéüÁêÜ‰∏çÈöæÂæóÂà∞ \sum_{i=1}^ni\binom{n}{i}\\\\ =n \times 2^{n-1}Áî±ÊÅíÁ≠âÂºè (1+x)^{m+n}=(1+x)^m(1+x)^n\\\\ \longrightarrow\space\binom{m+n}{r} = \sum_{k=0}^r\binom{m}{k}\binom{n}{r-k}Â•Ω‰∫Ü‰∏äÈù¢ÈÉΩÊòØÁé©Ê≥•Â∑¥~~ ‰æã1‰∏¢‰∏Ä‰∏™Ê†óÂ≠ê ÂÅáËÆæ‰Ω†Êúâ‰∏Ä‰∏™Ê≠£Â∏∏ÁöÑÈ™∞Â≠êÔºàÂÖ≠‰∏™Èù¢ÁöÑÈÇ£ÁßçÔºâÔºå‰∏îÊé∑Âá∫ÊØè‰∏™Èù¢ÁöÑÊ¶ÇÁéáËøë‰ººËÆ§‰∏∫Áõ∏Á≠âÔºà$\frac{1}{6}$Ôºâ. ËøûÁª≠‰∏¢Âá∫‰∏§Ê¨°,ÈóÆÊé∑Âá∫Âíå‰∏∫10ÁöÑÊ¶ÇÁéá‰∏∫Â§öÂ∞ëÔºü Á≠î:‰Ω†ÊÄï‰∏çÊòØ‰∏™zzÂêß,Ëøô‰πàÁÆÄÂçïÁöÑÈóÆÈ¢ò‰Ω†‰πüÊï¢ÈóÆÔºü Â•Ω,ËøûÁª≠‰∏¢Âá∫ÂçÅÊ¨°,ÈóÆÊé∑Âá∫Âíå‰∏∫30ÁöÑÊ¶ÇÁéá‰∏∫Â§öÂ∞ëÔºü Ê≤°ËØùËØ¥‰∫ÜÂêß Ëß£Ôºö Áî®ÁîüÊàêÂáΩÊï∞ÁöÑÊÄùÊÉ≥Êù•ÔºåÊääÊØè‰∏Ä‰∏™ÂíåÁúã‰ΩúÂÖ≥‰∫éÁÇπÊï∞(1,2,3,4,5,6)ÁöÑÂ§öÈ°πÂºè‰πòÁßØ. ‰πüÂ∞±ÊòØ$x+x^2+x^3+x^4+x^5+x^6$. ÈÇ£‰πà,ÂÖ≥‰∫éÁ¨¨‰∫å‰∏™ÈóÆÈ¢ò,ËΩ¨Êç¢‰∏∫ (x+x^2+x^3+x^4+x^5+x^6)^{10}‰∏äËø∞Ëøô‰∏™ÂºèÂ≠ê‰∏≠,ÈóÆ‰Ω†$x^{30}$ÁöÑÁ≥ªÊï∞„ÄÇ ËøòÊòØÂæàÈöæÂÅöÂØπ‰∏çÂØπ,ËÄÉËôëÂåñÁÆÄ (x+x^2+x^3+x^4+x^5+x^6)^{10}\\\\ =(x(1+x+x^2+x^3+x^4+x^5))^{10}\\\\ ÂèëÁé∞x=-1ÊòØÂéüÂºèÂõ†Âºè.\\\\ ‰∏ÄÈ°øÂ§ßÈô§Ê≥ï.\\\\ \longrightarrow\space =[(x^2+x+1)(x^2-x+1)]^{10}\times x^{10} \times (x+1)^{10}Â•ΩÁöÑÊàë‰ª¨Â§¥ÁöÆÂèëÈ∫ªËÄå‰∏îÂèëÁé∞Ëøô‰∏™ÂºèÂ≠êÂØπÊàë‰ª¨ÊúÄÁªàËÆ°ÁÆó$x^{30}$ÁöÑÁ≥ªÊï∞Ê≤°Êúâ‰ªª‰ΩïÁöÑÂçµÁî®. ‰∏∫‰ªÄ‰πàÔºüÂõ†‰∏∫Êàë‰ª¨‰∏ç‰ºö‰∏âÈ°πÂºèÂ±ïÂºÄÔºå‰ΩÜÊòØÂ¶ÇÊûú‰∏çËøõË°åÂõ†ÂºèÂàÜËß£È°πÊï∞ËÇØÂÆö‰ºöÊõ¥Â§ßÊàë‰ª¨Êõ¥‰∏ç‰ºöÁÆóÔºÅ ËÄÉËôëÂèçËøáÊù•,Â¶ÇÊûúÊääÂéüÂºèÂÜôÊàê‰∏§‰∏™‰∫åÈ°πÂºèÁöÑÂïÜ‰πüÂèØ‰ª•. (1+x+x^2+x^3+x^4+x^5)\\\\ =\frac{(1-x^6)}{1-x}\\\\ ÈÇ£‰πàÂéüÊù•ÁöÑÂºèÂ≠ê(x+x^2+x^3+x^4+x^5+x^6)^{10}\\\\ =x^{10}(1-x^6)^{10}(1-x)^{-10}\\\\Êâî‰∏ä‰∫åÈ°πÂºèÂÆöÁêÜ\\\\ ÂèàÂõ†‰∏∫10Ê¨°ÊòØÂÅ∂Êï∞Ê¨°,(1-x^6)ÂÜôÊàê(x^6-1)ÔºåÂêéÈù¢ÁöÑÂêåÁêÜ\\\\ \rightarrow x^{10}\times\sum_{i=0}^{10}(-1)^i\binom{10}{i}x^{6i}\times\sum_{k=0}^{\infty}\binom{10+k-1}{k}x^kÂ•Ω‰∫ÜÊääÂâçÈù¢ÁöÑ$x^{10}$ÊâîÊéâÂêéÈù¢ÁöÑÊûÑÈÄ†Âá∫i,kÊª°Ë∂≥xÁöÑÊ¨°Êï∞‰∏∫20Â∞±Ë°åËæ£. ‰∏ÄÂÖ±iÂè™ÂèØËÉΩÂèñ0,1,2,3Êûö‰∏æÂ∞±Ë°å. Á≠îÊ°à‰ºº‰πéÈïøËøô‰∏™Ê†∑Â≠ê \binom{29}{20}-\binom{10}{1}\binom{23}{14}+\binom{17}{8}\binom{10}{2}-\binom{10}{3}\binom{11}{2}ÂèçÊ≠£ÊàëÊòØÊáíÂæóÁÆóÁ≠îÊ°à‰∫Ü. ÁîüÊàêÂáΩÊï∞ÁöÑÊÄßË¥®ÁîüÊàêÂáΩÊï∞ÁöÑÂΩ¢ÂºèÂØºÊï∞ÂÆö‰πâ \forall A(x)=\sum_{k=0}^{\infty}a_kx^k \in R[[x]]\\\\ ÂÆö‰πâDA\equiv\sum_{k=1}^{\infty}ka_kx^{k-1}\\\\ Áß∞‰ΩúA(x)Âú®R[[x]]‰∏äÁöÑÂΩ¢ÂºèÂØºÊï∞.ÂΩ¢ÂºèÂØºÊï∞ÁöÑËøêÁÆóÊ≥ïÂàôÂíåÊôÆÈÄöÂØºÊï∞Â∑Æ‰∏çÂ§ö. Âä†Ê≥ïÂàô‰πòÊ≥ïÂàôÈÉΩÊª°Ë∂≥ÁöÑ.‰ΩÜÊòØ‰ºº‰πéÊ≤°ÊúâÂØπÈìæÂØºÊ≥ïÂàôÁöÑÂÆö‰πâ. ÁîüÊàêÂáΩÊï∞‰∏ªË¶ÅÂ∏∏Áî®ÊÄßË¥®]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI-2012] ÂñµÊòüÁêÉ‰∏äÁöÑÁÇπÂêç ACËá™Âä®Âß¨+map]]></title>
    <url>%2F2018%2F03%2F08%2FSCOI-2012-%E5%96%B5%E6%98%9F%E7%90%83%E4%B8%8A%E7%9A%84%E7%82%B9%E5%90%8D-AC%E8%87%AA%E5%8A%A8%E5%A7%AC-map%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢BZOJ-2754 ÂàÜÊûêÁõ¥Êé•Êö¥ÂäõÂØπÊØè‰∏™‰∏≤ÂºÄ‰∏™mapÂª∫ACËá™Âä®Âß¨. ÂÜôËµ∑Êù•ÂÖ∂ÂÆû‰∏çÈöæÁöÑ,ÊÄùÁª¥ÈöæÂ∫¶‰πü‰∏çÊòØÂæàÈ´ò.‰∏ªË¶ÅÁöÑÊäÄÂ∑ßÂú®‰∫éÂ∏∏Êï∞ÁöÑÂ§ÑÁêÜ. Áúã‰∏äÂéªÁ©∫Èó¥ÁàÜÁÇ∏‰ΩÜÊòØÂ±ÖÁÑ∂Ëøá‰∫Ü!! LUOGUÂ•ΩÂÉèÂä†‰∫Ü‰∏ÄÁªÑÊÅ∂ÂøÉÊï∞ÊçÆÂç°Êéâ‰∫ÜËøôÁßçËæ£È∏°ÂÅöÊ≥ï Â•ΩÂêßÂÖ∂ÂÆûÊ≠£Ëß£Â•ΩÂÉèË¶ÅÁî®Âà∞‰∏ªÂ∏≠Ê†ëÂèØÊÉúÊàëËøò‰∏ç‰ºö. ËèúÂïä qwq ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+4;#define RG registerinline int read(void)&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;f=ch=='-'?-1:1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x*f;&#125;int n,m,ans1[maxn],ans2[maxn];vector&lt;int&gt;a[maxn&lt;&lt;1],status[maxn],V,M;bool vis[maxn],mk[maxn];map&lt;int,int&gt;to[maxn];map&lt;int,int&gt;::iterator it;struct Aho_Corasick&#123; int cnt,ans; int fail[maxn],q[maxn]; Aho_Corasick() &#123; cnt = 1; for (RG int i = -1; i &lt;= 1e4; i++) to[0][i] = 1; fail[1] = 0; &#125; void Insert(int id) &#123; int L = read(),nn = 1; for (RG int i = 1; i &lt;= L; i++) &#123; int x = read(); if (!to[nn][x]) to[nn][x]=++cnt; nn = to[nn][x]; &#125; status[nn].push_back(id); &#125; void build_fail() &#123; queue&lt;int&gt;q; q.push(1); while(!q.empty()) &#123; int tmp = q.front(); q.pop(); for (it = to[tmp].begin(); it != to[tmp].end(); it++) &#123; int t1 = it-&gt;first,t2 = it-&gt;second; int k = fail[tmp]; //printf("%d %d %d\n",t1,t2,k); while(!to[k][t1]) k = fail[k]; fail[t2] = to[k][t1]; q.push(t2); &#125; &#125; &#125; void get(int id,int x) &#123; for (RG int i = x; i != 0; i = fail[i]) if (!vis[i]) &#123; vis[i] = 1; V.push_back(i); for (RG int j = 0; j &lt; status[i].size(); j++) &#123; if (!mk[status[i][j]]) &#123; mk[status[i][j]] = 1; M.push_back(status[i][j]); ans1[status[i][j]] ++; ans2[id]++; &#125; &#125; &#125; else break; &#125; void sett(void) &#123; for (RG int i = 0; i &lt; V.size(); i++) vis[V[i]] = 0; for (RG int i = 0; i &lt; M.size(); i++) mk[M[i]] = 0; V.clear(); M.clear(); &#125; void solve(int x) &#123; int nn = 1; for (RG int i = 0; i &lt; a[x].size(); i++) &#123; int t = a[x][i]; while(!to[nn][t]) nn = fail[nn]; nn = to[nn][t]; get(x,nn); &#125; sett(); &#125;&#125;AC;int main(int argc, char *argv[])&#123; n = read(); m = read(); int L,x; for(RG int i=1;i&lt;=n;i++) &#123; L=read(); while(L--)x=read(),a[i].push_back(x); a[i].push_back(-1); L=read(); while(L--)x=read(),a[i].push_back(x); &#125; for(RG int i=1;i&lt;=m;i++) AC.Insert(i); AC.build_fail (); for(RG int i=1;i&lt;=n;i++) AC.solve(i); for(RG int i=1;i&lt;=m;i++)printf("%d\n",ans1[i]); for(RG int i=1;i&lt;=n;i++) &#123; printf("%d",ans2[i]); if (i != n) putchar(' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Â≠óÁ¨¶‰∏≤</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU-3746] Cyclic Necklace KMPÊâæÂæ™ÁéØ]]></title>
    <url>%2F2018%2F03%2F08%2FHDU-3746-Cyclic-Necklace-KMP%E6%89%BE%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢HDU-3746 Â§ßÊÑè:Ê±ÇÂá∫Ê∑ªÂä†Â∞ΩÂèØËÉΩÂ∞ëÁöÑÂ≠óÁ¨¶Êï∞Èáè‰ΩøÂæóÂéü‰∏≤Êàê‰∏∫Âæ™ÁéØ‰∏≤. ÊØîÂ¶Çabca-&gt;abcabcË¶Å2‰∏™Â≠óÁ¨¶. ÂàÜÊûêKMPÊâæÂæ™ÁéØËäÇ!failÊï∞ÁªÑÁöÑÂ∑ßÁî® ÊØîÂ¶ÇËØ¥È¢òÁõÆ‰∏≠ËøôÊ†∑ÁöÑ‰∏≤abcaÁöÑfailÊï∞ÁªÑ‰∏∫[0,0,0,1].‰πüÂ∞±ÊòØËØ¥ÊúÄÂêé‰∏Ä‰Ωç‰∏∫1ÂÖ∂‰ªñÂùá‰∏∫0. Êàë‰ª¨Ê†πÊçÆfailÊï∞ÁªÑÁöÑÂÆö‰πâÂ∞±ÂæàÂÆπÊòìÊé®Âá∫Á≠îÊ°à 1.Â¶ÇÊûúfail[len]‰∏∫0,‰πüÂ∞±ÊòØËØ¥Ê≤°Êúâ‰ªª‰ΩïÁöÑÂåπÈÖç.Â∞±ÊòØÂéüÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶. 2.Â¶ÇÊûúfail[len]‰∏ç‰∏∫0,Êàë‰ª¨Áî®len-fail[len]ÂæóÂà∞‰∏Ä‰∏™Âæ™ÁéØËäÇ.ÁÑ∂ÂêéÂ¶ÇÊûúËøô‰∏™Âæ™ÁéØËäÇÊòØlenÁöÑÂõ†Â≠ê.‰πüÂ∞±ÊòØÊÅ∞Â•ΩÂá∫Áé∞‰∫ÜÂæ™ÁéØ.ÈÇ£‰πà‰∏çË¶ÅÊ∑ªÂä†‰ªª‰ΩïÁöÑÂ≠óÁ¨¶,return 0.Âê¶ÂàôËøîÂõûËØ•Ê∑ªÂä†ÁöÑÈáè.‰πüÂ∞±ÊòØÂæ™ÁéØÈïøÂ∫¶ÂáèÂéªÂ≠òÂú®ÁöÑÊÆãÁº∫Âæ™ÁéØÈïøÂ∫¶ ÂÖ∑‰Ωì‰ª£Á†ÅËØ¥Êòé‰∏ÄÂàá. ‰ª£Á†Å12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;char s[100010];int fail[100010];int kmp(char *b,int nb)&#123; memset(fail,0,sizeof(fail)); for (int i = 2; i &lt;= nb; i++) &#123; int j = fail[i-1]; while(j != 0 &amp;&amp; b[j+1] != b[i]) j = fail[j]; if (b[j+1] == b[i]) fail[i] = j+1; else fail[i] = 0; &#125; if (fail[nb] == 0) return nb; int t = nb - fail[nb]; if (nb % t == 0) return 0; return (t-nb%t); &#125;int main(int argc, char *argv[])&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%s",s+1); printf("%d\n",kmp(s,strlen(s+1))); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Â≠óÁ¨¶‰∏≤</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI-2011|BZOJ-2434] Ahri's Printer ÈòøÁã∏ÁöÑÊâìÂ≠óÊú∫ FenwickÊ†ë+ACËá™Âä®Âß¨]]></title>
    <url>%2F2018%2F03%2F08%2FNOI-2011-BZOJ-2434-Ahri-s-Printer-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA-Fenwick%E6%A0%91-AC%E8%87%AA%E5%8A%A8%E5%A7%AC%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢BZOJ-2434 ÂàÜÊûêÊØíÁò§È¢ò. 1.ÂÖàËÄÉËôëÊö¥ÂäõÁöÑÂÅöÊ≥ï,ÂØπ‰∫éÊØè‰∏Ä‰∏™ËØªËøõÊù•ÁöÑÂåπÈÖç‰∏≤ÈÉΩÂª∫Á´ã‰∏ÄÊ¨°ACËá™Âä®dÂß¨. 100%ÁàÜÁÇ∏‰∏çÂä†Ëæ£.‰ºº‰πéÂè™ËÉΩÊãø40ÂàÜ. 2.Êàë‰ª¨ÂèØ‰ª•ËÄÉËôëÂá∫Áé∞ÈáçÂ§çËÆ°ÁÆóÁöÑÂú∞Êñπ.ÊúâÂæàÂ§ß‰∏ÄÈÉ®ÂàÜÁöÑÂ§±ÈÖçÊï∞ÁªÑÂÖ∂ÂÆûÊòØÊ≤°ÊúâÂèòÂåñÁöÑ.‰ΩÜÊòØÊàë‰ª¨Êó†ËÑëÂú∞ÊääÂÆÉÁ†¥ÂùèÊéâÂÜçÈáçÊñ∞Âª∫Á´ãËµ∑Êù•,ËøôÈÉ®ÂàÜÁöÑÊçüËÄóÂæàÂ§ß.ËÄÉËôë‰ºòÂåñ‰∏≠Èó¥ÁöÑfailÊï∞ÁªÑ,Êàë‰ª¨Âú®ÊâæÈÄÇÈÖçËäÇÁÇπÁöÑÊó∂ÂÄôÊòØ‰∏çÊòØÂè™Ë¶ÅÂæÄ‰∏äÈù¢Ë∑≥.ÊèíÂÖ•Ëøô‰∏™ËäÇÁÇπÁöÑÁà∂ËäÇÁÇπÂ∞±ÂèØ‰ª•Âï¶ÔºüÂÅöÁöÑÊó∂ÂÄôËÆ∞ÂæóÂ§ßÊ≥ïÂ∏à‰∏ÄÈÅç. ËøôÊ†∑Êãø70~80ÂàÜ. 3.Âú®2ÁöÑÂü∫Á°Ä‰∏äÂä†‰∏Ä‰∏™Ê†ëÁä∂Êï∞ÁªÑÂ∞±Ë°åËæ£. 100ÂàÜÊ†áÁÆó ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;using namespace std;const int SIZE = 1e5+5;inline int read()&#123; int x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x;&#125;int n,m,cnt,T,l[SIZE],r[SIZE],t[200005];int last[SIZE],lastq[SIZE],pos[SIZE],ans[SIZE];char ch[SIZE];struct fail_tree&#123; int to,next,v;&#125;e[SIZE],que[SIZE];inline void add(int x,int val)&#123;for(int i=x;i&lt;=T;i+=i&amp;-i)t[i]+=val;&#125;inline int query(int x)&#123;int sum=0;for(int i=x;i;i-=i&amp;-i)sum+=t[i];return sum;&#125;void insert(int u,int v)&#123;e[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;&#125;struct Aho_Corasick&#123; int cnt; int fa[SIZE],fail[SIZE],next[SIZE][26],q[SIZE]; Aho_Corasick()&#123; cnt=1; for(int i=0;i&lt;26;i++) next[0][i]=1; &#125; void build()&#123; int now=1,id=0; for(int i=0;i&lt;n;i++) if(ch[i]=='P')pos[++id]=now; else if(ch[i]=='B')now=fa[now]; else &#123; if(!next[now][ch[i]-'a']) &#123; next[now][ch[i]-'a']=++cnt; fa[cnt]=now; &#125; now=next[now][ch[i]-'a']; &#125; &#125; void buildfail()&#123; int head=0,tail=1; fail[1]=0;q[0]=1; while(head!=tail) &#123; int now=q[head];head++; for(int i=0;i&lt;26;i++) if(next[now][i]) &#123; int v=next[now][i]; int k=fail[now]; while(!next[k][i])k=fail[k]; fail[v]=next[k][i]; q[tail++]=v; &#125; &#125; &#125; void solve() &#123; int now=1,id=0; add(l[1],1); for(int i=0;ch[i];i++) if(ch[i]=='P') &#123; id++; for(int x=lastq[id];x;x=que[x].next) &#123; int t=pos[que[x].to]; ans[x]=query(r[t])-query(l[t]-1); &#125; &#125; else if(ch[i]=='B')add(l[now],-1),now=fa[now]; else now=next[now][ch[i]-'a'],add(l[now],1);; &#125; &#125;Aho_Corasick;void dfs(int x)&#123; l[x]=++T; for(int i=last[x];i;i=e[i].next) dfs(e[i].to); r[x]=++T; //wtf!&#125;void addedge(int x,int y,int z)&#123; que[z].next = lastq[y]; lastq[y] = z; que[z].to = x;&#125;int main(int argc, char *argv[])&#123; scanf("%s",ch); n=strlen(ch); Aho_Corasick.build(); Aho_Corasick.buildfail(); for(int i=1;i&lt;=Aho_Corasick.cnt;i++) insert(Aho_Corasick.fail[i],i); m=read(); for(int i=1;i&lt;=m;i++) &#123; int x=read(),y=read(); addedge(x,y,i); &#125; dfs(0); Aho_Corasick.solve(); for(int i=1;i&lt;=m;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>Â≠óÁ¨¶‰∏≤</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI-2014] Zoo KMPÊ®°Êãü]]></title>
    <url>%2F2018%2F03%2F08%2FNOI-2014-Zoo-KMP%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢BZOJ-3670 ÂàÜÊûê‰∏çËÄÉËôëÈ¢òÁõÆÁöÑÈôêÂà∂,Âè™ÊÉ≥‰∏ÄËà¨ÁöÑÊÉÖÂÜµ. ÂÖàÈÄöËøáÂØπnextÊï∞ÁªÑÁöÑËßÇÂØü,‰∏çÈöæÂæóÂà∞$num(i)=num(fail(i))+1$. ËÄÉËôëÂÜçÁª¥Êä§‰∏Ä‰∏™ÂâçÁºÄ‰∏ç‰∏éÂêéÁºÄÈáçÂè†ÁöÑ,Â∏¶ÊúâÈôêÂà∂ÁöÑ$num‚Äô(i)$, Êâæ‰∏ÄÊ≥¢ËßÑÂæãÂæóÂà∞ num'(i) = num(fail'(i))+1Áõ∏ÂΩì‰∫éÂêåÊó∂Áª¥Êä§‰∫Ü‰∏§‰∏™Â§±ÈÖçÊï∞ÁªÑ‰∫ÜÂòõ. ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+5;typedef long long ll;int n;char s[maxn];int fail[maxn],num1[maxn],num2[maxn];const int Mod = 1e9+7;ll kmp(char *b)&#123; ll ans = 1; int nb = strlen(b+1),k = 0,t = 0; for (int i = 2; i &lt;= nb; i++) &#123; while(k &amp;&amp; s[k+1] != s[i]) k = fail[k]; while((t &amp;&amp; s[t+1] != s[i]) || t &gt;= (i&gt;&gt;1)) t = fail[t]; if(s[t+1] == s[i]) num2[i] = num1[++t] + 1; else num2[i] = 0; if(s[k+1] == s[i]) fail[i] = ++k,num1[i] = num1[k] + 1; else num1[i] = fail[i] = 0; ans = (ans * (num2[i]+1)) % Mod; &#125; return ans;&#125; int main(int argc, char *argv[])&#123; scanf("%d",&amp;n); while(n--) &#123; scanf("%s",s+1); printf("%lld\n",kmp(s)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Â≠óÁ¨¶‰∏≤</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF-578D(Div 1)] LCS AGAIN]]></title>
    <url>%2F2018%2F03%2F08%2FCF-578D-Div-1-LCS-AGAIN%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢Codeforces-578D You are given a string S of length n with each character being one of the first m lowercase English letters. Calculate how many different strings T of length n composed from the first m lowercase English letters exist such that the length of LCS (longest common subsequence) between S and T is n - 1. Recall that LCS of two strings S and T is the longest string C such that C both in S and T as a subsequence. Input The first line contains two numbers n and m denoting the length of string S and number of first English lowercase characters forming the character set for strings (1 ‚â§ n ‚â§ 100 000, 2 ‚â§ m ‚â§ 26). The second line contains string S. Output Print the only line containing the answer. ‰ª£Á†Å12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;char last,la_last;long long ans = 0,tmp = 0;inline char next()&#123; char c = getchar(); while(!isalpha(c)) c=getchar(); return c;&#125;int main(int argc, char *argv[])&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); ans = 1LL * n * (m-1); char ret = getchar(),last = next(),la_last = -1; for (int i = 2; i &lt;= n; i++) &#123; char ch = next(); if (ch == la_last) tmp++; else tmp = 0; if (ch != last) ans += n*(m-1)-tmp-1; la_last = last; last = ch; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Â≠óÁ¨¶‰∏≤</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP/TrieÊ†ë/Aho-Corasick Automaton Â≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2018%2F03%2F08%2FKMP-Trie%E6%A0%91-Aho-Corasick-Automaton-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ÁªßÁª≠Â°´Âùë.Êú¨Êù•ÊÉ≥ÊääËøô‰∏â‰∏™Áé©ÊÑèÂàÜÂºÄÊù•ÂÜôÁöÑ,ÂêéÊù•ÂèëÁé∞ÂÖ∂ÂÆûÈòøÊ¨°Ëá™Âä®Âß¨Â∞±ÂèØ‰ª•ÊèèËø∞ËøôÂá†‰∏™ÁöÑÂéüÁêÜ‰∫Ü.ÈÇ£Â∞±ÂÜô‰∏ÄËµ∑‰∫Ü. KMPÂÖ®Áß∞Âè´ÂÅö (Knuth-Morris-Pratt).ÊòØËÉΩÂ§üÂú®Á∫øÊÄßÊó∂Èó¥ÂÜÖÂÆåÊàêÂ≠óÁ¨¶‰∏≤ÂåπÈÖçÁöÑÁÆóÊ≥ï. ÂéüÁêÜKMPÁÆóÊ≥ï‰∏çÂêå‰∫é‰∏ÄËà¨ÁöÑÊö¥ÂäõÂåπÈÖçÁÆóÊ≥ïÁöÑÂú∞ÊñπÂú®‰∫é,KMPÁÆóÊ≥ïÂÖÖÂàÜÂà©Áî®‰∫ÜÊØèÊ¨°ÂåπÈÖçÂêéÁöÑÂ§±ÈÖç‰ø°ÊÅØ,‰∏ç‰ºöÊØè‰∏ÄÊ¨°ÈÉΩ‰ªéÁ¨¨‰∏Ä‰∏™‰ΩçÁΩÆÂåπÈÖç,Âõ†Ê≠§Êàë‰ª¨ÂÖà‰ªãÁªç‰∏Ä‰∏™Áé©ÊÑèÂè´ÂÅöÈÄÇÈÖçÊï∞ÁªÑfail[i]. ÂØπ‰∫éfail[i]Êï∞ÁªÑÁöÑÂÆö‰πâ: Ê®°Âºè‰∏≤‰∏≠Ââçi‰∏™Â≠óÁ¨¶‰Ωú‰∏∫ÁõÆÊ†á‰∏≤ÁöÑÊúÄÂ§ßÂâçÂêéÁºÄÂØπÁß∞ÈïøÂ∫¶. Ëøô‰ªÄ‰πàÂÆö‰πâÂïäÁúãÂæóÊàëÂ§¥Â§ß. Êàë‰ª¨‰ª•ÂÆûÈôÖÊ†óÂ≠êÊù•ËØ¥Êòé. ÂÅáËÆæÁé∞Âú®ÂèàËøôÊ†∑ÁöÑ‰∏Ä‰∏™Ê®°Âºè‰∏≤shryshrkrin Ê†πÊçÆÂÆö‰πâÊàë‰ª¨Êé®Âá∫ÁöÑfailÊï∞ÁªÑ‰∏∫00001230000 ‰∏∫‰ªÄ‰πàËøô‰πàÂÆö‰πâfailÊï∞ÁªÑÂë¢?Âú®Êàë‰ª¨ÂåπÈÖçÂ≠óÁ¨¶‰∏≤ÁöÑÊó∂ÂÄôÔºåÂ¶ÇÊûú‰πãÂâçÁöÑÂåπÈÖçÂ§±Ë¥•‰∫ÜÔºåÊàë‰ª¨Áõ¥Êé•Áî®failÊï∞ÁªÑÂæóÂà∞‰∏ã‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÂâçÁºÄÂç≥ÂèØ.ËÄå‰∏îÂèàÂèØ‰ª•ËØÅÊòé,failÊï∞ÁªÑÂíåÂåπÈÖçÁöÑ‰∏≤Ê≤°Êúâ‰ªª‰ΩïÁöÑÂÖ≥Á≥ª,Êç¢Ë®Ä‰πã,ÂæóÂà∞‰∫ÜfailÊï∞ÁªÑ,Â∞±ÊòØÂæóÂà∞‰∫ÜÂ§±ÈÖç‰ø°ÊÅØ.‰∏é‰∏ã‰∏Ä‰∏™ÂèØËÉΩÂêàÊ≥ïÁöÑÂ≠óÁ¨¶‰∏≤ÁöÑ‰ΩçÁΩÆ. Â•ΩÊàë‰ª¨ÊòØ‰∏çÊòØÂè™Ë¶ÅËÉΩÊ±ÇÂá∫failÊï∞ÁªÑÂ∞±ÂèØ‰ª•Êî∂Â∑•‰∫ÜÔºü failÁöÑÈÄíÊé®ÊñπÂºèÂ¶Ç‰∏ã. Â¶ÇÊûú fail[i - 1] ‰∏ç‰∏∫ 0Ôºå‰∏îÁ¨¨ i ‰∏™Â≠óÁ¨¶‰∏éÁ¨¨ fail[i - 1] + Ôºë ‰∏™Â≠óÁ¨¶Áõ∏ÂêåÔºåÂàô fail[i] Âç≥‰∏∫ fail[i - 1] + 1Ôºõ Â¶ÇÊûú fail[i - 1] ‰∏∫ 0Ôºå‰∏îÁ¨¨ i ‰∏™Â≠óÁ¨¶‰∏éÈ¶ñ‰∏™Â≠óÁ¨¶Áõ∏ÂêåÔºåÂàô fail[i] = 1ÔºåÂê¶Âàô fail[i] = 0Ôºõ Â¶ÇÊûú fail[i - 1] ‰∏ç‰∏∫ 0Ôºå‰∏îÁ¨¨ i ‰∏™Â≠óÁ¨¶‰∏éÁ¨¨ fail[i - 1] + Ôºë ‰∏™Â≠óÁ¨¶‰∏çÂêåÔºåÂàôÁªßÁª≠ÂØπÊØîÁ¨¨ i ‰∏™Â≠óÁ¨¶‰∏é fail[fail[i - 1]] + 1 ‰∏™Â≠óÁ¨¶Ôºå‰∏ÄÁõ¥ÂêëÂâçÊâæÁõ¥Âà∞ÂåπÈÖçÊàñËÄÖÊâæÂà∞‰∫Ü 0„ÄÇ ÊùøÂ≠ê12345678910111213141516171819202122232425262728int kmp(char *a, char *b) //find b in a&#123; static int fail[MAXN]; int na = strlen(a+1),nb = strlen(b+1); fail[1] = 0; for (int i = 2; i &lt;= nb; i++) &#123; int j = fail[i-1]; while(j != 0 &amp;&amp; b[j+1] != b[i]) j = fail[j]; if (b[j+1] == b[i]) fail[i] = j+1; else fail[i] = 0; &#125; int res = 0; for (int i = 1,j = 0; i &lt;= na; i++) &#123; while(j != 0 &amp;&amp; b[j+1] != a[i]) j = fail[j]; if (a[i] == b[j+1]) j++; if (j == nb) &#123; res ++; j = fail[j]; // j = 0; //Â¶ÇÊûúÊØè‰∏™Â≠óÁ¨¶Âè™ËÉΩ‰ΩøÁî®‰∏ÄÊ¨°,ËøôÈáåÁöÑjÂ∫îËØ•‰∏∫0 &#125; &#125; return res;&#125; ÁÑ∂ÂêéÊòØÊùøÂ≠êÈ¢ò. POJ-3461 ÊùøÂ≠êÈ¢ò,Ê±ÇÁ¨¨‰∏Ä‰∏™‰∏≤Âú®Á¨¨‰∫å‰∏™‰∏≠ÁöÑÂá∫Áé∞Ê¨°Êï∞. 1234567891011121314151617181920212223242526272829303132333435363738394041424344//#include&lt;bits/stdc++.h&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN = 1e6+10;char s1[MAXN],s2[MAXN];int kmp(char *a,char *b)&#123; static int fail[MAXN]; int na = strlen(a+1), nb = strlen(b+1); fail[1] = 0; for (int i = 2; i &lt;= nb; i++) &#123; int j = fail[i-1]; while(j != 0 &amp;&amp; b[j+1] != b[i]) j = fail[j]; if (b[i] == b[j+1]) fail[i] = j+1; else fail[i] = 0; &#125; int res = 0; for (int i = 1,j = 0; i &lt;= na; i++) &#123; while(j != 0 &amp;&amp; b[j+1] != a[i]) j = fail[j]; if (a[i] == b[j+1]) j ++; if (j == nb) &#123; res ++ ; j = fail[j]; &#125; &#125; return res;&#125;int main(int argc, char *argv[])&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",s1+1,s2+1); printf("%d\n",kmp(s2,s1)); &#125; return 0;&#125; LUOGU-3375 ËøòÊòØÊùøÂ≠êÈ¢ò,Ê±ÇËØ¢ÈóÆ‰∏≤ÁöÑÊâÄÊúâÂá∫Áé∞‰ΩçÁΩÆ‰∏énextÊï∞ÁªÑ. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN = 1e6+10;char s1[MAXN],s2[MAXN];vector &lt;int&gt; v;vector &lt;int&gt;::iterator it;void kmp(char *a,char *b)&#123; static int fail[MAXN]; int na = strlen(a+1), nb = strlen(b+1); fail[1] = 0; for (int i = 2; i &lt;= nb; i++) &#123; int j = fail[i-1]; while(j != 0 &amp;&amp; b[j+1] != b[i]) j = fail[j]; if (b[i] == b[j+1]) fail[i] = j+1; else fail[i] = 0; &#125; int res = 0; for (int i = 1,j = 0; i &lt;= na; i++) &#123; while(j != 0 &amp;&amp; b[j+1] != a[i]) j = fail[j]; if (a[i] == b[j+1]) j ++; if (j == nb) &#123; v.push_back(i-j+1);//Ëøô‰∏™Ëé´ÂêçÂÖ∂Â¶ôÂú∞Ëá™Â∑±ËíôÂá∫Êù•‰∫Ü. j = fail[j]; &#125; &#125; for (it = v.begin(); it != v.end(); it++) cout &lt;&lt; *it &lt;&lt; endl; for (int i = 1; i &lt;= nb; i++) cout &lt;&lt; fail[i] &lt;&lt; " ";&#125;int main(int argc, char *argv[])&#123; v.clear(); scanf("%s%s",s1+1,s2+1); kmp(s1,s2); return 0;&#125; ÈÇ£‰πàÂÜçÊù•‰∏ÄÈÅì. ÁÆó‰∫ÜÁúã‰π†È¢òÊï¥ÁêÜÂêß„ÄÇ TrieÊ†ë(Â≠óÂÖ∏Ê†ë)ÂÖ∂ÂÆûÊòØ‰∏™ÂæàÊñØÊ≥¢ÁöÑ‰∏úË•ø. ÂæàÂ•ΩÂÜô‰πüÂæàÂ•ΩÊáÇ. HDU-1251 Ê±ÇËØ¢ÈóÆ‰∏≤‰∏∫Ê®°Âºè‰∏≤ÂâçÁºÄÁöÑ‰∏™Êï∞. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma GCC optmize("0fuck")#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6+10;char s[11];struct Trie&#123; int tot,trie[maxn][26],sum[maxn]; void settledown(void)&#123;tot=0;memset(sum,0,sizeof(sum));&#125; void insert(char *s,int rt) &#123; int l = strlen(s); for (int i = 0; i &lt; l; i++) &#123; int x = s[i]-'a'; if (trie[rt][x] == 0) trie[rt][x] = ++tot; rt = trie[rt][x]; sum[rt]++; &#125; &#125; int find(char *s,int rt) &#123; int l = strlen(s); for (int i = 0; i &lt; l; i++) &#123; int x = s[i]-'a'; if (!trie[rt][x]) return 0; rt = trie[rt][x]; &#125; return sum[rt]; &#125;&#125;Tr;int main(int argc,char *argv[])&#123; char ch; while(gets(s)) &#123; if (s[0]==NULL) break; Tr.insert(s,0); &#125; while(gets(s)) printf("%d\n",Tr.find(s,0)); return 0;&#125; LUOGU-2580 ÂØπÂ≠óÁ¨¶‰∏≤Êü•ËØ¢Êìç‰Ωú.Ê±ÇËØ¢ÈóÆ‰∏≤‰Ωú‰∏∫ÂâçÁºÄÊòØÂê¶Âá∫Áé∞,ÊòØÂê¶Á¨¨‰∏ÄÊ¨°Âá∫Áé∞,ÊòØÂê¶Ê≤°Âá∫Áé∞. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#pragma GCC optmize("0fuck")#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6+10;char s[10];char ss[4][10] = &#123;"WRONG","REPEAT","OK"&#125;;struct Trie&#123; int tot,trie[maxn][26]; bool vis[maxn]; void settledown(void) &#123; tot = 1; memset(vis,1,sizeof(vis)); &#125; void insert(char *s,int rt) &#123; int l = strlen(s+1); for (int i = 1; i &lt;= l; i++) &#123; int x = s[i]-'a'; if (trie[rt][x] == 0) trie[rt][x] = ++tot; rt = trie[rt][x]; &#125; &#125; int find(char *s,int rt) &#123; int l = strlen(s+1); for (int i = 1; i &lt;= l; i++) &#123; int x = s[i]-'a'; if (!trie[rt][x]) return 0; rt = trie[rt][x]; &#125; if (vis[rt]) &#123; vis[rt] = 0; return 2; &#125; else return 1; &#125;&#125;Tr;int main(int argc,char *argv[])&#123; Tr.settledown(); int n,m; scanf("%d",&amp;n); while(n--) &#123; scanf("%s",s+1); Tr.insert(s,1); &#125; scanf("%d",&amp;m); while(m--) &#123; scanf("%s",s+1); printf("%s\n",ss[Tr.find(s,1)]); &#125; return 0;&#125; Aho-Corasick AutomatonËøôÁé©ÊÑèÊâçÊòØÈáçÁÇπ È¶ñÂÖàÊàëÂØπ‰∫éACËá™Âä®Âß¨ÁöÑÁêÜËß£Â∞±ÊòØ \large AC Automaton=KMP+Trie‰∏ÄÊ†∑ÁöÑÂØπ‰∫éÊ®°Âºè‰∏≤Âª∫Á´ãÂ≠óÂÖ∏Ê†ëÔºåÂú®Ê†ë‰∏äÁÆófailÊï∞ÁªÑÔºåÊàë‰ª¨ÊääËøô‰∏§‰∏™Áé©ÊÑèÊîæÂà∞‰∏ÄËµ∑. TrieÂè™ËÉΩÂÅöÂâçÁºÄ‰∏çËÉΩÂåπÈÖçÂêß,Âä†‰∫ÜKMP‰∏çÂ∞±Ë°å‰∫Ü‰πà! ÊàëËßâÂæóÊúâÂº†ÂõæÊå∫Â•ΩÁöÑ„ÄÇ ËøôÊòØÊôÆÈÄöÁöÑÂª∫Á´ãTrieÊ†ëÁöÑËøáÁ®ã ÁÑ∂ÂêéÊàë‰ª¨Âú®‰∏äÈù¢Âä†‰∏äfailÊï∞ÁªÑ / ÊåáÈíàÂ∞±ÂèØ‰ª•‰∫Ü ÂØπ‰∫éACËá™Âä®Âß¨,Êúâ‰∏§ÁßçÂÜôÊ≥ï Â∏¶ÊåáÈíà(ÊàëËøòÊòØÂÅèÂêë‰∫éÂñúÊ¨¢Ëøô‰πàÂÜô,ÊÑüËßâÊå∫Â•ΩÁêÜËß£ÁöÑ) ÂèØÈ£üÁî®ÂØπË±° LUOGU-3808 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#include&lt;queue&gt;using namespace std;const int maxn = 1e6 + 5;int cnt,N;struct node&#123; node *next[26]; node *fail; int sum;&#125;;char key[maxn];node *newnode,*root;char pattern[maxn];void Insert(char *s)&#123; node *p = root; for(int i = 0; s[i]; i++) &#123; int x = s[i] - 'a'; if(p-&gt;next[x] == NULL) &#123; //newnode=(struct node *)malloc(sizeof(struct node)); newnode = new(node); for(int j=0;j&lt;26;j++) newnode-&gt;next[j] = 0; newnode-&gt;sum = 0;newnode-&gt;fail = 0; p-&gt;next[x]=newnode; &#125; p = p-&gt;next[x]; &#125; p-&gt;sum++;&#125;void build_fail_pointer()&#123; queue&lt;node*&gt;q; q.push(root); node *p; node *temp; while(!q.empty()) &#123; temp = q.front(); q.pop(); for(int i = 0; i &lt;= 25; i++) &#123; if(temp-&gt;next[i]) &#123; if(temp == root) temp-&gt;next[i]-&gt;fail = root; else &#123; p = temp-&gt;fail; while(p) &#123; if(p-&gt;next[i]) &#123; temp-&gt;next[i]-&gt;fail = p-&gt;next[i]; break; &#125; p = p-&gt;fail; &#125; if(p == NULL) temp-&gt;next[i]-&gt;fail = root; &#125; q.push(temp-&gt;next[i]); &#125; &#125; &#125;&#125;void ac_automation(char *ch)&#123; node *p = root; int len = strlen(ch); for(int i = 0; i &lt; len; i++) &#123; int x = ch[i] - 'a'; while(!p-&gt;next[x] &amp;&amp; p != root) p = p-&gt;fail; p = p-&gt;next[x]; if(!p) p = root; node *temp = p; while(temp != root) &#123; if(temp-&gt;sum &gt;= 0) &#123; cnt += temp-&gt;sum; temp-&gt;sum = -1; &#125; else break; temp = temp-&gt;fail; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; //root=(struct node *)malloc(sizeof(struct node)); root = new(node); //Â•ΩÂÉè new(node)Êõ¥Âø´!? for(int j=0;j&lt;26;j++) root-&gt;next[j] = 0; root-&gt;fail=0; root-&gt;sum=0; scanf("%d",&amp;N); getchar();//get char of newline for(int i = 1; i &lt;= N; i++) &#123; scanf("%s",key); Insert(key); &#125; scanf("%s",pattern); cnt = 0; build_fail_pointer(); ac_automation(pattern); printf("%d\n",cnt); return 0;&#125; ÁΩë‰∏äÊãâÊù•‰∏Ä‰∏™‰∏çÁî®ÊåáÈíàÁöÑ. ËìùÁîòÂÜ∞Èú≤ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define il inline#define RG register#define N 10010using namespace std; char s[N][55],ss[N*100];int n,times[N];//timesËÆ∞ÂΩïÂçïËØçÂú®ÊñáÊú¨‰∏≤‰∏≠Âá∫Áé∞ÁöÑÊ¨°Êï∞ struct Trie&#123; int son[N][26],fail[N],root,L,num[N]; int last[N];//Âè™ÊòØ‰∏Ä‰∏™‰ºòÂåñÔºåÊúâÊ≤°ÊúâÈÉΩÊ≤°ÂÖ≥Á≥ª void init()&#123; L=1; root=0; memset(son,0,sizeof(son)); memset(num,0,sizeof(num)); memset(last,0,sizeof(last)); memset(fail,0,sizeof(fail)); &#125; il int idx(char c)&#123; return c-'a'; &#125; void insert( char s[],int v )&#123; int len=strlen(s), cur=root; for(int i=0;i&lt;len;i++)&#123; int id=idx(s[i]); if(!son[cur][id]) son[cur][id]=L++; cur=son[cur][id]; &#125; num[cur]=v; //ËÆ∞ÂΩïÂçïËØçÁºñÂè∑ &#125; void build()&#123; int que[N],hd=0,tl=0; for(int i=0;i&lt;26;i++) if(son[root][i])&#123; que[tl++]=son[root][i]; fail[son[root][i]]=root; &#125; else son[root][i]=root; while(hd&lt;tl)&#123; int cur=que[hd++]; for(int i=0;i&lt;26;i++)&#123; int Son=son[cur][i]; if(Son)&#123; int f=fail[cur]; while(f &amp;&amp; !son[f][i]) f=fail[f]; fail[Son]=son[f][i]; num[Son]=num[fail[Son]];//‰∏çÁî®last‰ºòÂåñÊó∂Ë¶ÅÂä†‰∏äËøô‰∏ÄÂè• que[tl++]=Son; &#125; else son[cur][i]=son[fail[cur]][i]; &#125; //if( num[fail[cur]] )last[cur]=fail[cur]; //else last[cur]=last[fail[cur]]; &#125; &#125; void query( char s[] )&#123; int len=strlen(s),cur=root; for(int i=0;i&lt;len;i++)&#123; int id=idx(s[i]); while(cur &amp;&amp; !son[cur][id]) cur=fail[cur]; if(son[cur][id])&#123; cur=son[cur][id]; int k=cur; while(k) times[ num[k] ]++,k=fail[k]; /*while(k)&#123; if(num[k]) times[num[k]]++; k=last[k]; &#125;*/ &#125; &#125; &#125; &#125;AC; int main()&#123; scanf("%d",&amp;n); AC.init(); for(RG int i = 1;i&lt;=n;i++)&#123; scanf("%s",s[i]); AC.insert(s[i],i); &#125; AC.build(); scanf("%s",ss); AC.query(ss); for( RG int i=1;i&lt;=n;i++ ) printf("%s %d\n",s[i],times[i]); return 0;&#125;]]></content>
      <categories>
        <category>ACËá™Âä®Âß¨</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Â•áÊäÄÊ∑´Â∑ß]ÁÆóÊ≥ïÁ´ûËµõÂ∏∏Êï∞‰ºòÂåñÊäÄÂ∑ß/‰ª£Á†ÅÈ£éÊ†ºÊÄªÁªì]]></title>
    <url>%2F2018%2F03%2F01%2F%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Â∫èË®ÄËøôÂá†Â§©Ë¢´Âç°Â∏∏ÊÅ∂ÂøÉÂà∞ÁöÑÊå∫Â§öÁöÑ..ÊâÄ‰ª•‰∏çÂæó‰∏çÊÅ∂Ë°•‰∫Ü‰∏ÄÊ≥¢ÈªëÁßëÊäÄÁöÑÂç°Â∏∏ÊäÄÂ∑ßÔºåÁÑ∂Âêé‰ª£Á†ÅÈ£éÊ†ºÁöÑÈóÆÈ¢òÂæà‰πÖÂ∞±ÊÉ≥ÂÜô‰∫Ü.. ÊâÄ‰ª•Â∞±ÂΩìÂÅö‰∏™ÊÄªÁªìÂêß„ÄÇ Âç°Â∏∏ÊäÄÂ∑ß‰øÆÈ•∞Á¨¶ÁöÑËøêÁî®1.Â§öÂú®ÈùûÈÄíÂΩíÂáΩÊï∞/ËøáÁ®ãÂä†inline,Â•ΩÂÉèÊòØËØ¥ËøôÊ†∑ÁºñËØëÂêéË∞ÉÁî®ÈÄüÂ∫¶Âä†Âø´.. 2.i++ÊØî++iÊÖ¢ 3.ÁÆóÊòØ‰∏™ÁéÑÂ≠¶ÁöÑ‰∏úË•øÂè´ÂÅöregister,ÂéüÁêÜÂú®‰∫éÊääÂèòÈáèÂ≠òÂú®CPUÁöÑÂØÑÂ≠òÂô®‰∏≠ËÆ°ÁÆóÂø´. ‰∏ÄËà¨ÊúâÈúÄË¶ÅÁöÑËØùÂèØ‰ª•Ëøô‰πàÂÜô 12#define RG register#define rep(i,a,b) for(RG int i=(a);i&lt;=(b);i++) ‰ΩÜÊòØÂ•áÊÄ™ÁöÑÊòØhjq‰∏äÊ¨°Â∏ÆÊàëË∞ÉÁöÑÊó∂ÂÄôÂä†‰∫ÜRGÂèçËÄåÂèòÊÖ¢‰∫Ü1s..È¨ºÁïúÂïä.. 4.Â∏∏Êï∞Â∞ëÁî®#define Â§öÁî®const/typedef 5.Â∞ëÁî®if else Â§öÁî®‰∏âÁõÆËøêÁÆóÁ¨¶ ËÆ°ÁÆó‰ºòÂåñ6.Âæ™ÁéØÂ±ïÂºÄ,ÂèØ‰ª•Âú®Â±ïÂºÄÁöÑÊó∂ÂÄôÊØè‰∏™ÂÜôÊàêÂáΩÊï∞‰ºöÁæéËßÇ‰∏ÄÁÇπ. 7.ËØªÂÖ•‰ºòÂåñÔºàÊàëÁöÑÊ†áÂáÜÂÜôÊ≥ïÂ∑Æ‰∏çÂ§öËøôÊ†∑‚ÜìÔºâ 1234567inline void read()&#123; int x = 0,f = 1;char ch = getchar(); while(!isdigit(ch))&#123;f = ch == '-' ? -1 : 1; ch = getchar();&#125; while(isdigit(ch))&#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return x * f;&#125; ‰∏äÈù¢ÁöÑx = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - ‚Äò0‚Äô;ËøòÊòØcgcÊÉ≥Âà∞ÁöÑÈ©¨ÂèâËô´ÂÜôÊ≥ï. 8.absËá™Â∑±ÂÜô. ÂáΩÊï∞Ë∞ÉÁî®‰ºòÂåñ9.Êüê‰∫õ‰∏çÂºÄO2Êó∂ÂÄôÁöÑÂáΩÊï∞/STLÊÖ¢ÁöÑË¶ÅÊ≠ª‰∏çÂ¶ÇËá™Â∑±ÂÆûÁé∞. e.g. isdigit(),isalpha(), max(),min(), queue&lt;&gt;,map&lt;&gt;,priority_queue&lt;&gt;, binary_search(),upper/lower_bound(). etc. Â•áÊÄ™ÁöÑÁ≠â‰ª∑x10 &lt;=&gt; (x&lt;]]></content>
      <categories>
        <category>Â•áÊäÄÊ∑´Â∑ß</category>
      </categories>
      <tags>
        <tag>Â•áÊäÄÊ∑´Â∑ß</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê¥≤ÈòÅÁ≠õÂ≠¶‰π†ÊÄªÁªì]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%B4%B2%E9%98%81%E7%AD%9B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[(‰∏çÁü•‰∏çËßâÂèàÁªôËá™Â∑±Êåñ‰∫Ü‰∏™Âùë.) ckr : ‚ÄúÊàëÂè™ÊòØÂú®Êó†ÊïåÁöÑË∑Ø‰∏äË∂äËµ∞Ë∂äËøú‚Äù Ê¥≤ÈòÅÁ≠õÈ£üÁî®ÊñπÊ≥ïÈ£üÁî®ËåÉÂõ¥Â§ßÈÉ®ÂàÜÁöÑÊÉÖÂÜµÂ∑Æ‰∏çÂ§öËøôÊ†∑: ÁªôÂá∫‰∏Ä‰∏™ÁßØÊÄßÂáΩÊï∞$f(x)$Êª°Ë∂≥ÁßØÊÄßÂáΩÊï∞ÁöÑÂü∫Êú¨ÊÄßË¥®,$f(1)=1$,Â¶ÇÊûú$gcd(a,b)=1$Êúâ$f(ab)=f(a)f(b)$. ÈÇ£‰πàÊ†πÊçÆÂîØ‰∏ÄÂàÜËß£ÂÆöÁêÜ,Â∞±ÊòØ$x=\prod _{i=1}^np_i^{k_i}$Â∞±ÂèØ‰ª•: \large f(x)=\prod f(p_i^{k_i})$In \space particular,p \space\space is\space a\space prime\space number$ÔºåËÄå‰∏î$f(p^c)$ÂèØ‰ª•Âø´ÈÄüÊ±ÇÂá∫. ‰∏ÄËà¨ÁöÑÈ¢òÁõÆÂ∑Æ‰∏çÂ§öÈÉΩËøôÊ†∑: $f(x)$ÊòØ‰∏Ä‰∏™Êï∞ËÆ∫ÂáΩÊï∞,Ë¶ÅÊ±Ç$\sum_{i=1}^nf(i)$,ËÄå‰∏î‰Ω†ÂèëÁé∞,ÊùúÊïôÁ≠õÂÆåÂÖ®‰∏çËÉΩÁî®Âç∑ÁßØÁÆÄÂåñÔºå‰Ω†Ë¢´È¢òÁõÆÁöÑÂΩ¢ÂºèÊ∑±Ê∑±Âç°Ê≠ªÔºÅ Âïä‚ôÇ Ê¥≤ÈòÅÁ≠õÂ∞±Âá∫Áé∞‰∫Ü„ÄÇ È£üÁî®ÊÄùÊÉ≥‰∏ªË¶ÅÁöÑÊ†∏ÂøÉÊÄùÊÉ≥Âú®‰∫é:ÂàÜÁ±ª ÂºïÁêÜÔºö$n$‰ª•ÂÜÖÁöÑÊï∞,ÊúÄÂ§öÂè™Êúâ‰∏Ä‰∏™Â§ß‰∫é$\sqrt{n}$ÁöÑË¥®Âõ†Êï∞: $Proof:$ ‚Äã ÂÅáËÆæÂéüÂëΩÈ¢ò‰∏çÊàêÁ´ã,Âç≥Â≠òÂú®Êúâ‰∏§‰∏™Â§ß‰∫é$\sqrt{n}$ÁöÑË¥®Âõ†Êï∞, ‚Äã ÈÇ£‰πà‰∏çÂ¶®ËÆæËøô‰∏§‰∏™Ë¥®Âõ†Êï∞ÊòØ$n_1,n_2$ ‰∫éÊòØÊúâ$n_1n_2&gt;n$,‰ΩÜËøôÊòØ‰∏çÂèØËÉΩÁöÑÔºÅ ‚Äã $\therefore$ÂÅáËÆæÂëΩÈ¢ò‰∏çÊàêÁ´ãÔºåÂéüÂëΩÈ¢òÊ≠£Á°Æ.]]></content>
      <categories>
        <category>Ê¥≤ÈòÅÁ≠õ</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MobiusÂèçÊºî‰π†È¢òÊï¥ÁêÜ]]></title>
    <url>%2F2018%2F02%2F27%2FMobius%E5%8F%8D%E6%BC%94%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[È¢òÂçïÔºàËøôËæπÁöÑÊòØÂÅöËøáÁöÑ..Ôºâ È¢òÂçïÂú®Ëøô: https://www.cnblogs.com/darklove/p/7554314.html BZOJ-2440 BZOJ-3994/LUOGU-3327ÂèåÂÄçÁªèÈ™å BZOJ-2154 SPOJ-DIVCNT2(Ë∞ÅÊù•Â∏ÆÊàëÂç°‰∏™Â∏∏ÂïäÊúÄÂêéÁöÑÁÇπTÈ£ûÂ∞±Â∑Æ‰∏ÄÁÇπÁÇπÂïäÂïäÂïäÂïäÂïä) BZOJ-2301/LUOGU-2522ÂèåÂÄçÁªèÈ™å 51Nod-1244 51Nod-1239 BZOJ-3944 51Nod-1237 ‚Äî-Ôºà‰∏çÂÆöÊúüÊ∑ªÂä†ÂÖ®Âá≠ÈÄ†ÂåñÔºâ Â•áÊäÄÊ∑´Â∑ßÂ∏∏Áî®ÂÖ¨ÂºèÊï¥ÁêÜÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÂÆö‰πâÂú®Êï∞ËÆ∫ÂáΩÊï∞‰∏ä ÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØ ÂÆö‰πâ ÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÔºö$\displaystyle (f \times g)(n) = \sum_{d|n}f(d)*g(\frac{n}{d})$ ‰∏Ä‰∏™‰æãÂ≠êÔºö$f(x)=2x,g(x)=3x$ Âàô$(f \times g)(6)=f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)$„ÄÇ ÂæÄÂæÄÁúÅÁï•Êéâ$n$„ÄÇ ÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÂÆö‰πâÂú®Êï∞ËÆ∫ÂáΩÊï∞‰∏ä„ÄÇ Êï∞ËÆ∫ÂáΩÊï∞Ôºö Â¶ÇÊûú‰∏Ä‰∏™ÂáΩÊï∞ÁöÑÂÆö‰πâÂüü‰∏∫Ê≠£Êï¥Êï∞ÔºåÂÄºÂüü‰∏∫Â§çÊï∞ÔºåÂàôÁß∞Ê≠§ÂáΩÊï∞‰∏∫Êï∞ËÆ∫ÂáΩÊï∞„ÄÇÂ∏∏ËßÅÁöÑÊï∞ËÆ∫ÂáΩÊï∞ÊúâÊ¨ßÊãâÂáΩÊï∞$\varphi$ÂíåËé´ÊØî‰πåÊñØÂáΩÊï∞$\mu$„ÄÇ ËøêÁÆóÂæãÔºö ÁªìÂêàÂæã $(f \times g ) \times h= f \times (g \times h)$„ÄÇ ‰∫§Êç¢Âæã $f \times g = g \times f$„ÄÇ Âä†Ê≥ï-ÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÂàÜÈÖçÂæã $f \times (g+h) = f\times g + f \times h$„ÄÇ Âçï‰ΩçÂÖÉ Âçï‰ΩçÂáΩÊï∞$\epsilon$Ôºå‰ΩøÂæó$f= \epsilon \times f =f \times \epsilon$„ÄÇÂçï‰ΩçÂáΩÊï∞ÁöÑÂèñÂÄºÔºö$n=1$Êó∂$\epsilon(n)=1$Ôºå$n$ÂèñÂÖ∂‰ªñÂÄºÊó∂$\epsilon(n)=0$„ÄÇ ÈÄÜÂÖÉ ÂØπ‰∫é‰ªªÊÑèÊï∞ËÆ∫ÂáΩÊï∞$f$ÔºåÂ¶ÇÊûú$f(1) \not = 0$ÔºåÂàôÂ≠òÂú®ÂîØ‰∏ÄÁöÑÈÄÜÂáΩÊï∞$f^{-1}$Ôºå‰ΩøÂæó $f \times f^{-1} = \epsilon$ÔºöÂØπ‰∫é$n=1$ÔºåÊúâÔºö${f^{-1}(1)={\frac {1}{f(1)}}}$ÂØπ‰∫é$n&gt;1$ÔºåÊúâÔºö$ {f^{-1}(n)={\frac {-1}{f(1)}}\displaystyle \sum _{d|n,n\neq d}f({\frac {n}{d}})f^{-1}(d)}$ ÁâπÊÆäÂáΩÊï∞ÁöÑÂ•ÜÁßØÁî±:$\sum_{d|n}\varphi(d)=n$ÂÜçÁªìÂêàÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÁöÑÂÆö‰πâ: $\varphi*1=n$ Ê†πÊçÆMobiusÂèçÊºîÁöÑÂºèÂ≠ê: $F(n)=\sum_{d|n}f(d)$ ÂÜôÊàêÂç∑ÁßØÁöÑÂΩ¢ÂºèÂ∞±ÊòØ: $F = f*1$ ‰∫ãÂÆû‰∏äÊàë‰ª¨ÁîöËá≥ÂèØ‰ª•Áî®ÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÁöÑËøêÁÆóÊ≥ïÂàôÊù•ËØÅÊòéËé´ÊØî‰πåÊñØÂèçÊºîÁöÑÊ≠£Á°ÆÊÄß \huge{ \because \mu * 1=\epsilon \\\\ \therefore f*1=F*\mu*1 \\\\\therefore f=F *\mu}Êõ¥ÊúâÊÑèÊÄùÁöÑÊòØÊàë‰ª¨Âá†‰πéÂèØ‰ª•‰∏çË¥πÂêπÁÅ∞‰πãÂäõÔºåÂà©Áî®ÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØËøêÁÆóÁöÑ‰∫§Êç¢Âæã,Áî±: \huge f=F*\mu=\mu*F \huge=>f(n)=\sum_{d|n}\mu(\frac{n}{d})F(d) = \sum_{d|n}\mu(d)F(\frac{n}{d})Ëøô‰πàÂø´Â∞±ËØÅÂÆå‰∫Ü,,,ÁèÇÊÄï. Êï∞ËÆ∫ÁßØÊÄßÂáΩÊï∞Á∫øÊÄßÁ≠õÊ≥ïÁî±ÁßØÊÄßÂáΩÊï∞ÁöÑÂÆö‰πâ,Â§ßÈÉ®ÂàÜÁöÑÊï∞ËÆ∫ÂáΩÊï∞Â¶Ç$\mu(x),\varphi(x)$ÈÉΩËÉΩÂú®$Euler$Á∫øÊÄßÁ≠õ‰∏≠‰ª•$O(n)$ÁöÑÊó∂Èó¥ÂæóÂà∞. ‰∫§Âá∫ÊùøÂ≠ê 1234567891011121314151617181920212223242526272829303132inline void init(void)&#123; //phi[i]‰∏∫Ê¨ßÊãâÂáΩÊï∞,u[i]‰∏∫Ëé´ÊØî‰πåÊñØÂáΩÊï∞,f[i]‰∏∫Á∫¶Êï∞‰∏™Êï∞ÂáΩÊï∞,g[i]‰∏∫ÊúÄÈ´òË¥®Âõ†Êï∞ÁöÑÊ¨°ÊñπÊï∞ phi[1] = u[1] = f[1] = 1; for (int i = 2; i &lt; maxn; i++) &#123; if(!vis[i]) &#123; prime[++cnt] = i; u[i] = -1; f[i] = 2; g[i] = 1; phi[i] = i-1; &#125; for(int j = 1;j &lt;= cnt&amp;&amp; i*prime[j] &lt;=maxn; j++) &#123; vis[i*prime[j]]=true; if(i%prime[j]== 0) &#123; u[i*prime[j]]=0; g[i*prime[j]]=g[i]+1; f[i*prime[j]]=f[i]/(g[i]+1)*(g[i]+2); phi[i*prime[j]] = phi[i] * prime[j]; break; &#125; u[i*prime[j]]=-u[i]; g[i*prime[j]]=1; f[i*prime[j]]=f[i]*2; phi[i*prime[j]] = phi[i] * (prime[j]-1); &#125; &#125;&#125; Ëøô‰∏™ÊùøÂ≠êÂ∫îËØ•Â§üÁî®‰∫Ü‰∏çÁÑ∂ÊàëÂ∞±ÂêÉckr MobiusÂèçÊºîÂÖ¨Âºè \huge{ \sum_{x|n}\mu(x)=[n=1]\\\\ \sum_{x|i}f(\frac{i}{x})=\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}f(i)\\\\ \varphi(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})=\sum_{d|n}\frac{\mu(d)n}{d}\\\\ \sum_{d|n}\varphi(d)=n\\\\ }Â§çÊùÇÁöÑÂçïÈ¢òÂÜôÈ¢òËß£Âêß.]]></content>
      <categories>
        <category>Ëé´ÊØî‰πåÊñØÂèçÊºî</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT/NTTÂ≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2018%2F02%2F25%2FFFT-NTT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ÂºïË®ÄÂè≤ËØóÁ∫ßÂ∑®ÂùëÂ°´ÂÆåÂÜçÂàí ‰∏ªË¶ÅÂèÇËÄÉËµÑÊñôÔºö lych_cysÊ¢ÅÂ§ßÁöÑËÆ≤Ëß£ MYYÁöÑÂõΩÂÆ∂ÈõÜËÆ≠ÈòüËÆ∫Êñá Menci‚Äôs blog ÈÇìÁ•éÊòéÁöÑÁü•‰πé‰∏ìÊ†è Â≠¶ÈïøÊñπÂ∞§‰πêÁöÑblog Miskcoo‚Äôs blog ÔºàÂíå‰∏Ä‰∫õÂ•áÂ•áÊÄ™ÊÄ™ÁöÑ‰∏úË•ø È¢ÑÂ§áÁü•ËØÜÂ§öÈ°πÂºèÂÆö‰πâÔºàÂèÇËßÅÂàù‰∏≠‰∫∫ÊïôÁâà‰∏ÉÂπ¥Á∫ß‰∏äËØæÊú¨Ôºâ Á≥ªÊï∞Ë°®Á§∫Ê≥ïÂ∞ÜP(X)=a_0+a_1X+a_2X^2+\cdots+a_nX^nÁöÑÊØè‰∏Ä‰∏™X ÂâçÁöÑÁ≥ªÊï∞a_iÊèêÂèñÂá∫Êù•Áúã‰Ωú‰∏Ä‰∏™n+1Áª¥ÂêëÈáè Ê≠§ÂêëÈáè$\vec{a}$Â∞±ÊòØ$P(X)$ÁöÑÁ≥ªÊï∞Ë°®Á§∫Ê≥ïÁöÑÂêëÈáè„ÄÇ ÁÇπÂÄºË°®Á§∫Ê≥ïÂØπ‰∫éËøô‰∏™Â§öÈ°πÂºèËã•Êàë‰ª¨‰∏çÁü•ÈÅìÂÆÉÁöÑÁ≥ªÊï∞,Êàë‰ª¨ÂèØ‰ª•Áî®ÈááÊ†∑ÁöÑÊñπÂºèÂ∞Ü‰∏ÄÁªÑÊèíÂÄºËäÇÁÇπ$(x_0,x_1,\cdot\cdot\cdot,x_n)$‰ª£ÂÖ•‰∏äÂºè ÂæóÂà∞$n+1$‰∏™‰∏çÂêåÁöÑÁªìÊûú$(y_0,y_1,\cdot\cdot\cdot,y_n)$ÔºåÂ∞±ÂèØ‰ª•ÂîØ‰∏ÄÁ°ÆÂÆöËøô‰∏™Â§öÈ°πÂºè. ÁÇπÂÄºË°®Á§∫Ê≥ïÊ≠£Á°ÆÊÄßÁöÑËØÅÊòé ËØÅÊòé: ÂÅáËÆæÂéüÂëΩÈ¢ò‰∏çÊàêÁ´ãÂç≥Â≠òÂú®‰∏§‰∏™‰∏çÂêåÁöÑÂ§öÈ°πÂºè$A(x),B(x)$Âú®$\forall i\in[0,n]$ÔºåÈÉΩÊúâ$A(x_i)=B(x_i)$ ÈÇ£‰πàÂÅáËÆæÁî®$A(x_i)-B(x_i) = H(x_i) = 0$,ÈÇ£‰πà$H(x_i)$Êúâ$(n+1)$‰∏™Ê†π,Ëøô‰∏é$n$Ê¨°Â§öÈ°πÂºèÂè™Êúâ$n$‰∏™Ê†πÁöÑ‰ª£Êï∞Âü∫Êú¨ÂÆöÁêÜÁõ∏ÁüõÁõæÔºåÁüõÁõæÔºÅÊïÖÂÅáËÆæ‰∏çÊàêÁ´ãÔºÅ $\therefore$ÂéüÂëΩÈ¢òÊ≠£Á°ÆÊÄßÊòæÁÑ∂. ËÄå$FFT$Â∞±ÊòØÂà©Áî®‰∫ÜÁÇπÂÄºÂíåÁ≥ªÊï∞Ë°®Á§∫‰πãÈó¥ÁöÑÂÖ≥Á≥ªÔºåÂú®Âø´ÈÄüÊ±ÇÁÇπÂÄºÊù•Ë°®Á§∫Á≥ªÊï∞ÔºåÊê≠Ëµ∑Ëøô‰∏§‰∏™ÂèòÊç¢ÁöÑÊ°•Ê¢Å. Â§öÈ°πÂºèÁöÑ‰πòÈô§Ê≥ï‰πòÊ≥ï:Âè´ÂÅöÂç∑ÁßØ,‰πü‰ΩúÂ•ÜÁßØ„ÄÇÂΩ¢Ë±°Âú∞ÂèØ‰ª•ÂÜôÊàê: c_i=\sum_{j=0}^{i}a_j*b_{i-j}Áî®Ëøô‰∏™ÂÖ¨Âºè‰∏çÈöæÂæóÂà∞‰∏Ä‰∏™$O(n^2)$ÁöÑÁÆóÊ≥ï. Èô§Ê≥ï:Â∞±ÊòØÂ§ßÈô§Ê≥ï,Â∞èÂ≠¶/Âàù‰∏≠Â••Êï∞ÈÉ®ÂàÜ‰∏çËµòËø∞‰∫Ü. Âçï‰ΩçÊ†πÂèäÂÖ∂ÊÄßË¥® ËØÅÊòé‰∏ÄÔºö Áî±Âá†‰ΩïÊÑè‰πâÔºåËøô‰∏§ËÄÖË°®Á§∫ÁöÑÂêëÈáèÁªàÁÇπÊòØÁõ∏ÂèçÁöÑÔºåÂ∑¶ËæπËæÉÂè≥ËæπÂú®Âçï‰ΩçÂúÜ‰∏äÂ§öËΩ¨‰∫ÜÂçäÂúà„ÄÇ ËØÅÊòé‰∫åÔºö Áî±ËÆ°ÁÆóÁöÑÂÖ¨ÂºèÔºö ÊúÄÂêé‰∏ÄÊ≠•Áî±‰∏âËßíÊÅíÁ≠âÂèòÊç¢ÂæóÂà∞„ÄÇ FFT(Ê≥ïÊ≥ïÂ°î) ‰ΩÜÊòØËøôÊ†∑ÁöÑÊìç‰ΩúÂ∏∏Êï∞ÁàÜÁÇ∏..FFTÊú¨Ë∫´ÁöÑÂ∏∏Êï∞Â∞±ÂæàÂ•Ü.. ËßÇÂØüÂàÜÁªÑÊÉÖÂÜµ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//ÈÄíÂΩíÁàÜÊ†à LUOGUÁÉ≠Êéâ77ÂàÜ #include&lt;bits/stdc++.h&gt;#define complex COMPLEX//complexÂÖ≥ÈîÆÂ≠ó‰πüÊòØÊúç‰∫Ü using namespace std;const int MAXN=2*1e6+10;inline int read()&#123; char c=getchar();int x=0,f=1; while(!isdigit(c))&#123;if(c=='-')f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;const double Pi=acos(-1.0);struct complex&#123; double x,y; complex (double xx=0,double yy=0)&#123;x=xx,y=yy;&#125;&#125;a[MAXN],b[MAXN];complex operator + (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x+b.x , a.y+b.y);&#125;complex operator - (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x-b.x , a.y-b.y);&#125;complex operator * (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);&#125;//‰∏çÊáÇÁöÑÁúãÂ§çÊï∞ÁöÑËøêÁÆóÈÇ£ÈÉ®ÂàÜ void FFT(int limit,complex *a,int type)&#123; if(limit==1) return ; complex a1[limit&gt;&gt;1],a2[limit&gt;&gt;1]; for(int i=0;i&lt;=limit;i+=2) a1[i&gt;&gt;1]=a[i],a2[i&gt;&gt;1]=a[i+1]; FFT(limit&gt;&gt;1,a1,type); FFT(limit&gt;&gt;1,a2,type); complex Wn=complex(cos(2.0*Pi/limit) , type*sin(2.0*Pi/limit)),w=complex(1,0); for(int i=0;i&lt;(limit&gt;&gt;1);i++,w=w*Wn)//ËøôÈáåÁöÑwÁõ∏ÂΩì‰∫éÂÖ¨Âºè‰∏≠ÁöÑk a[i]=a1[i]+w*a2[i], a[i+(limit&gt;&gt;1)]=a1[i]-w*a2[i];//Âà©Áî®Âçï‰ΩçÊ†πÁöÑÊÄßË¥®ÔºåO(1)ÂæóÂà∞Âè¶‰∏ÄÈÉ®ÂàÜ &#125;int main(int argc, char *argv[])&#123; int N=read(),M=read(); for(int i=0;i&lt;=N;i++) a[i].x=read(); for(int i=0;i&lt;=M;i++) b[i].x=read(); int limit=1;while(limit&lt;=N+M) limit&lt;&lt;=1; FFT(limit,a,1); FFT(limit,b,1); for(int i=0;i&lt;=limit;i++) a[i]=a[i]*b[i]; FFT(limit,a,-1); for(int i=0;i&lt;=N+M;i++) printf("%d ",(int)(a[i].x/limit+0.5)); return 0;&#125; ÈÄíÂΩíÁàÜÊ†à..Ê≤°ËØùËØ¥‰∫Ü. ÊîπËø≠‰ª£ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt; #define complex COMPLEX//complexÂÖ≥ÈîÆÂ≠ó‰πüÊòØÊúç‰∫Ü using namespace std;const int MAXN=1e6+10;inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;const double Pi=acos(-1.0);struct complex&#123; double x,y; complex (double xx=0,double yy=0)&#123;x=xx,y=yy;&#125;&#125;a[MAXN],b[MAXN];complex operator + (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x+b.x , a.y+b.y);&#125;complex operator - (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x-b.x , a.y-b.y);&#125;complex operator * (const complex &amp;a,const complex &amp;b)&#123; return complex(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);&#125;//‰∏çÊáÇÁöÑÁúãÂ§çÊï∞ÁöÑËøêÁÆóÈÇ£ÈÉ®ÂàÜ int N,M;int l,r[MAXN];int limit=1;void FFT(complex *A,int type)&#123; for (int i = 0; i &lt; limit; i++) if (i &lt; r[i]) swap(A[i],A[r[i]]); for (int mid = 1; mid &lt; limit; mid&lt;&lt;=1) &#123; complex Wn(cos(Pi/mid),type*sin(Pi/mid)); for (int R = mid&lt;&lt;1,j = 0; j &lt;limit;j+=R) &#123; complex w(1,0); for (int k = 0; k &lt; mid; k++,w=w*Wn) &#123; complex x=A[j+k],y=w*A[j+mid+k]; A[j+k] = x+y; A[j+mid+k] = x-y; &#125; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; int N=read(),M=read(); for(int i=0;i&lt;=N;i++) a[i].x=read(); for(int i=0;i&lt;=M;i++) b[i].x=read(); while(limit&lt;=N+M) limit&lt;&lt;=1,l++; for(int i=0;i&lt;limit;i++) r[i]= ( r[i&gt;&gt;1]&gt;&gt;1 )| ( (i&amp;1)&lt;&lt;(l-1) ) ; FFT(a,1); FFT(b,1); for(int i=0;i&lt;=limit;i++) a[i]=a[i]*b[i]; FFT(a,-1); for(int i=0;i&lt;=N+M;i++) printf("%d ",(int)(a[i].x/limit+0.5)); return 0;&#125; ÊâÄ‰ª•ËØ¥ÁÆóÊòØÂ∑Æ‰∏çÂ§öÂ≠¶‰ºö‰∫ÜFFT ‰∏äÈÅìÈ¢òÁõÆ LUOGU-1919 Â§ßÊï¥Êï∞‰πòÊ≥ïÁî®FFTÊù•Ë∑ë ÂÖ∂ÂÆûÂ∞±ÊòØËßÑÂÆö‰∫Ü$x=10$ÁöÑFFT. Ê≥®ÊÑèÂâçÂØº0ÁöÑÂ§ÑÁêÜ,ÂÖ∑‰ΩìÂÆûÁé∞Áúã‰ª£Á†Å. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define complex COMPLEX using namespace std;const int MAXN=1e6+10;inline int read()&#123; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;c=getchar();&#125; if(c&gt;='0'&amp;&amp;c&lt;='9') return c-'0';&#125;const double Pi=acos(-1.0);struct complex&#123; double x,y; complex (double xx=0,double yy=0)&#123;x=xx,y=yy;&#125;&#125;a[MAXN],b[MAXN];complex operator + (complex a,complex b)&#123; return complex(a.x+b.x , a.y+b.y);&#125;complex operator - (complex a,complex b)&#123; return complex(a.x-b.x , a.y-b.y);&#125;complex operator * (complex a,complex b)&#123; return complex(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);&#125;int N,M;int l,r[MAXN],ans[MAXN];int limit=1;void FFT(complex *A,int type)&#123; for (int i = 0; i &lt; limit; i++) if (i &lt; r[i]) swap(A[i],A[r[i]]); for (int mid = 1; mid &lt; limit; mid&lt;&lt;=1) &#123; complex Wn(cos(Pi/mid),type*sin(Pi/mid)); for (int R = mid&lt;&lt;1,j = 0; j &lt;limit;j+=R) &#123; complex w(1,0); for (int k = 0; k &lt; mid; k++,w=w*Wn) &#123; complex x=A[j+k],y=w*A[j+mid+k]; A[j+k] = x+y; A[j+mid+k] = x-y; &#125; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; int N;scanf("%d",&amp;N); int M = N; M--,N--; for(int i=0;i&lt;=N;i++) a[i].x=read(); for(int i=0;i&lt;=M;i++) b[i].x=read(); while(limit&lt;=N+M) limit&lt;&lt;=1,l++; for(int i=0;i&lt;limit;i++) r[i]= ( r[i&gt;&gt;1]&gt;&gt;1 )| ( (i&amp;1)&lt;&lt;(l-1) ) ; FFT(a,1); FFT(b,1); for(int i=0;i&lt;=limit;i++) a[i]=a[i]*b[i]; FFT(a,-1); int i; for(i=0;i&lt;=N+M;i++) ans[i+100] = (int)(a[i].x/limit+0.5);//ÂêëÂè≥ËæπÂπ≥Áßª100‰ΩçÊù•Â§ÑÁêÜÂâçÂØº0 for (int j=M+N+100; j&gt;=100; j--) while(ans[j] &gt;= 10) ans[j-1] += ans[j]/10,ans[j]%=10; i = 0; while(!ans[i]) i++; for (;i&lt;=M+N+100;i++) printf("%d",ans[i]); return 0;&#125; NTT$NTT$Â∞±ÊòØÂø´ÈÄüÊï∞ËÆ∫ÂèòÊç¢,ÊòØFFTÁöÑËôöÈÉ®ÂèòÊàêÈùûÊµÆÁÇπËÄåÊîπ‰∏∫Mod‰∏Ä‰∏™ÂÄºÁöÑÂ∫îÁî®. ÂÆûÈÉ®ÊòØÂèØ‰ª•‰∏çÁÆ°ÁöÑ.Êàë‰ª¨ÁöÑÈáçÁÇπÊòØÊääËôöÈÉ®ËΩ¨Âåñ‰∏∫ÂÖ∂‰ªñ‰æø‰∫éËÆ°ÁÆóÁöÑ‰∏úË•ø. ÊéåÊè°‰∫ÜÂÖ≥‰∫éÂéüÊ†πÁöÑÁü•ËØÜÂêé„ÄÇÂ∞±ÂèØ‰ª•ÂæóÂà∞ W_n^n \equiv g^{P-1}\mod{1}ÊâÄ‰ª•Ëøô‰∏™ÂΩ¢ÂºèÂè™ËÉΩÊª°Ë∂≥‰∏ÄÈÉ®ÂàÜÂΩ¢Â¶Ç$2^n*p+1$ÁöÑË¥®Êï∞,ËøôÁßçË¥®Êï∞Âõ†‰∏∫Êª°Ë∂≥Ë¥πÈ©¨Â∞èÂÆöÁêÜ$a^p\equiv{1}\mod{p}$ Âè´ÂÅöË¥πÈ©¨Ë¥®Êï∞„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Âè™ËÉΩModË¥πÈ©¨Ë¥®Êï∞ÁöÑNTT#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL a[400010],b[400010],c[400010];int p=1004535809,g=3,n,m,bin[400010]; //p = 2^21*479+1 (Fema Prime)LL pow(LL a,int b,int mod)&#123; LL ans=1; while(b) &#123; if(b&amp;1) ans=ans*a%mod; a=a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;void ntt(LL *a,int n,int op)&#123; for(int i=0;i&lt;n;i++) if(i&lt;bin[i]) swap(a[i],a[bin[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; LL wn=pow((LL)g,op==1?(p-1)/(2*i):p-1-(p-1)/(2*i),p),t,w; for(int j=0;j&lt;n;j+=i&lt;&lt;1) &#123; w=1; for(int k=0;k&lt;i;k++) &#123; t=w*a[i+j+k]%p;w=w*wn%p; a[i+j+k]=(a[j+k]-t+p)%p;a[j+k]=(a[j+k]+t)%p; &#125; &#125; &#125; if(op==-1) &#123; LL inv=pow(n,p-2,p); for(int i=0;i&lt;n;i++) a[i]=a[i]*inv%p; &#125;&#125;int main(int argc, char *argv[])&#123; scanf("%d %d",&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(int i=0;i&lt;=m;i++) scanf("%lld",&amp;b[i]); m+=n;n=1;while(n&lt;=m) n&lt;&lt;=1; for(int i=0;i&lt;n;i++) bin[i]=(bin[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); ntt(a,n,1);ntt(b,n,1); for(int i=0;i&lt;n;i++) c[i]=a[i]*b[i];ntt(c,n,-1); for(int i=0;i&lt;=m;i++) printf("%lld ",c[i]); return 0;&#125; ÈÇ£‰πàÂ¶ÇÊûú‰∏çÊòØË¥πÈ©¨Ë¥®Êï∞ Âèñ‰∏Ä‰∏™‰ªªÊÑèÁöÑÊï∞ÂèñÊ®° Â≤Ç‰∏çÊòØË¶Å$gg$ Âõ†‰∏∫MYYÂú®ËÆ∫Êñá‰∏≠ÊèêÂá∫‰∏âÊ¨°Ê±ÇModÂÜçCRT(China Remainder Theorem)ÁöÑÂÅöÊ≥ï Â∞±Ë¢´Áß∞‰∏∫MTT‰∫Ü(Èõæ Ê®°ÊùøÈ¢ò MTT,LUOGU-4245 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//ÂØπ‰∫é‰ªªÊÑèModÁöÑNTT//Áî®MYYÁöÑ‰∏âÊ®°Ê≥ï.//%%%%% #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int P=23333333;const int M[]= &#123;998244353,1004535809,469762049&#125;;const int G[]= &#123;3,3,3&#125;;const ll _M=(ll)M[0]*M[1];inline ll Pow(ll a,int b,int p) &#123; ll ret=1; for (; b; b&gt;&gt;=1,a=a*a%p) if (b&amp;1) ret=ret*a%p; return ret;&#125;inline ll mul(ll a,ll b,ll p) &#123; a%=p; b%=p; return ((a*b-(ll)((ll)((long double)a/p*b+1e-3)*p))%p+p)%p;&#125;const int m1=M[0],m2=M[1],m3=M[2];const int inv1=Pow(m1%m2,m2-2,m2),inv2=Pow(m2%m1,m1-2,m1),inv12=Pow(_M%m3,m3-2,m3);inline int CRT(int a1,int a2,int a3) &#123; ll A=(mul((ll)a1*m2%_M,inv2,_M)+mul((ll)a2*m1%_M,inv1,_M))%_M; ll k=((ll)a3+m3-A%m3)*inv12%m3; return (k*(_M%P)+A)%P;&#125;const int N=264000;struct NTT &#123; int P,G; int num,w[2][N]; int R[N]; void Pre(int _P,int _G,int m) &#123; num=m; P=_P;G=_G; int g=Pow(G,(P-1)/num,P); w[1][0]=1; for (int i=1; i&lt;num; i++) w[1][i]=(ll)w[1][i-1]*g%P; w[0][0]=1; for (int i=1; i&lt;num; i++) w[0][i]=w[1][num-i]; int L=0;while (m&gt;&gt;=1) L++; for (int i=1; i&lt;=num; i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1)); &#125; void FFT(int *a,int n,int r) &#123; for (int i=0; i&lt;n; i++) if (i&lt;R[i]) swap(a[i],a[R[i]]); for (int i=1; i&lt;n; i&lt;&lt;=1) for (int j=0; j&lt;n; j+=(i&lt;&lt;1)) for (int k=0; k&lt;i; k++) &#123; int x=a[j+k],y=(ll)a[j+i+k]*w[r][num/(i&lt;&lt;1)*k]%P; a[j+k]=(x+y)%P; a[j+i+k]=(x+P-y)%P; &#125; if (!r) for (int i=0,inv=Pow(n,P-2,P); i&lt;n; i++) a[i]=(ll)a[i]*inv%P; &#125;&#125; ntt[3];int n,m,n1,n2;int a[3][N];int A[N],B[N],C[N],D[N];int main(int argc, char *argv[]) &#123; scanf("%d%d%d",&amp;n1,&amp;n2,&amp;P); for (int i=0; i&lt;=n1; i++) scanf("%d",&amp;A[i]); for (int i=0; i&lt;=n2; i++) scanf("%d",&amp;B[i]); for (m=1; m&lt;=(n1+n2); m&lt;&lt;=1); for (int i=0; i&lt;3; i++) ntt[i].Pre(M[i],G[i],m); for (int i=0; i&lt;3; i++) &#123; memcpy(C,A,sizeof(int)*(m+5)); memcpy(D,B,sizeof(int)*(m+5)); ntt[i].FFT(C,m,1); ntt[i].FFT(D,m,1); for (int j=0; j&lt;m; j++) C[j]=(ll)C[j]*D[j]%ntt[i].P; ntt[i].FFT(C,m,0); for (int j=0; j&lt;m; j++) a[i][j]=C[j]; &#125; for (int i=0; i&lt;=n1+n2; i++) printf("%d ",CRT(a[0][i],a[1][i],a[2][i])); return 0;&#125;]]></content>
      <categories>
        <category>FFT/NTT</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-11525] Permutation Ê†ëÁä∂Êï∞ÁªÑÊ±Çkth element+Â∫∑ÊâòÂ±ïÂºÄ]]></title>
    <url>%2F2018%2F02%2F22%2FUVa-11525-Permutation-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82kth-element-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®: UVa-11525 È¢òÁõÆÂ§ßÊÑè:ËæìÂá∫1..nÁöÑÂÖ®ÈÉ®ÊéíÂàóÂ≠óÂÖ∏Â∫èÂ§ßÂ∞èÁöÑÁ¨¨\sum_{i=1}^{k} S_i * (K-i)!‰∏™ Ê†∑‰æã12345678910111213141516Sample Input432 1 031 0 042 1 1 041 2 1 0Sample Output3 2 12 1 33 2 4 12 4 3 1 ÊÄùË∑ØÂ∫∑ÊâòÂ±ïÂºÄ‰∫ÜËß£‰∏Ä‰∏ã X = a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[1]*0!ÂÖ∂‰∏≠a[i]‰∏∫Á¨¨i‰ΩçÂæÄÂè≥ËæπÁöÑÊï∞ÈáåÁ¨¨Âá†Â§ßÂÖ∂ÂÆûÂíåÊï∞‰Ωçdp‰∏Ä‰∏™ÈÅìÁêÜ„ÄÇÂÖ∑‰ΩìÁöÑÊ†óÂ≠êÔºàÊëòËá™cnblogÔºâ Â¶ÇÊàëÊÉ≥Áü•ÈÅì321ÊòØ{1,2,3}‰∏≠Á¨¨Âá†‰∏™Â§ßÁöÑÊï∞ÂèØ‰ª•ËøôÊ†∑ËÄÉËôë Ôºö\\\\\ Á¨¨‰∏Ä‰ΩçÊòØ3ÔºåÂΩìÁ¨¨‰∏Ä‰ΩçÁöÑÊï∞Â∞è‰∫é3Êó∂Ôºå\\\\ ÈÇ£ÊéíÂàóÊï∞Â∞è‰∫é321 Â¶Ç 123„ÄÅ 213 ÔºåÂ∞è‰∫é3ÁöÑÊï∞Êúâ1„ÄÅ2 „ÄÇ\\\\ ÊâÄ‰ª•Êúâ2*2!‰∏™„ÄÇÂÜçÁúãÂ∞è‰∫éÁ¨¨‰∫å‰Ωç2ÁöÑÔºöÂ∞è‰∫é2ÁöÑÊï∞Âè™Êúâ‰∏Ä‰∏™Â∞±ÊòØ1 Ôºå\\\\ÊâÄ‰ª•Êúâ1*1!=1 ÊâÄ‰ª•Â∞è‰∫é321ÁöÑ{1,2,3}ÊéíÂàóÊï∞Êúâ2*2!+1*1!=5‰∏™ „ÄÇ\\\\ÊâÄ‰ª•321ÊòØÁ¨¨6‰∏™Â§ßÁöÑÊï∞„ÄÇ \\\\2*2!+1*1!ÊòØÂ∫∑ÊâòÂ±ïÂºÄ„ÄÇÁÑ∂ÂêéÊòØÊ†ëÁä∂Êï∞ÁªÑÔºàFenwickÊ†ëÔºâÊ±ÇÁ¨¨kÂ∞è ËøôÂÖ∂ÂÆûÊòØ‰∏Ä‰∏™ÂèçÂêëÊûö‰∏æÊûÑÈÄ†+‰∫åÂàÜÁöÑËøáÁ®ã ÂÖ∑‰ΩìÁúã‰ª£Á†ÅÂÆûÁé∞Âêß„ÄÇ ‰ª£Á†Å12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define maxn 50005using namespace std;#define lowbit(x) (x&amp;-x)int c[maxn], K;void add(int pos)&#123; while(pos&lt;=K)&#123; c[pos]++; pos+=lowbit(pos); &#125;&#125;int query(int pos)&#123; int res=0; while(pos&gt;0)&#123; res+=c[pos]; pos-=lowbit(pos); &#125; return res;&#125;int BS(int num)&#123; int l=0,r=K+1; while(l&lt;r-1)&#123; int mid=(l+r)/2; if(mid-query(mid)&gt;=num) r=mid; else l=mid; &#125; return r;&#125;int main(int argc, char *argv[])&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;K); memset(c,0,sizeof(c)); for(int i=0;i&lt;K;i++) &#123; int t; scanf("%d",&amp;t); t++; int k=BS(t); printf("%d%c",k,(i==K-1)?'\n':' '); add(k); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Á∫øÊÆµÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-12299] RMQ with Shifts Á∫øÊÆµÊ†ëÂçïÁÇπ‰øÆÊîπÂå∫Èó¥Êü•ËØ¢]]></title>
    <url>%2F2018%2F02%2F22%2FUVa-12299-RMQ-with-Shifts-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®: UVa-12299 È¢òÁõÆÂ§ßÊÑè:Âú®‰º†ÁªüÁöÑRMQÈóÆÈ¢ò‰∏äÂ§öÈôÑÂä†‰∏Ä‰∏™shift(x_1,x_2,...,x_n)ÁöÑÊìç‰Ωú,‰ΩøÂæóËøô‰∫õÊìç‰ΩúÁöÑÊï∞ÂàóËΩÆÊç¢‰∏Ä‰Ωç„ÄÇ ÁªôÂá∫ÁöÑËßÑÊ®°ÊòØn \leq 100000,q \leq 250000 Ê†∑‰æãÁúã‰º†ÈÄÅÈó®Âêß. ÊÄùË∑Ø‰ΩÜÊòØ,,ËæìÂÖ•‰∏≠Êìç‰ΩúË°åÁöÑÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶Â∞è‰∫éÁ≠â‰∫é30. ‰πüÂ∞±ÊòØËØ¥shiftÊìç‰ΩúÈáåÁöÑÂÖÉÁ¥†‰∏ç‰ºöÂæàÂ§ö„ÄÇ ÈÇ£‰πàÂ∞±Êö¥ÂäõÂú∞‰∏äÂêß. ‰∫éÊòØÁ¨¨‰∏ÄÊ¨°ÂÜôÂá∫Êù• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1const int maxn = 1e5+10;int n,q,a[maxn],b[maxn];char req;vector&lt;int&gt;r,w;inline void read(int &amp;x)&#123; x=0;char ch=getchar();if(ch=='\n')&#123;x=-2333333;return;&#125;int f=1; while(!isdigit(ch))&#123;if (ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;struct SegmentTree&#123; int lazy[maxn&lt;&lt;2],minv[maxn&lt;&lt;2]; void pushup(int rt)&#123;minv[rt] = min(minv[lc],minv[rc]);&#125; void build(int rt,int l,int r) &#123; if (l == r) &#123; minv[rt] = a[l]; return ; &#125; int m = (l+r) &gt;&gt; 1; build(lc,l,m); build(rc,m+1,r); pushup(rt); &#125; void update(int p,int v,int L,int R,int rt) // LR‰øÆÊîπÂå∫Èó¥ &#123; if (L == R) &#123; minv[rt] = v; return ; &#125; int m = (L+R) &gt;&gt; 1; if(p &lt;= m) update(p,v,L,m,lc); else update(p,v,m+1,R,rc); pushup(rt); &#125; int query(int ql,int qr,int l,int r,int rt) &#123; int ans = INT_MAX,m = (l+r)&gt;&gt;1; if (ql &lt;= l &amp;&amp; qr &gt;= r) return minv[rt]; if (ql &lt;= m) ans = min(ans,query(ql,qr,l,m,lc)); if (qr &gt; m) ans = min(ans,query(ql,qr,m+1,r,rc)); return ans; &#125;&#125;Tree;int main(int argc, char *argv[])&#123; read(n); read(q); for (int i = 1; i &lt;= n; i++) read(a[i]); Tree.build(1,1,n); while(q--) &#123; req = '6'; memcpy(b,a,sizeof(a)); while(!isalpha(req)) req = getchar(); if (req == 'q') &#123; int x,y; read(x),read(y); printf("%d\n",Tree.query(x,y,1,n,1)); &#125; else if (req == 's') &#123; int x; r.clear(); read(x); while(x!=-2333333) &#123; r.push_back(x); read(x); &#125; for (int i = 0; i &lt; r.size(); i++) &#123; //printf("Elements: "); //printf("%d ",r[i]); //puts(""); if (i == r.size()-1) a[r[i]] = b[r[0]],Tree.update(r[i],b[r[0]],1,n,1); else a[r[i]] = b[r[i+1]],Tree.update(r[i],b[r[i+1]],1,n,1); &#125; &#125; &#125; return 0;&#125; ‰∏≠Èó¥Â≠óÁ¨¶‰∏≤Â§ÑÁêÜÂç°‰∫ÜÂ•Ω‰πÖÂì¶.‰∏çÂæó‰∏çÂú®Âø´ËØª‰∏≠Âä†Âà§Êñ≠Êç¢Ë°åËøîÂõû-2333333Êù•ÁöÆ‰∏ÄÊ≥¢. ‰ΩÜÊòØTÈ£û‰∫Ü.. Ê£ÄÊü•‰∫ÜÂçäÂ§©Ê≤°ËßâÂæóÂì™Èáå‰∏çÂØπÂä≤,ÁÑ∂ÂêéÂ∞ùËØïÁùÄÊäävectorÊîπÊàê‰∫ÜÂÆöÈïøÊï∞ÁªÑ,ÊäämemcpyÂéªÊéâ. Â∞±Ëøá‰∫Ü.. ÂÆûË∑µËØÅÊòé,memcpyÁ°ÆÂÆûÊÖ¢ÁöÑÂèØ‰ª•. ‰ª£Á†Å1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1const int maxn = 1e5+10;int n,q,a[maxn],b[maxn];char req;int r[41],w[41],cnt = 0;inline void read(int &amp;x)&#123; x=0;char ch=getchar();if(ch=='\n')&#123;x=-2333333;return;&#125;int f=1; while(!isdigit(ch))&#123;if (ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;struct SegmentTree&#123; int lazy[maxn&lt;&lt;2],minv[maxn&lt;&lt;2]; void pushup(int rt)&#123;minv[rt] = min(minv[lc],minv[rc]);&#125; void build(int rt,int l,int r) &#123; if (l == r) &#123; minv[rt] = a[l]; return ; &#125; int m = (l+r) &gt;&gt; 1; build(lc,l,m); build(rc,m+1,r); pushup(rt); &#125; void update(int p,int v,int L,int R,int rt) // LR‰øÆÊîπÂå∫Èó¥ &#123; if (L == R) &#123; minv[rt] = v; return ; &#125; int m = (L+R) &gt;&gt; 1; if(p &lt;= m) update(p,v,L,m,lc); else update(p,v,m+1,R,rc); pushup(rt); &#125; int query(int ql,int qr,int l,int r,int rt) &#123; int ans = INT_MAX,m = (l+r)&gt;&gt;1; if (ql &lt;= l &amp;&amp; qr &gt;= r) return minv[rt]; if (ql &lt;= m) ans = min(ans,query(ql,qr,l,m,lc)); if (qr &gt; m) ans = min(ans,query(ql,qr,m+1,r,rc)); return ans; &#125;&#125;Tree;int main(int argc, char *argv[])&#123; read(n); read(q); for (int i = 1; i &lt;= n; i++) read(a[i]); Tree.build(1,1,n); while(q--) &#123; req = '6'; while(!isalpha(req)) req = getchar(); if (req == 'q') &#123; int x,y; read(x),read(y); printf("%d\n",Tree.query(x,y,1,n,1)); &#125; else if (req == 's') &#123; int x; cnt = 0; read(x); while(x!=-2333333) &#123; r[++cnt] = x; w[cnt] = a[x]; read(x); &#125; for (int i = 1; i &lt;= cnt-1; i++) a[r[i]] = w[i+1],Tree.update(r[i],w[i+1],1,n,1); a[r[cnt]] = w[1],Tree.update(r[cnt],w[1],1,n,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Á∫øÊÆµÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-5902] Movie Collection FenwickÊ†ë]]></title>
    <url>%2F2018%2F02%2F22%2FLA-5902-Movie-Collection-Fenwick%E6%A0%91%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®:LA-5902 È¢òÁõÆÂ§ßÊÑè:Êúân‰∏™Áâ©ÂìÅ‰ªé‰∏äÂà∞‰∏ãÊîæÁΩÆ,Âπ∂‰∏îÊ†áÂè∑1..n,ÊúânÊ¨°Êü•ËØ¢,ÊØèÊ¨°Êü•ËØ¢Ê†áÂè∑‰∏∫xÁöÑÁâ©ÂìÅÁé∞Âú®ÁöÑ‰ΩçÁΩÆÔºà0..n,Âç≥ËØ•Áâ©ÂìÅ‰∏äÈù¢ÊúâÂ§öÂ∞ë‰∏™Áâ©ÂìÅÔºâ,ÂêåÊó∂Â∞ÜËØ•Áâ©ÂìÅÂèñÂá∫ÊîæÂà∞Á¨¨0Âè∑‰ΩçÁΩÆ„ÄÇ Ê†∑‰æã123456789Sample Input23 33 1 15 34 4 5Sample Output2 1 03 0 4 ÊÄùË∑ØËøòÊòØ‰∏çÈöæÊÉ≥Âà∞ÁöÑ,Â∞Ü1~n‰ª∂Áâ©ÂìÅÈáçÊñ∞ÁºñÂè∑,1~nÊ†á‰∏∫n~1,ÊØèÊ¨°ÊãøÂá∫‰∏Ä‰ª∂Áâ©ÂìÅx,ÂÜçÂ∞ÜÂÖ∂ÈáçÊñ∞ÁºñÂè∑,Â¶ÇÊûúÊòØÁ¨¨‰∏ÄÊ¨°ÊãøÂá∫Â∞±Ê†á‰∏∫n+1‚Ä¶..‰æùÊ¨°ÈÄíÂ¢û,ÁÑ∂ÂêéÂ∞Ü‰πãÂâçÁöÑÁºñÂè∑Âà†Êéâ,ÊèíÂÖ•Êñ∞ÁöÑÁºñÂè∑Âç≥ÂèØÔºåÁî®‰∏Ä‰∏™Ê†ëÁä∂Êï∞ÁªÑÁª¥Êä§ ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2*1e5+10;#define lowbit(x) (x&amp;-x)int T,n,m;int pos[maxn],c[maxn];inline void read(int &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;int sum(int x)&#123; int ret = 0; while(x)&#123;ret+=c[x];x-=lowbit(x);&#125; return ret;&#125;void add(int x,int d)&#123; while(x&lt;=maxn) &#123; c[x]+=d; x+=lowbit(x); &#125;&#125;int main(int argc, char *argv[])&#123; read(T); while(T--) &#123; read(n),read(m); for (int i = 1; i &lt;= n; i++) pos[i] = n + 1 - i; for (int i = 1; i &lt; maxn; i++) c[i] = lowbit(i); int t = n; for (int i = 0; i &lt; m; i++) &#123; int id; read(id); if (i != 0) printf(" "); printf("%d",n-sum(pos[id])); add(pos[id],-1); pos[id] = ++t; &#125; printf("\n"); &#125; return 0;&#125; ‰∏ÄÁúãRankÊ¶úÊòØÁ¨¨‰∏Ä. Á™ÉÂñú]]></content>
      <categories>
        <category>Á∫øÊÆµÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-4108] Skyline Á∫øÊÆµÊ†ë/Ê†ëÁä∂Êï∞ÁªÑ+‰∫åÂàÜ]]></title>
    <url>%2F2018%2F02%2F22%2FLA-4108-Skyline-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®: LA-4108 Ê†∑‰æãSample Input135 11 31 10 13 13 20Sample Output14 ÊÄùË∑ØÁ∫øÊÆµÊ†ëÂå∫Èó¥Êõ¥Êñ∞Áª¥Êä§ÊúÄÂ§ßÂÄºÂç≥ÂèØ Ë£∏È¢òÂïä ‰ª£Á†Å1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1#define maxn 100010inline void read(int &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;int ans = 0,n;struct SegmentTree&#123; int lazy[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2]; void Pushup(int rt) &#123; maxv[rt] = max(maxv[lc],maxv[rc]); &#125; void Pushdown(int rt) &#123; lazy[lc] = max(lazy[lc],lazy[rt]); lazy[rc] = max(lazy[rc],lazy[rt]); &#125; void Update(int rt,int l,int r,int x,int y,int v) &#123; if (lazy[rt] &gt; v) return ; if (x &lt;= l &amp;&amp; y &gt;= r &amp;&amp; v &gt;= maxv[rt]) &#123; ans += (r-l+1); maxv[rt] = v; lazy[rt] = v; return ; &#125; if (l == r) return ; Pushdown(rt); int m = (l+r) &gt;&gt; 1; if (x &lt;= m) Update(lc,l,m,x,y,v); if (y &gt; m) Update(rc,m+1,r,x,y,v); Pushup(rt); &#125;&#125;Tree;int main(int argc, char *argv[])&#123; int t,f,g,h; read(t); &#123; while(t--) &#123; ans = 0; memset(Tree.lazy,0,sizeof(Tree.lazy)); memset(Tree.maxv,0,sizeof(Tree.maxv)); read(n); while(n--) &#123; read(f),read(g),read(h); Tree.Update(1,1,maxn,f,g-1,h); &#125; printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Á∫øÊÆµÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-2191] Potentiometers Ê†ëÁä∂Êï∞ÁªÑ]]></title>
    <url>%2F2018%2F02%2F22%2FLA-2191-Potentiometers-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®:LA-2191 È¢òÁõÆÂ§ßÊÑè:Âü∫Êú¨Ê†ëÁä∂Êï∞ÁªÑÁöÑÊìç‰ΩúÔºåÊääadd(x,d)ÊîπÊàê‰∫ÜS(x,d)ÔºåÊääÁ¨¨x‰Ωç‰∏äÁöÑÂèòÊàêd. Ê†∑‰æã3100100100M 1 1M 1 3S 2 200M 1 2S 3 0M 2 3END1012345678910M 1 10END0Sample OutputCase 1:100300300200Case 2:55 ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std; const int MAXN=200000+10; int a[MAXN],c[MAXN],n; inline int lowbit(const int &amp;x)&#123;return x&amp;(-x);&#125; void add(int x,int d) &#123; while(x&lt;=n) &#123; c[x]+=d; x+=lowbit(x); &#125; &#125; long long sum(int L,int R) &#123; int x=R; long long ans=0; while(x&gt;0) &#123; ans+=c[x]; x-=lowbit(x); &#125; return ans; &#125; int main(int argc,char *argv[]) &#123; int kase=1; while(scanf("%d",&amp;n),n) &#123; if(kase!=1) printf("\n"); printf("Case %d:\n",kase++); memset(c,0,sizeof(c)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); add(i,a[i]); &#125; char action[10]; while(scanf("%s",action),strcmp(action,"END")) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); if(action[0]=='S') &#123; add(x,y-a[x]); a[x]=y; &#125; else &#123; printf("%lld\n",sum(x,y)-sum(1,x-1));&#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Á∫øÊÆµÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-4730] Kingdom Âπ∂Êü•ÈõÜ+Á∫øÊÆµÊ†ë]]></title>
    <url>%2F2018%2F02%2F22%2FLA-4730-Kingdom-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®:LA-4730 È¢òÁõÆÂ§ßÊÑèÔºö There were N cities in an ancient kingdom. In the beginning of the kingdom, all cities were isolated. Kings ordered their subjects to construct roads connecting cities. A lot of roads were built with time. Every road was always constructed along the line segment between two cities. All cities are partitioned into disjoint components of cities by road-connectivity. A connected component of cities was called a state. A state consists of cities and roads connecting them. A historical record tells a time sequence of road constructions in order. A road connecting two citiesA and B doesn‚Äôt intersect with other roads at a point except forA and B. Before construction,A and B may have belonged to the same state or different states. After construction,A and B would belong to a same state, i.e., two states would merge into a state if needed. Prof. Kim, a historian, is concerned about the following question: How many states does a horizontal line (corresponding to the latitude of a specific place) pass by at a moment of the past? The figure below shows an example of a configuration of roads at some moment. A circle represents a city and a line segment represents a road between two cities. There are 3 states. A line with y = 4.5 passes by two states with total 8 cities and a line with y = 6.5 passes by one state with 5 cities. ÔºàÈÄÉ Ê≠£ÁªèÔºö Âπ≥Èù¢‰∏äÊúân‰∏™ÂüéÂ∏ÇÔºåÂàùÂßãÊó∂ÂüéÂ∏Ç‰πãÈó¥Ê≤°Êúâ‰ªª‰ΩïÂèåÂêëÈÅìË∑ØÁõ∏Ëøû„ÄÇ‰Ω†ÁöÑ‰ªªÂä°ÊòØ‰∏ÄÊ¨°ÊâßË°å‰ª•‰∏ãÊåá‰ª§„ÄÇ road A BÔºöÂú®ÂüéÂ∏ÇAÂíåB‰πãÈó¥Ëøû‰∏ÄÊù°ÂèåÂêëÈÅìË∑ØÔºå‰øùËØÅËøôÊù°ÈÅìË∑Ø‰∏çÂíåÂÖ∂‰ªñÈÅìË∑ØÂú®ÈùûÁ´ØÁÇπÂ§ÑÁõ∏‰∫§„ÄÇ line CÔºöËØ¢ÈóÆ‰∏ÄÊù°Y=CÁöÑÊ∞¥Âπ≥Á∫øÂíåÂ§öÂ∞ë‰∏™Â∑ûÁõ∏‰∫§Ôºå‰ª•ÂèäËøô‰∫õÂ∑û‰∏ÄÂÖ±ÂåÖÂê´Â§öÂ∞ëÂ∫ßÂüéÂ∏Ç„ÄÇ ÊÄùË∑ØÁúãÂà∞ÂåÖÂê´Â§öÂ∞ëÂüéÂ∏ÇÊÉ≥Âà∞Âπ∂Êü•ÈõÜ„ÄÇËøôÈáåÂ¶ÇÊûúÂçï‰∏™Êûö‰∏æÁöÑËØùÂæàË¥πÊó∂Èó¥‰ºöTÈ£û Êàë‰ª¨Â∞±Áî®Á∫øÊÆµÊ†ëÊù•Áª¥Êä§Âå∫Èó¥ÂÜÖÁöÑÂüéÂ∏ÇÊï∞ÈáèÂíåÂ∑ûÁöÑÊï∞Èáè„ÄÇ ÂèëÁé∞ÂÖ∂ÂÆûËøôÈ¢ò‰∏éxËΩ¥‰∏äÁöÑÂ§ßÂ∞èÂÄºÊ≤°Êúâ‰ªª‰ΩïÂÖ≥Á≥ª„ÄÇ Âè™Ë¶ÅËÄÉËôëyËΩ¥ÂùêÊ†áÁöÑ‰∏ä‰∏ãÊúÄÂÄºÂç≥ÂèØ Ê≥®ÊÑèÂàÜÁ±ªËÆ®ËÆ∫„ÄÇ ‰ª•ÂèäÂπ∂Êü•ÈõÜÁöÑÊó∂ÂÄôÂà´ÂøòËÆ∞ Ë∑ØÂæÑÂéãÁº© Á∫øÊÆµÊ†ëupdateÂà´ÂÜôÁÇ∏ Â∞±A‰∫Ü ‰ª£Á†Å3617ÂïäÁèÇÊÄï 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1const int maxn = 1e5+5; int miny[maxn],maxy[maxn],n,m,fa[maxn],d[maxn];int getf(int x)&#123;return x == fa[x] ? x : fa[x] = getf(fa[x]);&#125;inline void read(int &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;struct SegmentTree&#123; int sum1[maxn&lt;&lt;2],sum2[maxn&lt;&lt;2]; int lazy1[maxn&lt;&lt;2],lazy2[maxn&lt;&lt;2]; void Pushup(int rt) &#123; sum1[rt] = sum1[rc] + sum1[lc]; sum2[rt] = sum2[rc] + sum2[lc]; &#125; void Pushdown(int rt) &#123; if (lazy1[rt]) &#123; sum1[lc] += lazy1[rt]; sum2[rc] += lazy1[rt]; lazy1[lc] += lazy1[rt]; lazy1[rc] += lazy1[rt]; lazy1[rt] = 0; &#125; if (lazy2[rt]) &#123; sum1[lc] += lazy2[rt]; sum2[rc] += lazy2[rt]; lazy2[lc] += lazy2[rt]; lazy2[rc] += lazy2[rt]; lazy2[rt] = 0; &#125; &#125; void update(int rt,int l,int r,int L,int R,int x,int f) &#123; if (L &gt; R) return ; if(L &lt;= l &amp;&amp; R &gt;= r) &#123; if(!f) &#123; lazy1[rt] += x; sum1[rt] += x; &#125; else &#123; lazy2[rt] += x; sum2[rt] += x; &#125; return ; &#125; Pushdown(rt); int m = (l+r) &gt;&gt; 1; if (l &lt;= m) update(lc,l,m,L,R,x,f); if (r &gt; m) update(rc,m+1,r,L,R,x,f); Pushup(rt); &#125; int query(int rt,int l,int r,int c) &#123; if (l == r) return rt; Pushdown(rt); int m = (l+r) &gt;&gt; 1; if (c &lt;= m) return query(lc,l,m,c); else Pushup(rt); &#125;&#125;Tree;inline void set_init()&#123; memset(miny,0,sizeof(miny)); memset(maxy,0,sizeof(maxy)); memset(Tree.lazy1,0,sizeof(Tree.lazy1)); memset(Tree.sum1,0,sizeof(Tree.sum1)); memset(Tree.lazy2,0,sizeof(Tree.lazy2)); memset(Tree.sum2,0,sizeof(Tree.sum2)); for (int i = 1; i &lt;= n; i++) fa[i] = i; memset(d,1,sizeof(d));&#125;int main(int argc, char *argv[])&#123; int T,Lim; int x,y;double c; char opt[13]; read(T); while(T--) &#123; Lim = -0x7fffffff; read(n); set_init(); for (int i = 1; i &lt;= n; i++) &#123; int t1,t2; read(t1),read(t2); miny[i] = maxy[i] = t2; Lim = max(Lim,t2); &#125; Lim++; read(m); while(m--) &#123; scanf("%s",&amp;opt); if(opt[0] == 'r') &#123; read(x);read(y); int px = getf(x),py = getf(y); if(px == py) ; else &#123; if (maxy[px] &gt; maxy[py]) swap(px,py); if (miny[py] &gt; maxy[px]) &#123; Tree.update(1, 1, Lim, maxy[px] + 1, miny[py], 1, 0); Tree.update(1, 1, Lim, maxy[px] + 1, miny[py], d[px] + d[py], 1); Tree.update(1, 1, Lim, miny[px] + 1, maxy[px], d[py], 1); Tree.update(1, 1, Lim, miny[py] + 1, maxy[py], d[px], 1); &#125; else if (miny[px] &gt; miny[py]) &#123; Tree.update(1, 1, Lim, miny[px] + 1, maxy[px], -1, 0); Tree.update(1, 1, Lim, miny[py] + 1, miny[px], d[px], 1); Tree.update(1, 1, Lim, maxy[px] + 1, maxy[py], d[px], 1); &#125; else &#123; Tree.update(1, 1, Lim, miny[py] + 1, maxy[px], -1, 0); Tree.update(1, 1, Lim, miny[px] + 1, miny[py], d[py], 1); Tree.update(1, 1, Lim, maxy[px] + 1, maxy[py], d[px], 1); &#125; fa[px] = py; d[py] += d[px]; miny[py] = min(miny[py], miny[px]); maxy[py] = max(maxy[py], maxy[px]); &#125; &#125; else &#123; scanf("%lf",&amp;c); int k = Tree.query(1,1,Lim,(int)(c+1)); printf("%d %d\n",Tree.sum1[k],Tree.sum2[k]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Á∫øÊÆµÊ†ë</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âå∫Èó¥‰ø°ÊÅØÁöÑÁª¥Êä§ÂíåÊü•ËØ¢Â≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2018%2F02%2F18%2F%E5%8C%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%B4%E6%8A%A4%E5%92%8C%E6%9F%A5%E8%AF%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Áªà‰∫éÂºÄÂßãÁ£ïÈ´òÁ∫ßÊï∞ÊçÆÁªìÊûÑ‰∫Ü ‰∫åÂèâÁ¥¢ÂºïÊ†ëBinary Index TreeÔºàÊ†ëÁä∂Êï∞ÁªÑÔºâÂä®ÊÄÅÁöÑËøûÁª≠ÂíåÊü•ËØ¢ÈóÆÈ¢ò,Êúân‰∏™ÂÖÉÁ¥†ÁöÑÊï∞ÁªÑËÆæËÆ°‰∏Ä‰∏™Êï∞ÊçÆÁªìÊûÑ,ÊîØÊåÅ‰ª•‰∏ã‰∏§ÁßçÊìç‰Ωú:Add(x,d) ËÆ©A[x]Â¢ûÂä†dQuery(L,R) ËÆ°ÁÆóA[L]+..+A[R]. È¶ñÂÖà‰ªãÁªç‰∏Ä‰∏™Áé©ÊÑèÂè´ÂÅölowbit(x) ÂØπ‰∫éÊ≠£Êï¥Êï∞xÊàë‰ª¨ÂÆö‰πâÂÆÉÁöÑ‰∫åËøõÂà∂ÊúÄÂè≥ËæπÁöÑ1ÁöÑÂÄº‰∏∫lowbit(x)Âú®ËÆ≤BIT‰πãÂâçÔºåÊàë‰ª¨Êù•ÂÖà‰∫ÜËß£‰∏Ä‰∏™ÂáΩÊï∞ÔºöÂØπ‰∫é‰ªªÊÑèÊ≠£Êï¥Êï∞xÔºåÊàë‰ª¨ÂÆö‰πâlowbit(x)‰∏∫xÁöÑ‰∫åËøõÂà∂‰∏≠ÊúÄÂè≥ËæπÁöÑ1ÊâÄÂØπÂ∫îÁöÑÂÄºÔºåÊØîÂ¶ÇÔºå5ÁöÑ‰∫åËøõÂà∂ÊòØ101ÔºåÈÇ£‰πàlowbit(5)= 1Ôºõ4ÁöÑ‰∫åËøõÂà∂ÊòØ100ÔºåÈÇ£‰πàlowbit(4) = 4ÔºõËøôÈáåÁî®Âà∞ÁöÑÊòØÊåâ‰ΩçËøêÁÆóÔºåËØ∑ËØªËÄÖËá™Â∑±ÂéªÊü•ÈòÖÂÖ≥‰∫éËøôÁÇπÁöÑËµÑÊñô„ÄÇ‰ΩÜ‰∏∫‰ªÄ‰πàÂë¢ÔºüËÆ°ÁÆóÊú∫ÈáåÈù¢ÁöÑÊï¥Êï∞ÈááÁî®Ë°•Á†ÅË°®Á§∫Ôºå-xÂÆûÈôÖ‰∏äÊòØxÂú®‰∫åËøõÂà∂‰∏≠Êåâ‰ΩçÂèñÂèçÔºåÊú´‰Ωç+1ÂêéÁöÑÁªìÊûúÔºå‰∫åËÄÖÊåâ‰ΩçÂèñ‚Äú‰∏é‚Äù‰πãÂêéÔºåÂâçÈù¢ÂÖ®ÈÉ®ÂèòÊàê0Ôºå‰πãÂêéÁöÑlowbit‰øùÊåÅ‰∏çÂèò„ÄÇ ÁÆÄÂçïÁöÑ‰∏§‰∏™Êìç‰ΩúÂ¶Ç‰∏ã12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int n,m,a[maxn],C[maxn];#define lowbit(x) (x&amp;-x)int sum(int x)&#123; int ret = 0; while(x) &#123; ret += C[x]; x -= lowbit(x); &#125; return ret;&#125;void add(int x,int d)&#123; while(x &lt;= n) &#123; C[x] += d; x += lowbit(x); &#125;&#125;int query(int l,int r)&#123;return (sum(r)-sum(l-1));&#125;int main(int argc, char *argv[])&#123; memset(C,0,sizeof(C)); scanf("%d%d",&amp;n,&amp;m); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d",&amp;x); a[i] = x; add(i,x); &#125; while(m--) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",query(x,y)); &#125; return 0;&#125; ‰∏ªË¶ÅÊòØaddÂíåsumËøô‰∏§‰∏™Êìç‰ΩúÂèØ‰ª•Áî®Ëìù‰π¶‰∏ä‰∏§Âº†ÂõæËÆ∞ÂøÜ LA-4329 Ping Pong‰º†ÈÄÅÈó®:LA-4329 È¢òÁõÆÂ§ßÊÑè:ÁªôÂÆö‰∏Ä‰∏™n‰∏™ÂÖÉÁ¥†ÁöÑÊï∞ÁªÑÔºåÊØè‰∏™ÂÖÉÁ¥†ÈÉΩÊúâ‰ΩçÁΩÆÂíåÂÆûÂäõ‰∏§‰∏™ÊùÉÂÄºÔºåÊ±Ç‰∏âÂÖÉÁªÑ(al,ar,ap)ÁöÑ‰∏™Êï∞,ÂÖ∂‰∏≠Ë¶ÅÊ±ÇÊó†ËÆ∫ÊòØ‰ΩçÁΩÆËøòÊòØÂÆûÂäõÂÄºÈÉΩË¶ÅÊª°Ë∂≥l&lt;p&lt;r. ÊÄùË∑Ø:Âä†Ê≥ïÂéüÁêÜÔºåÊàë‰ª¨Âè™Ë¶ÅÊ±ÇÂá∫Âú®Á¨¨i‰∏™‰∫∫ÂΩìË£ÅÂà§ÁöÑÊó∂ÂÄôÂú®ÂâçÂêéÊØîa[i]Â∞èÊàñÊòØÊØîa[i]Â§ßÁöÑ‰∏™Êï∞ÔºåÂ∞±ÂèØ‰ª•Áî®‰πòÊ≥ïÂéüÁêÜÂíåÂä†Ê≥ïÂéüÁêÜËÆ°ÁÆó‰∫Ü„ÄÇÊâÄ‰ª•ÈóÆÈ¢òËΩ¨Âåñ‰∏∫Ê±ÇËøô‰∏™ÊØîa[i]Â∞èÁöÑc[i]ÂíåÊØîa[i]Â§ßÁöÑd[i]Âç≥ÂèØ.Ë¶ÅÊ±ÇÂä®ÊÄÅÔºåËøôÊ†∑Â∞±ÂèØ‰ª•Â•ó‰∏äÊ†ëÁä∂Êï∞ÁªÑ‰∫Ü„ÄÇ‰ª£Á†ÅÂ¶Ç‰∏ã 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;int T,n,a[maxn],C[maxn],D[maxn],bit[maxn];int lowbit(int x)&#123;return (x&amp;-x);&#125;int sum(int x)&#123; int ret = 0; while(x) &#123; ret += bit[x]; x -= lowbit(x); &#125; return ret;&#125;void add(int x,int d)&#123; while(x &lt;= 1e5+10) &#123; bit[x] += d; x += lowbit(x); &#125;&#125;int main(int argc, char *argv[])&#123; scanf("%d",&amp;T); while(T--) &#123; long long ans = 0; memset(bit,0,sizeof(bit)); memset(C,0,sizeof(C)); memset(D,0,sizeof(D)); scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d",&amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; add(a[i],1); C[i] = sum(a[i]-1); &#125; memset(bit,0,sizeof(bit)); for (int i = n; i &gt;= 1; i--) &#123; add(a[i],1); D[i] = sum(a[i]-1); &#125; for (int i = 2; i &lt;= n; i++) ans += C[i] * (n-i-D[i]) + D[i] * (i-1-C[i]); printf("%lld\n",ans); &#125; return 0;&#125; RMQÈóÆÈ¢òRMQ,Âç≥Range Minimum Query,Ë¶ÅÊ±ÇÁªôÂá∫‰∏Ä‰∏™n‰∏™ÂÖÉÁ¥†ÁöÑÊï∞ÂÄº,ËÉΩÂ§üÊü•ËØ¢Âá∫Âå∫Èó¥ËåÉÂõ¥ÂÜÖÁöÑÂÖÉÁ¥†ÊúÄÂ∞èÂÄº ST(Sparse Table)Ë°®O(nlogn) ~ O(1)Âà©Áî®ÈÄíÊé®ÁöÑÊÄùÊÉ≥,‰ª§d(i,j)Ë°®Á§∫‰ªéiÂºÄÂßã,ÈïøÂ∫¶‰∏∫2^jÁöÑ‰∏ÄÊÆµÂÖÉÁ¥†‰∏≠ÁöÑÊúÄÂ∞èÂÄº,ÈÇ£‰πàÊúâËøôÊ†∑ÁöÑÈÄíÊé®Âºèd(i,j)= min(d(i,j-1),d(i+2^(j-1),j-1));‰∏çÈöæÂÜôÂá∫ËøôÊ†∑ÁöÑ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536//RMQÈóÆÈ¢ò #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+10;int a[maxn];int d[maxn][100]; // d[maxn][maxlog(n)];void RMQ_init(int a[],int n)&#123; for (int i = 1; i &lt;= n; i++) d[i][0] = a[i]; for (int j = 1; (1&lt;&lt;j) &lt;= n; j++) for (int i = 0; i + (1&lt;&lt;j) - 1 &lt;= n; i++) //ÂèØ‰ª•‰ªéÁ¨¨0‰ΩçÁΩÆÂºÄÂßã d[i][j] = min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]);&#125; int RMQ_query(int l,int r)&#123; int k = 0; while((1&lt;&lt;(k+1)) &lt;= r-l+1) k++; return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]);&#125;int main(int argc, char *argv[])&#123; int n,t,q,x; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d",&amp;a[i]); RMQ_init(a,n); scanf("%d",&amp;q); while(q--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",RMQ_query(l,r)); &#125; return 0;&#125; Á¨õÂç°Â∞îÊ†ë + LCA + ¬±RMQO(n) ~ O(1)ËøôÊòØ‰∏™Â∑®Â§çÊùÇÁöÑÊñπÊ≥ïÂæàÈöæÂÜôÂØπ ÊåÇ‰∏™ÈìæÊé•Â∞±Ë∑ëhttp://blog.csdn.net/john159151/article/details/19411523 Á∫øÊÆµÊ†ëÂÆö‰πâÂÅáËÆæÊúâÁºñÂè∑‰ªé1Âà∞nÁöÑn‰∏™ÁÇπÔºåÊØè‰∏™ÁÇπÈÉΩÂ≠ò‰∫Ü‰∏Ä‰∫õ‰ø°ÊÅØÔºåÁî®[L,R]Ë°®Á§∫‰∏ãÊ†á‰ªéLÂà∞RÁöÑËøô‰∫õÁÇπ„ÄÇÁ∫øÊÆµÊ†ëÁöÑÁî®Â§ÑÂ∞±ÊòØÔºåÂØπÁºñÂè∑ËøûÁª≠ÁöÑ‰∏Ä‰∫õÁÇπËøõË°å‰øÆÊîπÊàñËÄÖÁªüËÆ°Êìç‰ΩúÔºå‰øÆÊîπÂíåÁªüËÆ°ÁöÑÂ§çÊùÇÂ∫¶ÈÉΩÊòØO(log2(n)). Á∫øÊÆµÊ†ëÁöÑÂéüÁêÜÔºåÂ∞±ÊòØÔºåÂ∞Ü[1,n]ÂàÜËß£ÊàêËã•Âπ≤ÁâπÂÆöÁöÑÂ≠êÂå∫Èó¥(Êï∞Èáè‰∏çË∂ÖËøá4 * n),ÁÑ∂ÂêéÔºåÂ∞ÜÊØè‰∏™Âå∫Èó¥[L,R]ÈÉΩÂàÜËß£‰∏∫Â∞ëÈáèÁâπÂÆöÁöÑÂ≠êÂå∫Èó¥ÔºåÈÄöËøáÂØπËøô‰∫õÂ∞ëÈáèÂ≠êÂå∫Èó¥ÁöÑ‰øÆÊîπÊàñËÄÖÁªüËÆ°ÔºåÊù•ÂÆûÁé∞Âø´ÈÄüÂØπ[L,R]ÁöÑ‰øÆÊîπÊàñËÄÖÁªüËÆ°„ÄÇ ÊâÄ‰ª•Êª°Ë∂≥Áî®Á∫øÊÆµÊ†ëËß£ÂÜ≥ÁöÑÈ¢òÁõÆÂøÖÈ°ªË¶ÅËÉΩÂ§üÁ¨¶ÂêàÂå∫Èó¥Âä†Ê≥ïÁöÑÂéüÂàô,‰øùËØÅÂàÜÊàêÁöÑÂ≠êÂå∫Èó¥L,RËÉΩÂ§üÂæóÂà∞Ê≠£Á°ÆÁöÑÁªüËÆ°ÁªìÊûúÔºåÊç¢Ë®Ä‰πãÔºåË¶ÅËÉΩÂ§üÊª°Ë∂≥Â≠êÂå∫Èó¥Á≠îÊ°à‰πãÂíå‰∏∫ÊÄªÂå∫Èó¥Á≠îÊ°àÁöÑÂéüÂàô„ÄÇ Á¨¶ÂêàÂå∫Èó¥Âä†Ê≥ïÁöÑ‰æãÂ≠êÔºöÊï∞Â≠ó‰πãÂíå‚Äî‚ÄîÊÄªÊï∞Â≠ó‰πãÂíå = Â∑¶Âå∫Èó¥Êï∞Â≠ó‰πãÂíå + Âè≥Âå∫Èó¥Êï∞Â≠ó‰πãÂíåÊúÄÂ§ßÂÖ¨Âõ†Êï∞(GCD)‚Äî‚ÄîÊÄªGCD = gcd( Â∑¶Âå∫Èó¥GCD , Âè≥Âå∫Èó¥GCD );ÊúÄÂ§ßÂÄº‚Äî‚ÄîÊÄªÊúÄÂ§ßÂÄº=max(Â∑¶Âå∫Èó¥ÊúÄÂ§ßÂÄºÔºåÂè≥Âå∫Èó¥ÊúÄÂ§ßÂÄº) ‰∏çÁ¨¶ÂêàÂå∫Èó¥Âä†Ê≥ïÁöÑ‰æãÂ≠êÔºö‰ºóÊï∞‚Äî‚ÄîÂè™Áü•ÈÅìÂ∑¶Âè≥Âå∫Èó¥ÁöÑ‰ºóÊï∞ÔºåÊ≤°Ê≥ïÊ±ÇÊÄªÂå∫Èó¥ÁöÑ‰ºóÊï∞01Â∫èÂàóÁöÑÊúÄÈïøËøûÁª≠Èõ∂‚Äî‚ÄîÂè™Áü•ÈÅìÂ∑¶Âè≥Âå∫Èó¥ÁöÑÊúÄÈïøËøûÁª≠Èõ∂ÔºåÊ≤°Ê≥ïÁü•ÈÅìÊÄªÁöÑÊúÄÈïøËøûÁª≠Èõ∂ ÂéüÁêÜÁ∫øÊÆµÊ†ëÊú¨Ë¥®‰∏äÊòØÁª¥Êä§‰∏ãÊ†á‰∏∫1,2,..,nÁöÑn‰∏™ÊåâÈ°∫Â∫èÊéíÂàóÁöÑÊï∞ÁöÑ‰ø°ÊÅØÔºåÊâÄ‰ª•ÔºåÂÖ∂ÂÆûÊòØ‚ÄúÁÇπÊ†ë‚ÄùÔºåÊòØÁª¥Êä§nÁöÑÁÇπÁöÑ‰ø°ÊÅØ. Á∫øÊÆµÊ†ëÊòØÂ∞ÜÊØè‰∏™Âå∫Èó¥[L,R]ÂàÜËß£Êàê[L,M]Âíå[M+1,R] (ÂÖ∂‰∏≠M=(L+R)/2 ËøôÈáåÁöÑÈô§Ê≥ïÊòØÊï¥Êï∞Èô§Ê≥ïÔºåÂç≥ÂØπÁªìÊûú‰∏ãÂèñÊï¥)Áõ¥Âà∞ L==R ‰∏∫Ê≠¢„ÄÇ ÂºÄÂßãÊó∂ÊòØÂå∫Èó¥[1,n] ,ÈÄöËøáÈÄíÂΩíÊù•ÈÄêÊ≠•ÂàÜËß£ÔºåÂÅáËÆæÊ†πÁöÑÈ´òÂ∫¶‰∏∫1ÁöÑËØùÔºåÊ†ëÁöÑÊúÄÂ§ßÈ´òÂ∫¶‰∏∫ \log_2(n-1)+2Á∫øÊÆµÊ†ëÂØπ‰∫éÊØè‰∏™nÁöÑÂàÜËß£ÊòØÂîØ‰∏ÄÁöÑÔºåÊâÄ‰ª•nÁõ∏ÂêåÁöÑÁ∫øÊÆµÊ†ëÁªìÊûÑÁõ∏ÂêåÔºåËøô‰πüÊòØÂÆûÁé∞ÂèØÊåÅ‰πÖÂåñÁ∫øÊÆµÊ†ëÁöÑÂü∫Á°Ä„ÄÇÂÖ≥‰∫élazyÊ†áËÆ∞ÊÄùÊÉ≥:Á∫øÊÆµÊ†ëÁöÑÂå∫Èó¥‰øÆÊîπ‰πüÊòØÂ∞ÜÂå∫Èó¥ÂàÜÊàêÂ≠êÂå∫Èó¥Ôºå‰ΩÜÊòØË¶ÅÂä†‰∏Ä‰∏™Ê†áËÆ∞ÔºåÁß∞‰ΩúÊáíÊÉ∞Ê†áËÆ∞„ÄÇÊ†áËÆ∞ÁöÑÂê´‰πâÔºöÊú¨ËäÇÁÇπÁöÑÁªüËÆ°‰ø°ÊÅØÂ∑≤ÁªèÊ†πÊçÆÊ†áËÆ∞Êõ¥Êñ∞Ëøá‰∫ÜÔºå‰ΩÜÊòØÊú¨ËäÇÁÇπÁöÑÂ≠êËäÇÁÇπ‰ªçÈúÄË¶ÅËøõË°åÊõ¥Êñ∞„ÄÇÂç≥ÔºåÂ¶ÇÊûúË¶ÅÁªô‰∏Ä‰∏™Âå∫Èó¥ÁöÑÊâÄÊúâÂÄºÈÉΩÂä†‰∏ä1ÔºåÈÇ£‰πàÔºåÂÆûÈôÖ‰∏äÂπ∂Ê≤°ÊúâÁªôËøô‰∏™Âå∫Èó¥ÁöÑÊâÄÊúâÂÄºÈÉΩÂä†‰∏ä1ÔºåËÄåÊòØÊâì‰∏™Ê†áËÆ∞ÔºåËÆ∞‰∏ãÊù•ÔºåËøô‰∏™ËäÇÁÇπÊâÄÂåÖÂê´ÁöÑÂå∫Èó¥ÈúÄË¶ÅÂä†1.Êâì‰∏äÊ†áËÆ∞ÂêéÔºåË¶ÅÊ†πÊçÆÊ†áËÆ∞Êõ¥Êñ∞Êú¨ËäÇÁÇπÁöÑÁªüËÆ°‰ø°ÊÅØÔºåÊØîÂ¶ÇÔºåÂ¶ÇÊûúÊú¨ËäÇÁÇπÁª¥Êä§ÁöÑÊòØÂå∫Èó¥ÂíåÔºåËÄåÊú¨ËäÇÁÇπÂåÖÂê´5‰∏™Êï∞ÔºåÈÇ£‰πàÔºåÊâì‰∏ä+1ÁöÑÊ†áËÆ∞‰πãÂêéÔºåË¶ÅÁªôÊú¨ËäÇÁÇπÁª¥Êä§ÁöÑÂíå+5„ÄÇËøôÊòØÂêë‰∏ãÂª∂Ëøü‰øÆÊîπÔºå‰ΩÜÊòØÂêë‰∏äÊòæÁ§∫ÁöÑ‰ø°ÊÅØÊòØ‰øÆÊîπ‰ª•ÂêéÁöÑ‰ø°ÊÅØÔºåÊâÄ‰ª•Êü•ËØ¢ÁöÑÊó∂ÂÄôÂèØ‰ª•ÂæóÂà∞Ê≠£Á°ÆÁöÑÁªìÊûú„ÄÇÊúâÁöÑÊ†áËÆ∞‰πãÈó¥‰ºöÁõ∏‰∫íÂΩ±ÂìçÔºåÊâÄ‰ª•ÊØîËæÉÁÆÄÂçïÁöÑÂÅöÊ≥ïÊòØÔºåÊØèÈÄíÂΩíÂà∞‰∏Ä‰∏™Âå∫Èó¥ÔºåÈ¶ñÂÖà‰∏ãÊé®Ê†áËÆ∞ÔºàËã•Êú¨ËäÇÁÇπÊúâÊ†áËÆ∞ÔºåÂ∞±‰∏ãÊé®Ê†áËÆ∞ÔºâÔºåÁÑ∂ÂêéÂÜçÊâì‰∏äÊñ∞ÁöÑÊ†áËÆ∞ÔºåËøôÊ†∑‰ªçÁÑ∂ÊØè‰∏™Âå∫Èó¥Êìç‰ΩúÁöÑÂ§çÊùÇÂ∫¶ÊòØO(log2(n))„ÄÇÊ†áËÆ∞ÊúâÁõ∏ÂØπÊ†áËÆ∞ÂíåÁªùÂØπÊ†áËÆ∞‰πãÂàÜÔºöÁõ∏ÂØπÊ†áËÆ∞ÊòØÂ∞ÜÂå∫Èó¥ÁöÑÊâÄÊúâÊï∞+a‰πãÁ±ªÁöÑÊìç‰ΩúÔºåÊ†áËÆ∞‰πãÈó¥ÂèØ‰ª•ÂÖ±Â≠òÔºåË∑üÊâìÊ†áËÆ∞ÁöÑÈ°∫Â∫èÊó†ÂÖ≥ÔºàË∑üÈ°∫Â∫èÊó†ÂÖ≥ÊâçÊòØÈáçÁÇπÔºâ„ÄÇÊâÄ‰ª•ÔºåÂèØ‰ª•Âú®Âå∫Èó¥‰øÆÊîπÁöÑÊó∂ÂÄô‰∏ç‰∏ãÊé®Ê†áËÆ∞ÔºåÁïôÂà∞Êü•ËØ¢ÁöÑÊó∂ÂÄôÂÜç‰∏ãÊé®„ÄÇÊ≥®ÊÑèÔºöÂ¶ÇÊûúÂå∫Èó¥‰øÆÊîπÊó∂‰∏ç‰∏ãÊé®Ê†áËÆ∞ÔºåÈÇ£‰πàPushUpÂáΩÊï∞‰∏≠ÔºåÂøÖÈ°ªËÄÉËôëÊú¨ËäÇÁÇπÁöÑÊ†áËÆ∞„ÄÇËÄåÂ¶ÇÊûúÊâÄÊúâÊìç‰ΩúÈÉΩ‰∏ãÊé®Ê†áËÆ∞ÔºåÈÇ£‰πàPushUpÂáΩÊï∞ÂèØ‰ª•‰∏çËÄÉËôëÊú¨ËäÇÁÇπÁöÑÊ†áËÆ∞ÔºåÂõ†‰∏∫Êú¨ËäÇÁÇπÁöÑÊ†áËÆ∞‰∏ÄÂÆöÂ∑≤ÁªèË¢´‰∏ãÊé®‰∫ÜÔºà‰πüÂ∞±ÊòØÂØπÊú¨ËäÇÁÇπÊó†Êïà‰∫ÜÔºâÁªùÂØπÊ†áËÆ∞ÊòØÂ∞ÜÂå∫Èó¥ÁöÑÊâÄÊúâÊï∞ÂèòÊàêa‰πãÁ±ªÁöÑÊìç‰ΩúÔºåÊâìÊ†áËÆ∞ÁöÑÈ°∫Â∫èÁõ¥Êé•ÂΩ±ÂìçÁªìÊûúÔºåÊâÄ‰ª•ËøôÁßçÊ†áËÆ∞Âú®Âå∫Èó¥‰øÆÊîπÁöÑÊó∂ÂÄôÂøÖÈ°ª‰∏ãÊé®ÊóßÊ†áËÆ∞Ôºå‰∏çÁÑ∂‰ºöÂá∫Èîô„ÄÇÊ≥®ÊÑèÔºåÊúâÂ§ö‰∏™Ê†áËÆ∞ÁöÑÊó∂ÂÄôÔºåÊ†áËÆ∞‰∏ãÊé®ÁöÑÈ°∫Â∫è‰πüÂæàÈáçË¶ÅÔºåÈîôËØØÁöÑ‰∏ãÊé®È°∫Â∫èÂèØËÉΩ‰ºöÂØºËá¥ÈîôËØØ„ÄÇ ÂÖ∑‰ΩìÂÆûÁé∞Âú®Á∫øÊÆµÊ†ë‰∏≠ Êàë‰ª¨ÂèØ‰ª•ÈááÁî®Êï∞ÁªÑÊûÑÈÄ†ÂÆåÂÖ®‰∫åÂèâÊ†ëÁöÑÊñπÂºèÔºå‰ΩøÂæóÂ¶ÇÊûúÊ†πËäÇÁÇπ‰∏∫rtÔºåÂ∑¶ÂÑøÂ≠êÂ∞±‰∏∫2 rt,Âè≥ÂÑøÂ≠êÂ∞±‰∏∫2 rt+1. ‰ΩÜÊòØÂèØ‰ª•Ë£Ö‰∏™biËøô‰πàÂÜô12#define lc rt&lt;&lt;1 #define rc rt&lt;&lt;1|1 ÂçïÁÇπ‰øÆÊîπ‰∏ãÈù¢‰ª•codevs1080ÁöÑÂçïÁÇπ‰øÆÊîπÊ±ÇÂå∫Èó¥ÂíåÁöÑ‰æãÂ≠êÊºîÁ§∫ÂÖ∑‰ΩìÂÜôÊ≥ï‰º†ÈÄÅÈó®:Codevs-10801234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+7;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1int n,m,a[maxn];struct SegmentTree&#123; int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2]; void Pushup(int rt)&#123;sum[rt] = sum[lc]+sum[rc];&#125; void Pushdown(int rt,int ln,int rn) &#123; if(lazy[rt]) &#123; lazy[lc]+=lazy[rt]; lazy[rc]+=lazy[rt]; sum[lc]+=lazy[rt]*ln; sum[rc]+=lazy[rt]*rn; lazy[rt] = 0; &#125; &#125; void build(int l,int r,int rt) &#123; if (l == r) &#123; sum[rt] = a[l]; return ; &#125; int mid = (l+r) &gt;&gt; 1; build(l,mid,lc); build(mid+1,r,rc); Pushup(rt); &#125; void update(int q,int v,int l,int r,int rt)//A[q] += v; &#123; if (l == r) &#123; sum[rt] += v; return ; &#125; int mid = (l+r) &gt;&gt; 1; if (q &lt;= mid) update(q,v,l,mid,lc); else update(q,v,mid+1,r,rc); Pushup(rt); &#125; int query(int L,int R,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int mid = (l+r) &gt;&gt; 1; Pushdown(rt,mid-l+1,r-mid); int ans = 0; if (L &lt;= mid) ans += query(L,R,l,mid,lc); if (R &gt; mid) ans += query(L,R,mid+1,r,rc); return ans; &#125;&#125;Tree;int main(int argc, char *argv[])&#123; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d",&amp;a[i]); Tree.build(1,n,1); scanf("%d",&amp;m); while(m--) &#123; int opt,x,y; scanf("%d%d%d",&amp;opt,&amp;x,&amp;y); if (opt == 1) Tree.update(x,y,1,n,1); else printf("%d\n",Tree.query(x,y,1,n,1)); &#125; return 0;&#125; ‰∏ÄÈÅçÂ∞±Ëøá‰∫ÜÁúüÊòØÁ•ûÂ•á Âå∫Èó¥‰øÆÊîπÂ§ßËá¥Ê†ºÂºèÂ∑Æ‰∏çÂ§öÈïøËøô‰∏™Ê†∑Â≠ê 123456789101112131415161718192021222324252627282930313233343536void Change(int p, int l, int r, int L, int R)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; ‰øÆÊîπÁÇπpÁöÑÁä∂ÊÄÅËá≥ÂÆÉÂ∫îËØ•Êàê‰∏∫ÁöÑÁä∂ÊÄÅ p‰∏äÈôÑÂä†‰∏ä‰∏Ä‰∏™ËÉΩÂ§üÂΩ±ÂìçÂÆÉÊï¥‰∏™Â≠êÊ†ëÁöÑtag return; &#125; if (p‰∏äÈù¢Êúâtag) &#123; Â∞ÜpÁöÑ‰∏§‰∏™ÂÑøÂ≠êË∞ÉÊï¥Ëá≥ÂÆÉ‰ª¨Â∫îËØ•Êàê‰∏∫ÁöÑÁä∂ÊÄÅ Ê∏ÖÈô§p‰∏äÁöÑtag &#125; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) Change(pÁöÑÂ∑¶ÂÑøÂ≠ê, l, m, L, R); if (R &gt; m) Change(pÁöÑÂè≥ÂÑøÂ≠ê, m + 1, r, L, R); pÁöÑÁä∂ÊÄÅ = ÂÆÉÂ∑¶Âè≥‰∏§‰∏™ÂÑøÂ≠êÁöÑÂêàÂπ∂&#125;node Query(int p, int l, int r, int L, int R)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return pÁöÑÁä∂ÊÄÅ if (p‰∏äÈù¢Êúâtag) &#123; Â∞ÜpÁöÑ‰∏§‰∏™ÂÑøÂ≠êË∞ÉÊï¥Ëá≥ÂÆÉ‰ª¨Â∫îËØ•Êàê‰∏∫ÁöÑÁä∂ÊÄÅ Ê∏ÖÈô§p‰∏äÁöÑtag &#125; int m = (l + r) &gt;&gt; 1; if (R &lt;= m) return Query(pÁöÑÂ∑¶ÂÑøÂ≠ê, l, m, L, R); if (L &gt; m) return Query(pÁöÑÂè≥ÂÑøÂ≠ê, m + 1, r, L, R); return Query(pÁöÑÂ∑¶ÂÑøÂ≠ê, l, m, L, R) Âíå Query(pÁöÑÂè≥ÂÑøÂ≠ê, m + 1, r, L, R) ÁöÑÁªìÊûúÁöÑÂêàÂπ∂&#125; Ëøô‰∏™Áé©ÊÑèÊí∏‰∫ÜÂ•Ω‰πÖÂïä„ÄÇËìù‰π¶ÈóÆÈ¢ò3.2.4(2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;#define lc rt&lt;&lt;1#define rc rt&lt;&lt;1|1const int maxn = 1e5+10;int n,m,a[maxn];int _sum,_min = INT_MAX,_max = -INT_MAX;struct SegmentTree&#123; int minv[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2],sum[maxn&lt;&lt;2]; void Pushup(int rt) &#123; sum[rt] = sum[lc]+sum[rc]; minv[rt] = min(minv[lc],minv[rc]); maxv[rt] = max(maxv[lc],maxv[rc]); &#125; void Pushdown(int rt) &#123; if (lazy[rt]) &#123; lazy[lc] += lazy[rt]; lazy[rc] += lazy[rt]; lazy[rt] = 0; &#125; &#125; void Maintain(int rt,int l,int r) &#123; sum[rt] = maxv[rt] = minv[rt] = 0; if (r &gt; l) &#123; sum[rt] = sum[lc] + sum[rc]; minv[rt] = min(minv[lc],minv[rc]); maxv[rt] = max(maxv[lc],maxv[rc]); &#125; minv[rt] += lazy[rt]; maxv[rt] += lazy[rt]; sum[rt] += lazy[rt] * (r-l+1); &#125; void build(int l,int r,int rt) &#123; if(l == r) &#123; minv[rt] = a[l]; maxv[rt] = a[l]; sum[rt] = a[l]; return ; &#125; int mid = (l+r) &gt;&gt; 1; build(l,mid,lc); build(mid+1,r,rc); Pushup(rt); &#125; void update(int l,int r,int v,int L,int R,int rt) &#123; if (l &lt;= L &amp;&amp; r &gt;= R) lazy[rt] += v; else &#123; Pushdown(rt); //?? int mid = (L+R) &gt;&gt; 1; if (l &lt;= mid) update(l,r,v,L,mid,lc); else Maintain(lc,L,mid); if (r &gt; mid) update(l,r,v,mid+1,R,rc); else Maintain(rc,mid+1,R); &#125; Maintain(rt,L,R); &#125; void query(int rt,int l,int r,int L,int R,int ret) &#123; _sum = 0; _min = INT_MAX; _max = -INT_MAX; printf("%d %d %d %d %d %d\n",rt,l,r,L,R,ret); if(l &lt;= L &amp;&amp; r &gt;= R) &#123; _sum += sum[rt] + ret * (R-L+1); _min = min(_min,minv[rt]+ret); _max = max(_max,maxv[rt]+ret); &#125; else &#123; int mid = (L+R) &gt;&gt; 1; if (l &lt;= mid) query(lc,l,r,L,mid,ret + lazy[rt]); if (r &gt; mid) query(rc,l,r,mid+1,R,ret + lazy[rt]); &#125; &#125;&#125;Tree;int main(int argc, char *argv[])&#123; scanf("%d %d",&amp;n,&amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d",&amp;a[i]); Tree.build(1,n,1); while(m--) &#123; int x,a,b,c; scanf("%d",&amp;x); if (x == 1) &#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); Tree.update(a,b,c,1,n,1); &#125; else &#123; scanf("%d %d",&amp;a,&amp;b); Tree.query(1,a,b,1,n,0); printf("Minv: %d Maxv: %d Sumv: %d\n",_min,_max,_sum); &#125; &#125; return 0;&#125; ËøòÊúâ‰∏Ä‰∏™ÂÜôÊ≥ïÁ®çÂæÆ‰∏ç‰∏ÄÊ†∑ÁöÑÊùøÂ≠ê‰ΩÜÊòØÂíåËìù‰π¶‰∏äÈù¢ÁöÑ‰∏§‰∏™ÈóÆÈ¢òÊòØÂåπÈÖçÁöÑÊåÇ‰∏äÊù•ÂíØ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000+ 10;//update_add:ÊääA[L]~A[R]ÁöÑÂÄºÂÖ®ÈÉ®Âä†v_add//update_set:ÊääA[l]~A[R]ÁöÑÂÄºËÆæ‰∏∫v_set//query:ËÆ°ÁÆóÂ≠êÂ∫èÂàóÁöÑÂÖÉÁ¥†ÂíåÔºåÊúÄÂ∞èÂÄºÔºåÊúÄÂ§ßÂÄºint sumv[2*maxn],minv[2*maxn],maxv[2*maxn];int addv[2*maxn], setv[2*maxn];int y11, y2, v_add, v_set;void maintain(int o, int L, int R) &#123; int lc = 2*o, rc = 2*o + 1; sumv[o] = minv[o] = maxv[o] = 0; if(setv[o] &gt;= 0) &#123; sumv[o] = setv[o] * (R-L+1); minv[o] = maxv[o] = setv[o]; &#125; else if(R &gt; L) &#123; sumv[o] = sumv[lc] + sumv[rc]; minv[o] = min(minv[lc], minv[rc]); maxv[o] = max(maxv[lc], maxv[rc]); &#125; minv[o] += addv[o]; maxv[o] += addv[o]; sumv[o] += addv[o] * (R-L+1);&#125;void pushdown(int o) &#123; int lc = 2*o, rc = 2*o+1; if(setv[o] &gt;= 0) &#123; setv[lc] = setv[rc] = setv[o]; addv[lc] = addv[rc] = 0; setv[o] = -1; &#125; if(addv[o] &gt; 0) &#123; addv[lc] += addv[o]; addv[rc] += addv[o]; addv[o] = 0; &#125;&#125;void update_add(int o, int L, int R) &#123; int lc = 2*o, rc = o*2+1; if(y11 &lt;= L &amp;&amp; y2 &gt;= R) &#123; addv[o] += v_add; &#125; else &#123; pushdown(o); int M = L + (R-L)/2; if(y11 &lt;= M) update_add(lc, L, M); else maintain(lc, L, M); if(y2 &gt; M) update_add(rc, M+1, R);else maintain(rc, M+1, R); &#125; maintain(o, L, R);&#125;void update_set(int o, int L, int R) &#123; int lc = 2*o, rc = o*2+1; if(y11 &lt;= L &amp;&amp; y2 &gt;= R) &#123; setv[o] = v_set; addv[o] = 0; &#125; else &#123; pushdown(o); int M = L + (R-L)/2; if(y11 &lt;= M) update_set(lc, L, M); else maintain(lc, L, M); if(y2 &gt; M) update_set(rc, M+1, R); else maintain(rc, M+1, R); &#125; maintain(o, L, R);&#125;int _min, _max, _sum;void query(int o, int L, int R, int add) &#123; if(setv[o] &gt;= 0) &#123; _sum += (add+setv[o]+addv[o]) * (min(R, y2)-max(L, y11)+1); _min = min(_min, setv[o]+addv[o]+add); _max = max(_max, setv[o]+addv[o]+add); &#125; else if(y11 &lt;= L &amp;&amp; y2 &gt;= R) &#123; _sum += sumv[o] + add * (R-L+1); _min = min(_min, minv[o]+add); _max = max(_max, maxv[o]+add); &#125; else &#123; int M = L + (R-L)/2; if(y11 &lt;= M) query(o*2, L, M, add+addv[o]); if(y2 &gt; M) query(o*2+1, M+1, R, add + addv[o]); &#125;&#125;void init() &#123; memset(setv, -1, sizeof setv); memset(addv, 0, sizeof addv); memset(sumv, 0, sizeof sumv); memset(minv, 0, sizeof minv); memset(maxv, 0, sizeof maxv);&#125;int main(int argc, char *argv[])&#123; int n,m; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d",&amp;v_add); y11 = y2 = i; update_add(1,1,n); &#125; scanf("%d",&amp;m); while(m--) &#123; int x,a,b,c; scanf("%d",&amp;x); if (x == 1) &#123; scanf("%d %d %d",&amp;y11,&amp;y2,&amp;c); v_add = c; update_add(1,1,n); &#125; else &#123; _sum = 0; scanf("%d",&amp;y11); y2 = y11; query(1,1,n,0); printf("%d\n",_sum); &#125; &#125; return 0;&#125; Âàí‰∏Ä‰∏ã‰π†È¢ò. Ê†ëÁä∂Êï∞ÁªÑ: LA-2191LA-5902 Á∫øÊÆµÊ†ë+ÂÖ∂‰ªñÊäÄÂ∑ßUVA-12299UVA-11525LA-4730LA-4108LA-4013]]></content>
      <categories>
        <category>Á∫øÊÆµÊ†ë</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Êï∞Â≠¶‰∏ìÈ¢ò‰π†È¢ò2]]></title>
    <url>%2F2018%2F02%2F16%2F%E6%95%B0%E5%AD%A6%E4%B8%93%E9%A2%98%E4%B9%A0%E9%A2%982%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆ‰º†ÈÄÅÈó®UVa-11728UVa-10673UVa-11768UVa-10692 Code1234567891011121314151617181920212223242526272829303132333435//UVA-11728#include&lt;bits/stdc++.h&gt;using namespace std;int kase = 0,S;bool check(int n,int m)&#123; int q = sqrt(n+0.5); int ret = 0; for (int i = 1; i &lt;= q; i++) if (n % i == 0) ret += i+n/i; if (q*q == n) ret -= q; return (ret == m);&#125;int main(int argc, char *argv[])&#123; while(scanf("%d",&amp;S) == 1 &amp;&amp; S) &#123; bool flag = 0; if (S == 1) &#123; printf("Case %d: 1\n",++kase); continue; &#125; for (int i = S-1; i &gt;= 1; i--) if (check(i,S)) &#123; flag = 1; printf("Case %d: %d\n",++kase,i); break; &#125; if(!flag) printf("Case %d: %d\n",++kase,-1); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445// UVA-10673#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline void getLL(LL &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-') f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;void ex_gcd(LL a,LL b,LL &amp;X,LL &amp;Y,LL &amp;d)&#123; if (!b)&#123;d=a;X=1;Y=0;&#125; else &#123; ex_gcd(b,a%b,Y,X,d); Y-=(a/b)*X; &#125;&#125;LL T,x,k,a,b,X,Y,d;int main(int argc, char *argv[])&#123; getLL(T); while(T--) &#123; getLL(x);getLL(k); a = floor(double(x)/double(k)); b = ceil(double(x)/double(k)); d = a == b ? a : 1; if (a == b) X = 0,Y = k; else &#123; ex_gcd(a,b,X,Y,d); X *= x, Y *= x; &#125; printf("%lld %lld\n",X,Y); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445//UVA-11768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;void exgcd(ll a,ll b,ll&amp; g,ll&amp; x,ll&amp; y)&#123; if(!b) g=a,x=1,y=0; else exgcd(b,a%b,g,y,x),y-=x*(a/b);&#125;double X1,Y1,X2,Y2;ll solve()&#123; ll x1=(X1+0.05)*10,y1=(Y1+0.05)*10,x2=(X2+0.05)*10,y2=(Y2+0.05)*10; if(x1==x2) &#123; if(x1%10) return 0; if(Y2&lt;Y1) swap(Y1,Y2); return floor(Y2)-ceil(Y1)+1; &#125; if(y1==y2) &#123; if(y1%10) return 0; if(X2&lt;X1) swap(X1,X2); return floor(X2)-ceil(X1)+1; &#125; ll a=(y2-y1)*10,b=(x1-x2)*10,c=y2*x1-y1*x2,g,x,y; exgcd(a,b,g,x,y); if(c%g) return 0; x*=c/g;b=abs(b/g); if(X1&gt;X2) swap(X1,X2); x1=ceil(X1);x2=floor(X2);x-=(x-x1)/b*b; if(x&lt;x1) x+=b; if(x2&lt;x) return 0; return (x2-x)/b+1;&#125;int main(int argc, char *argv[])&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%lf%lf%lf%lf",&amp;X1,&amp;Y1,&amp;X2,&amp;Y2); printf("%lld\n",solve()); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//UVA-10692#include&lt;bits/stdc++.h&gt;const int maxn = 15;int A[maxn], k;int pow_mod(int a, int n, int M) &#123; int ans = 1; while (n) &#123; if (n&amp;1) ans = ans * a % M; a = a * a % M; n /= 2; &#125; return ans;&#125;int euler_phi(int n)&#123; int m = (int)sqrt(n+0.5); int ans = n; for (int i = 2; i &lt;= m; i++) &#123; if (n % i == 0) &#123; ans = ans / i * (i-1); while (n%i==0) n /= i; &#125; &#125; if (n &gt; 1) ans = ans / n * (n - 1); return ans;&#125;int solve (int d, int M) &#123; if (d == k - 1) return A[d]%M; int phi = euler_phi(M); int c = solve (d+1, phi) + phi; return pow_mod(A[d], c, M);&#125;int main (int argc, char *argv[]) &#123; int cas = 1; char str[maxn]; while (scanf("%s", str) == 1 &amp;&amp; strcmp(str, "#")) &#123; int M; sscanf(str, "%d", &amp;M); scanf("%d", &amp;k); for (int i = 0; i &lt; k; i++) scanf("%d", &amp;A[i]); printf("Case #%d: %d\n", cas++, solve(0, M)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Êï∞Â≠¶‰∏ìÈ¢ò‰π†È¢ò]]></title>
    <url>%2F2018%2F02%2F15%2F%E6%95%B0%E5%AD%A6%E4%B8%93%E9%A2%98%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆ‰º†ÈÄÅÈó®UVa-10237UVa-10883UVa-10943UVa-11038UVa-11076UVa-11388UVa-11889 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546//UVA-10237#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 40;int n, k;ll b[N][N*N],w[N][N*N];void init() &#123; memset(b, 0, sizeof(b)); memset(w, 0, sizeof(w)); b[0][0] = w[1][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; b[i][0] = b[i-1][0]; int l = (i+1)/2 * 2 - 1; for (int j = 1; j &lt;= l &amp;&amp; j &lt;= k; j++) b[i][j] = b[i-1][j] + (ll)(l-j+1) * b[i-1][j-1]; &#125; for (int i = 2; i &lt;= n; i++) &#123; w[i][0] = w[i-1][0]; int l = i/2 * 2; for (int j = 1; j &lt;= l &amp;&amp; j &lt;= k; j++) w[i][j] = w[i-1][j] + (ll)(l-j+1) * w[i-1][j-1]; &#125;&#125;int main (int argc, char *argv[]) &#123; while (scanf("%d%d", &amp;n, &amp;k) == 2 &amp;&amp; n + k) &#123; init(); ll ans = 0; for (int i = 0; i &lt;= k; i++) ans = ans + b[n][i] * w[n][k-i]; printf("%lld\n", ans); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829//UVA-10883#include&lt;bits/stdc++.h&gt;using namespace std;int T,n,kase = 0;double ln[50010],a;void init(void)&#123; ln[0] = ln[1] = 0; for (int i = 2; i &lt;= 50009; i++) ln[i] = ln[i-1]+log(i);&#125;int main(int argc, char *argv[])&#123; init(); cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; n; n--; double summ = 0.0; for (int i = 0; i &lt;= n; i++) &#123; cin &gt;&gt; a; summ += a * exp(ln[n]-ln[n-i]-ln[i]-n*ln[2]); &#125; printf("Case #%d: %.3lf\n",++kase,summ); &#125; return 0;&#125; 12345678910111213141516171819202122//UVA-10943#include&lt;bits/stdc++.h&gt;using namespace std;int N,K;int C[210][210];const int module = 1e6;void in_table(void)&#123; for (int i = 0; i &lt;= 208; i++) for (int j = 0; j &lt;= i; j++) &#123; if (i == j) C[i][j] = 1; else C[i][j] = (C[i-1][j-1]+C[i-1][j])%module; &#125; &#125;int main(int argc, char *argv[])&#123; in_table(); while(scanf("%d %d",&amp;N,&amp;K) == 2 &amp;&amp; N &amp;&amp; K) &#123;printf("%d\n",C[N+K-1][K-1]);&#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132//UVA-11038#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint m,n;int f[13],g[13]; //10^i~10^(i+1)-1int calc(int x)&#123; int ans=1,cnt=1,tmp=0; if (x &lt; 0) return 0; while(x) &#123; int c = x%10; x/=10; if (c) ans+=x*cnt; else ans+=(x-1)*cnt+tmp+1; tmp+=c*cnt; cnt*=10; &#125; return ans;&#125;signed main(signed argc, char *argv[])&#123; f[0] = g[0] = 1; for (int i = 1; i &lt;= 11; i++) f[i] = (9*(i-1))*i+i; for (int i = 1; i &lt;= 11; i++) g[i] = g[i-1]+f[i]; while(scanf("%lld%lld",&amp;n,&amp;m) == 2 &amp;&amp; n &gt;= 0 &amp;&amp; m &gt;= 0) printf("%lld\n",calc(m)-calc(n-1)); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637//UVA-11076#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[13],c[11],d[11];unsigned long long ans,t = 1;unsigned long long op(int x)&#123; unsigned long long ret = 1; int y=x; while(y) ret*=y,y--; return ret;&#125;unsigned long long op1(int x)&#123; unsigned long long ret = 0; while(x) &#123; x--; ret+=pow(10,x); &#125; return ret;&#125;int main(int argc, char *argv[])&#123; while(scanf("%d",&amp;n) == 1 &amp;&amp; n) &#123; memset(c,0,sizeof(c)); for (int i = 1; i &lt;= n; i++) scanf("%d",&amp;a[i]),c[a[i]]++; unsigned long long f = op(n),mul = op1(n); for (int i = 0; i &lt;= 9; i++) f/=(op(c[i])); for (int i = 0; i &lt;= 9; i++) d[i] = f*c[i]/n; ans = 0; for (int i = 0; i &lt;= 9; i++) ans += d[i]*i*mul; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//UVA-11388#include&lt;bits/stdc++.h&gt;using namespace std;int T;#define LL long longlong long gcd(long long x,long long y)&#123; return (y == 0) ? x : gcd(y,x%y);&#125;int main(int argc, char *argv[])&#123; ios::sync_with_stdio(false); long long T,G,L; cin &gt;&gt; T; while(T--) &#123; int flag = 0; cin &gt;&gt; G &gt;&gt; L; if (L % G != 0) &#123; cout &lt;&lt; "-1" &lt;&lt; endl; continue; &#125; else &#123; cout &lt;&lt; G &lt;&lt; " " &lt;&lt; L &lt;&lt; "\n"; continue; &#125; /* long long x = G*L; for (long long i = G; i &lt;= min((LL)sqrt(x),L); i++) &#123; if (x % i == 0) &#123; if (gcd(i,x/i) == G) &#123; printf("%lld %lld\n",i,x/i); flag = 1; break; &#125; &#125; &#125; if (!flag) printf("-1\n");*/ &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132//UVA-11889#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longlong long gcd(long long x,long long y)&#123; return (y == 0) ? x : gcd(y,x%y);&#125;signed main(signed argc, char *argv[])&#123; int A,C,T; ios::sync_with_stdio(false); cin &gt;&gt; T; while(T--) &#123; int flag = 1; cin &gt;&gt; A &gt;&gt; C; for (int i = 1; i &lt;= A; i++) if (i*C % A == 0) &#123; int B = i * C/A; if (gcd(A,B) == i) &#123; printf("%d\n",B); flag = 0; break; &#125; &#125; if (flag) puts("NO SOLUTION"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-3485] Bridge Âü∫‰∫éÂÆöÁßØÂàÜÁöÑ‰∫åÂàÜ]]></title>
    <url>%2F2018%2F02%2F13%2FLA-3485-Bridge-%E5%9F%BA%E4%BA%8E%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®:LA-3485È¢òÁõÆÂ§ßÊÑè:ÁªôÂÆö‰∏Ä‰∏™ÊäõÁâ©Á∫øÁöÑÂ∑¶Âè≥ÈïøÂ∫¶ÂíåÊõ≤Á∫øÈïøÔºåÊ±ÇÊäõÁâ©Á∫øÁöÑÂ∫ïÂà∞È°∂ÈÉ®ÁöÑË∑ùÁ¶ª„ÄÇ Ê†∑‰æãSample Input220 101 400 40421 2 3 4Sample OutputCase 1:1.00 Case 2:1.60 ÊÄùË∑ØÁî±‰∏ä‰∏ÄÁØáÁöÑÂ≠¶‰π†Á¨îËÆ∞‰∏≠ÔºåÊàë‰ª¨Â∑≤ÁªèËØ¥ÊòéËøáÂØπ‰∫é‰∏Ä‰∏™Êõ≤Á∫øÂáΩÊï∞f(x)ÔºåÂ¶ÇÊûúÂÆÉÁöÑÂØºÂáΩÊï∞‰∏∫f‚Äô(x),ÈÇ£‰πàÂú®a,bËøô‰∏ÄÊÆµ‰∏äÁöÑÊõ≤Á∫øÈïøÂ∫¶‰∏∫ \int_a^b\sqrt{1+[f'(x)]^2}dx ‰∏∫‰ªÄ‰πàÊòØËøô‰∏™Ê†∑Â≠êÂë¢ÔºüÊàë‰ª¨ÂèØ‰ª•Êääf‚Äò(x)Â±ïÂºÄÂÜôÊàê\\\\\Delta y/\Delta x\\\\ ÈÇ£‰πàÂú®ÂØπ‰∫é\Delta x Ë∂ãËøë‰∫é0ÁöÑÊó∂ÂÄô,(\Delta x)^2+(\Delta y)^2Â∞±Áõ∏ÂΩì‰∫é‰∏Ä‰∏™Áõ¥Ëßí‰∏âËßíÂΩ¢ÊñúËæπÁöÑÂπ≥Êñπ.\\\\ ÂºÄÊ†πÂè∑,Â∞±ÊòØ\sqrt{\frac{(\Delta y)^2}{(\Delta x)^2}+1}\\\\ ‰πüÂ∞±ÊòØ\sqrt{[f'(x)]^2+1}ËøôÈáå‰∏çÂÖçË¶ÅËøêÁî®Ëøô‰∏™ÂéªËÆ°ÁÆóÂå∫Èó¥ÂÜÖÁöÑÊõ≤Á∫øÈïøÂ∫¶„ÄÇ ËØªÈ¢òÔºåÊàë‰ª¨ÂèØ‰ª•ÂèëÁé∞Èó¥ÈöîÊÄªÊï∞‰∏∫ceil(B/D).ÊØè‰∏™Èó¥ÈöîÂÆΩÂ∫¶‰∏∫(B/n).ÊØè‰∏™Èó¥ÈöîÁöÑÁª≥Á¥¢ÈïøÂ∫¶‰∏∫(L/n) Êàë‰ª¨ÂèØ‰ª•ÊûÑÈÄ†‰∏Ä‰∏™‰∫åÊ¨°ÂáΩÊï∞,ÂÆÉËøá0,0‰∏îÂºÄÂè£Âêë‰∏ä„ÄÇ ÂÅáËÆæw‰∏∫ÂÆΩ,h‰∏∫È´ò ÈÇ£‰πàÊúâa(w/2)^2 = h. ÊâÄ‰ª•a = 4h/(w^2). ‰∏ãÈù¢Â∞±ÊòØ‰∏áÊÅ∂ÁöÑÁßØÂàÜËøêÁÆó‰∫ÜÔºÅ ËøôÈáåÁßØÂàÜÊàëÁÆó‰∫Ü‰∏§Ê¨°ÔºåÁ¨¨‰∏ÄÊ¨°ÊòØËá™Â∑±Ê≤°Áî®aÊù•ÂéªÊõøÊç¢wÂíåhÁÆóÁöÑ,ÁÆóÊòØÁ°¨Â§¥ÁöÆÁÆóÁöÑÔºåÁ¨¨‰∫åÊ¨°Â∞±ÂèÇËÄÉËìù‰π¶‰∫Ü„ÄÇ Á¨¨‰∏ÄÊ¨°ÁöÑËÆ°ÁÆóÊñπÊ≥ï: ÁªèËøá‰∏ÄÁï™ËØïÈ™å„ÄÇ 123456789double w,h = 1.0; cin &gt;&gt; w; while(1) &#123; double ans = w*w/8/h*(log(abs(sqrt(16*h*h/w/w)+4*h/w)) + 4*h/w*sqrt(16*h*h/w/w+1))/2; h += 1.0; cout &lt;&lt; ans &lt;&lt; endl; system("pause"); &#125; ÂèëÁé∞ÈöèÁùÄhÁöÑÂ¢ûÂä†Ëøô‰∏™ÁßØÂàÜÁöÑÂÄº‰πüÂú®Â¢ûÂä†,ËøôÊòØ‰∏™‰∏•Ê†ºÈÄíÂ¢ûÁßØÂàÜ„ÄÇÂ∞±ÂèØ‰ª•Áî®‰∫åÂàÜÊ±ÇËß£‰∫ÜÔºÅÂÜôÂá∫ËøôÊ†∑ÁöÑ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-8;double D,H,B,L;int T;double F(double w,double h)&#123; double ans = w*w/8/h*(log(fabs(sqrt(16*h*h/w/w)+4*h/w)) + 4*h/w*sqrt(16*h*h/w/w+1))/2; ans *= 2; return ans;&#125;double calc(double L,double w)&#123; double ll = 0.0,rr = H; //while(rr-ll &gt; eps) for (int i=0;i&lt;100;i++) &#123; double mid = (ll+rr)/2; if (F(w,mid) - L &gt; eps) rr = mid; else ll = mid; &#125; return (H-ll);&#125;int main(int argc, char *argv[])&#123; scanf("%d",&amp;T); for (int kase = 1; kase &lt;= T; kase++) &#123; printf("Case %d:\n",kase); scanf("%lf%lf%lf%lf",&amp;D,&amp;H,&amp;B,&amp;L); int n = ceil(B/D); double singleL = L/double(n); double singlew = B/double(n); //printf("##debug n:%d L:%.5lf w %.5lf\n",n,singleL,singlew); printf("%.5lf\n",calc(singleL,singlew)); &#125; return 0;&#125; ÂÖ¥Ëá¥ÂãÉÂãÉÂú∞ÂØπÊ†∑‰æãÔºåÂèëÁé∞ÊòØÊ≠£Á°ÆÁöÑÔºÅÔºÅÔºÅ ÊøÄÂä®Âïä,Ëá™Â∑±ÈÄ†‰∫ÜÂá†‰∏™ÂáëÂ•ΩÁöÑÊï∞ÊçÆÂèëÁé∞ÈÉΩÊ≤°ÊúâÈóÆÈ¢ò„ÄÇ ÁÑ∂ÂêéÊâîÂà∞OJ‰∏äÂ∞±WA‰∫Ü,‰∏çÁÆ°ÊÄé‰πàË∞ÉÁ≤æÂ∫¶ÈÉΩÊòØWA„ÄÇ ‰∫éÊòØÂ∞±ËÄÉËôëÂà∞Ëøô‰∏™ÊñπÊ≥ïÂèØËÉΩÂ≠òÂú®ËØØÂ∑Æ„ÄÇÂè™‰∏çËøáÂæàÂ∞èÂæàÂ∞è‰ΩÜÊòØÂú®Á≤æÂ∫¶‰ª•ÂÜÖÔºå‰ºöÂΩ±ÂìçÁ≠îÊ°à„ÄÇ ‰º§ÂøÉÔºåÁúãÂà∞Ëìù‰π¶ÂÜôÁöÑ‰ª£Êç¢ÊàëÁúüÁöÑÂ§¥ÁöÆÂèëÈ∫ª ÁÆÄÂåñ‰∫ÜaÂêéÂèëÁé∞ÂÖ∂ÂÆûÁßØÂàÜ‰∏≠Áî®t‰∏édt‰ª£Êç¢xÁöÑÊ≠•È™§‰πüÁúÅÂéª‰∫Ü„ÄÇ ÂïäÂïäÂïäÂïäÂïäÂïäÂïä ÈöæÂèó ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-8;double D,H,B,LLL;int T; double f(double a,double x)&#123; double aa = a*a,xx = x*x; return (x*sqrt(aa+xx) + aa*log(fabs(x+sqrt(aa+xx))))/2;&#125;double calc(double w,double h)&#123; double a = 4*h/w/w; double b = 1/(2*a); return 4*a*(f(b,w/2)-f(b,0));&#125;int main(int argc, char *argv[])&#123; scanf("%d",&amp;T); for (int kase = 1; kase &lt;= T; kase++) &#123; if(kase &gt; 1) printf("\n"); printf("Case %d:\n",kase); scanf("%lf%lf%lf%lf",&amp;D,&amp;H,&amp;B,&amp;LLL); int n = ceil(B/D); double L = LLL/double(n); double w = B/double(n); double ll = 0.0,rr = H; while(rr-ll &gt; eps) &#123; double mid = (ll+rr)/2; if (calc(w,mid) - L &gt; eps) rr = mid; else ll = mid; &#125; printf("%.2lf\n",H-ll); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Êï∞ÂÄºÁÆóÊ≥ïÂ≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2018%2F02%2F13%2F%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ÈùûÁ∫øÊÄßÊñπÁ®ãÊ±ÇÊ†πËøô‰∏ÄÈÉ®ÂàÜÂæàÂ§ßÊÉÖÂÜµ‰∏ã‰ª•Êù•‰∏éÂáΩÊï∞Êú¨Ë∫´ÁöÑÂçïË∞ÉÊÄßÔºåÈúÄË¶ÅÊéåÊè°‰∏ÄÂÆöÁöÑÊï∞Â≠¶Âü∫Á°ÄÂØπÂáΩÊï∞Ê¶ÇÂøµË¶ÅÊúâÊ∏ÖÊô∞ÁöÑËÆ§ËØÜ„ÄÇÂèØËÉΩ‰πüË¶ÅÊúâÁÇπÊ±ÇÂØºÂíåÁßØÂàÜÁöÑÁü•ËØÜ„ÄÇËøòÂ•ΩÊàë‰ºö Êàë‰ºö‰∏™ÊØõÁ∫ø:) UVa-10341 Solve It!‰º†ÈÄÅÈó®:UVa-10341È¢òÁõÆÂ§ßÊÑè:ËØïËß£‰∏Ä‰∏™ÊñπÁ®ãÔºå‰ΩøÂæó pe^{-x}+qsin(x)+rcos(x)+stan(x)+tx^2+u =0 \space \space , x \in [0,1].\\\\ 0\leq p,r \leq 20;\\\\ -20\leq q,s,t \leq 0;ÂÖâÂá≠Ëøô‰∏™ÊñπÁ®ãÊàë‰ª¨ÊØ´Êó†ÂäûÊ≥ïÔºåÂõ†‰∏∫ÂØπÊï¥‰∏™ÂáΩÊï∞Ê±ÇÂØºÂèØ‰ª•ÂæóÂà∞. Â∫îÁî®ÂàÜÈÉ®Ê±ÇÂØºÊ≥ïÂàôÂ∞±ÂèØ‰ª•‰∫ÜÁÆóÊòØÁÆÄÂçïÁöÑÊ±ÇÂØº ÂæóÂà∞ f'(x) = -pe^{-x}+qcos(x)-rsin(x)+2stan(x)sec^2(x)+2tx \\\\ÁúºËä±Áº≠‰π±ÊØ´Êó†ÂäûÊ≥ï,Âá≠ÂÄüÂØºÂáΩÊï∞Êàë‰ª¨Áúã‰∏çÂá∫‰ªª‰ΩïÂ¢ûÂáèÊÄßÁöÑÂèòÂåñ„ÄÇ Ê≥®ÊÑèÂà∞xÁöÑËæπÁïå‰∏∫0,1„ÄÇ ÈÇ£‰πàÊúâ‰ª•‰∏ãÂáΩÊï∞Âú®ËØ•Âå∫Èó¥ÊòØÂçïÂáèÁöÑÔºà‰∏•Ê†ºÈÄíÂáèÔºâ e^{-x};cos(x);Êúâ‰ª•‰∏ãÁöÑÂáΩÊï∞Âú®ËØ•Âå∫Èó¥ÂçïÂ¢ûÔºà‰∏•Ê†ºÈÄíÂ¢ûÔºâ sin(x);tan(x);tx^2;ÂÜçÁúã‰∏ÄÁúºÈ¢òÁõÆÁúãÂà∞‰∫Üsin(x),tan(x),tx^2ÂâçÈù¢ÁöÑÁ≥ªÊï∞ÈÉΩÊòØÈùûÊ≠£ÁöÑÔºÅÈÇ£‰πàÁõ∏ÂΩì‰∫éÊï¥‰∏™ÂáΩÊï∞‰∏∫Âú®[0,1]‰∏äÁöÑÂáèÂáΩÊï∞„ÄÇ ‰∫éÊòØÊ†πÊçÆ‰ªãÂÄºÂÆöÁêÜÔºåÂú®Êüê‰∏ÄÂå∫Èó¥‰∏äÔºàËøôÈáåÊòØ[0,1]Ôºâ ÔºåËøô‰∏™ÂçïË∞ÉÈÄíÂáèÁöÑÂáΩÊï∞Ëã•Êª°Ë∂≥f(0) &gt;= 0 &gt;= f(1). ÂàôÂú®[0,1]‰∏ä‰∏ÄÂÆöÊúâ‰∏î‰ªÖÊúâ‰∏Ä‰∏™Ëß£. ‰∫éÊòØ‰∫åÂàÜÂ∞±Ë°å‰∫Ü„ÄÇ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;using namespace std;const double eps = 1e-7;double p,q,r,s,t,u;double e = pow(double(1.0+1.0/10000),10000);double calc(double x)&#123;return (p*exp(-x)+q*sin(x)+r*cos(x)+s*tan(x)+t*x*x+u);&#125;\\e^x ÂèØ‰ª•ÂÜôÊàêexp(-x)!int main(int argc, char *argv[])&#123; while(scanf("%lf%lf%lf%lf%lf%lf",&amp;p,&amp;q,&amp;r,&amp;s,&amp;t,&amp;u) == 6) &#123; double lim0 = calc(0),lim1 = calc(1); if (lim1 &gt; 1e-9 || lim0 &lt; -1e-9) &#123; puts("No solution"); continue; &#125; double l = 0.0,r = 1.0,mid; while(r-l &gt; eps) &#123; mid = (l+r)/2; if (calc(mid) &gt; 0.0) l = mid; else r = mid; &#125; printf("%.4lf\n",l); &#125; return 0;&#125; LA-5009 Error Curves‰º†ÈÄÅÈó®:LA-5009 È¢òÁõÆÂ§ßÊÑè:ÁªôÂá∫n‰∏™ÊäõÁâ©Á∫øÔºàÂºÄÂè£Âêë‰∏äÔºâÊàñËÄÖÁõ¥Á∫øÔºåÂÆö‰πâ‰∏Ä‰∏™ÊÄªÂáΩÊï∞f(x) = max{Si(x)}. Ê±ÇËøô‰∏™ÊÄªÂáΩÊï∞Âú®[0,1000]‰∏äÁöÑÊúÄÂ∞èÂÄº„ÄÇ ÈîôËØØÊÄùË∑Ø:ÊääÊØè‰∏™ÂáΩÊï∞Âú®[0,1000]‰∏äÁöÑÊúÄÂ∞èÂÄºÊ±ÇÂá∫Êù•ÊúÄÂêé‰∏ÄÈÅçÂèñÊúÄÂ∞è„ÄÇËøôÊ†∑ËôΩËØ¥Áúã‰∏äÂéªÊØ´Êó†ÈóÆÈ¢òÔºå‰ΩÜÊòØËøô‰∏™ÊÄùË∑ØÂØπ‰∫éÂÆö‰πâÂ∞±ÊòØ‰∏çÊ≠£Á°ÆÁöÑf(x)ÁöÑÂÆö‰πâÊòØmax(si(x))ËÄå‰∏çÊòØmin,‰πüÂ∞±ÊòØËØ¥,Êàë‰ª¨Âú®Â§ÑÁêÜÂáΩÊï∞Êó∂‰∏çËÉΩ‰ª•ÂÅèÊ¶ÇÂÖ®,ÂøÖÈ°ªÂú®Êüê‰∏ÄÂå∫Èó¥‰∏äÁ°¨ÊÄßËßÑÂÆöË¶ÅÂèñÁöÑÊòØÂáΩÊï∞ÁöÑÊúÄÂ§ßÂÄº,Êç¢Ë®Ä‰πã,Êàë‰ª¨ÁöÑÁ≠îÊ°à‰∏çËÉΩ‰øùËØÅÂèñÂà∞Ëøô‰∏™Á≠îÊ°àÊó∂f(x)ËÉΩÂèñÂà∞Ëøô‰∏™ÊúÄÂ∞èÂÄº„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//wrong answer.#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+10;const double eps = 1e-7;int T,n;struct Node&#123; int a,b,c; double ans;&#125;f[maxn]; void calc(Node q)&#123; int x = q.a,y = q.b,z = q.c; if (x == 0) &#123; if (y &lt;= 0) &#123; q.ans = (double)(z); return ; &#125; else &#123; q.ans = (double)(1000*y+z); return ; &#125; &#125; else &#123; double u = (-y)/(2*x); if (u &gt; eps &amp;&amp; 1000 - u &gt; eps) &#123; q.ans = u*u*double(x)+u*double(y)+u*double(z); return ; &#125; if (u &lt; -eps) &#123; q.ans = double(z); return ; &#125; if (u - 1000 &gt; eps) &#123; q.ans = 1000*1000*double(x)+double(y)*1000+double(z); return ; &#125; &#125;&#125;int main(int argc ,char *argv[])&#123; scanf("%d",&amp;T); while(T--) &#123; double ass = 1e8; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d",&amp;f[i].a,&amp;f[i].b,&amp;f[i].c), calc(f[i]), ass = min(ass,f[i].ans), printf("%.4lf\n",ass); &#125; return 0;&#125; Ê≠£Ëß£:ÂèØ‰ª•ËØÅÊòéÔºåÂØπ‰∫é‰∏§Êù°ÊäõÁâ©Á∫øÊàñËÄÖÁõ¥Á∫øÔºåË¶Å‰πàÊòØÂçïÂ¢ûÂçïÂáèÔºåË¶Å‰πàÊòØÂºÄÂè£Âêë‰∏äÁöÑÂáπÂΩ¢ÂõæÂÉè„ÄÇÂÜçÁî®‰∏ÄÊ¨°Êï∞Â≠¶ÂΩíÁ∫≥Ê≥ï,ËØÅÊòé‰ªénÊù°Á∫øÊé®ÂØºÂà∞n+1Êù°Êõ≤Á∫øÂç≥ÂèØ„ÄÇÂõ†‰∏∫Á≠îÊ°àÂëàÂçïÂ≥∞Ôºå‰∏âÂàÜÊ±ÇËß£Âç≥ÂèØ„ÄÇ‰∫§‰∫Ü‰∏§Ê¨°,Á¨¨‰∏ÄÊ¨°eps =1e-7Ëé´ÂêçwaÊéâ,Á¨¨‰∫åÊ¨°eps=1e-9Â∞±AC‰∫Ü‰Ω†Êï¢‰ø° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+10;const double eps = 1e-9;int a[maxn],b[maxn],c[maxn],T,n;inline void read(int &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;double calc(double x)&#123; double ans = a[1]*x*x+b[1]*x+c[1]; for (int i = 2; i &lt;= n; i++) ans = max(ans,a[i]*x*x+b[i]*x+c[i]); return ans;&#125;int main(int argc, char *argv[])&#123; read(T); while(T--) &#123; read(n); for (int i = 1; i &lt;= n; i++) read(a[i]),read(b[i]),read(c[i]); double l = 0.0,r = 1000.0; while(r - l &gt; eps) &#123; double m1,m2; m1 = l+(r-l)/3; m2 = r-(r-l)/3; if (calc(m2)-calc(m1) &gt; eps) r = m2; else l = m1; &#125; //printf("%.4lf %.4lf\n",l,r); printf("%.4lf\n",calc(l)); &#125; return 0;&#125; ÁßØÂàÜÂØºÊï∞ÊäÄÂ∑ßËôΩÁÑ∂ÁßØÂàÜÂíåÂØºÊï∞ÁÆóÊòØÊàëÈ´òÊï∞ÈáåÊØîËæÉÊìÖÈïøÁöÑ‰∏úË•ø„ÄÇ‰ΩÜÊòØËøòÊòØË¶ÅÁêÜ‰∏Ä‰∏ãÁöÑÂêß„ÄÇ ÂØºÊï∞ÁöÑÂÆö‰πâÂú®ÂèØÂØºÂáΩÊï∞‰∏äÊüê‰∏ÄÁÇπÁöÑÁû¨Êó∂ÂèòÂåñÁéá. \lim_{\Delta x\rightarrow0} \frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}Âü∫Êú¨ÂàùÁ≠âÂáΩÊï∞ÂØºÊï∞Âç≥Ê±ÇÂØºÊ≥ïÂàô. f(x)=t,f'(x)=0\\\\ f(x)=x^n,f'(x)=nx^{n-1}\\\\ f(x)=sin(x),f'(x)=cos(x)\\\\ f(x)=cos(x),f'(x)=-sin(x)\\\\ f(x)=e^x,f'(x)=e^x\\\\ f(x)=lnx,f'(x)=\frac{1}{x}\\\\ f(x) = tan(x),f'(x)=\frac{1}{cos^2(x)} ‰πòÊ≥ïÂàô:Â¶ÇÊûú‰∏Ä‰∏™ÂáΩÊï∞f(x)=g(x)h(x),ÈÇ£‰πà\\\\ f'(x) = g'(x)h(x)+g(x)h'(x) ÂïÜÊ≥ïÂàôÔºöÂ¶ÇÊûú‰∏Ä‰∏™ÂáΩÊï∞f(x)=\frac{g(x)}{h(x)},ÈÇ£‰πà\\\\ f'(x)=\frac{g'(x)h(x)-g(x)h'(x)}{h^2(x)} ÈìæÂØºÊ≥ïÂàôÔºöÂ¶ÇÊûú‰∏Ä‰∏™ÂáΩÊï∞f(x)=g(h(x)),ÈÇ£‰πà\\\\ f'(x)=g'(h(x))¬∑h'(x)MathjaxÊâìÂæóÊàëÂ•ΩÁ¥Ø ÁßØÂàÜÁöÑÂÆö‰πâÈöæ‰ª•Ëß£Èáä.ÁßØÂàÜÊ±ÇÁöÑÊòØ‰∏Ä‰∏™ÂáΩÊï∞‰∏éxËΩ¥Âõ¥ÊàêÁöÑÈù¢ÁßØÂ§ßÂ∞è„ÄÇÂè™ÂèØÊÑè‰ºö‰∏çÂèØË®Ä‰º†„ÄÇÔºàÈÄÉ ËøôÂá†‰∏™ÁÆóÊúâÁî®ÁöÑÂêß„ÄÇ ‰πãÂâçÂÅöËøáÁöÑ‰∏ÄÁÇπ‰π†È¢ò Ë¥¥‰∏äÊù•ÁÆó‰∫Ü ÁßØÂàÜÂíåÂØºÊï∞ÁöÑÁªºÂêàËøêÁî®Ê±ÇÊõ≤ÂáΩÊï∞ÁöÑÈïøÂ∫¶(LA-3485ÊúâÁî®) Êúâ‰∏ÄÊõ≤Á∫øÊñπÁ®ã\space f(x),‰∏îx\in[a,b],‰ª§f'(x)‰∏∫f(x)ÁöÑÂØºÂáΩÊï∞,ÈÇ£‰πàËØ•Êõ≤Á∫øÂú®a,b‰∏äÁöÑÈïøÂ∫¶‰∏∫\\\\ \int_a^b\sqrt{1+[f'(x)]^2}dxLA-3485 Bridge‰º†ÈÄÅÈó®:LA-3485 È¢òÁõÆÂ§ßÊÑè:ÁªôÂá∫‰∏Ä‰∏™ÂºÄÂè£Âêë‰∏äÁöÑÊäõÁâ©Á∫øÁöÑÊõ≤Á∫øÈïøÂíåÂ∑¶Âè≥Âå∫Èó¥ÔºåÊ±ÇÂá∫ÊäõÁâ©Á∫øÈ°∂ÁÇπÁöÑÂÄºÔºàÊúÄÂ∞èÂÄºÔºâ„ÄÇ ‰∏çË°åËøôÈ¢ò‰∏ÄÂÆöË¶ÅÂè¶Â§ñÂÜô‰∏ÄÁØáMark‰∏Ä‰∏ã,Â§™ÈúáÊíº‰∫Ü. qwq]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-11542] Square]]></title>
    <url>%2F2018%2F02%2F12%2FUVa-11542-Square%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®UVa-11542È¢òÁõÆÂ§ßÊÑè:ÁªôÂá∫‰∏Ä‰∏™Êï¥Êï∞ÈõÜÂêà‰ªé‰∏≠ÊåëÂá∫Ëá≥Â∞ë‰∏Ä‰∏™‰ΩøÂæóÁßØ‰∏∫ÂÆåÂÖ®Âπ≥ÊñπÊï∞„ÄÇ Ê†∑‰æãSample Input432 3 536 10 1544 6 10 1532 2 2Sample Output0133 ÊÄùË∑ØÈ´òÊñØÊ∂àÂÖÉ+xorÁü©ÈòµÂÖàÂ§ÑÁêÜÂá∫ÂâçÈù¢500ÁöÑË¥®Êï∞ÂÜôÊàêm‰∏™ÂºÇÊàñÁöÑÊñπÁ®ã Ëá™‰∏äËÄå‰∏ãÊ±ÇËß£Âç≥ÂèØÂºÇÊàñÁöÑËØùÂèØ‰ª•Áî®bitset‰ºòÂåñ‰ΩÜÊòØÔºåÔºåÊàë‰∏ç‰ºöÁî®Âïä ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 510;const int maxp = 100;typedef int Matrix[maxn][maxn];bool is_prime[maxn];int prime[maxp],cnt=0;inline void read(int &amp;x)&#123; x=0;char ch=getchar();int f=1; while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;void Euler_Prime(int s)&#123; memset(is_prime,1,sizeof(is_prime)); is_prime[1] = 0; //1 ‰∏çÊòØË¥®Êï∞. for (int i = 2; i &lt;= s; i++) &#123; if (is_prime[i]) prime[cnt++] = i; for (int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= s; j++) &#123; is_prime[prime[j] * i] = 0; if (i % prime[j] == 0) break; &#125; &#125;&#125;Matrix A;int rank(Matrix A, int m, int n) &#123; int i = 0, j = 0, k, r, u; while(i &lt; m &amp;&amp; j &lt; n) &#123; r = i; for(k = i; k &lt; m; k++) if(A[k][j]) &#123; r = k; break; &#125; if(A[r][j]) &#123; if(r != i) for(k = 0; k &lt;= n; k++) swap(A[r][k], A[i][k]); for(u = i+1; u &lt; m; u++) if(A[u][j]) for(k = i; k &lt;= n; k++) A[u][k] ^= A[i][k]; i++; &#125; j++; &#125; return i;&#125;int main(int argc, char *argv[]) &#123; int T; cin &gt;&gt; T; while(T--) &#123; int n, maxp = 0; long long x; cin &gt;&gt; n; memset(A, 0, sizeof(A)); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; for(int j = 0; j &lt; cnt; j++) while(x % prime[j] == 0) &#123; maxp = max(maxp, j); x /= prime[j]; A[j][i] ^= 1; &#125; &#125; int r = rank(A, maxp+1, n); // Âè™Áî®Âà∞‰∫ÜÂâçmaxp+1‰∏™Á¥†Êï∞ cout &lt;&lt; (1LL &lt;&lt; (n-r))-1 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LA-3704] Cellular Automaton ÁªÜËÉûËá™Âä®Êú∫]]></title>
    <url>%2F2018%2F02%2F12%2FLA-3704-Cellular-Automaton-%E7%BB%86%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®:LA-3704 Ê†∑‰æãSample Input5 3 1 11 2 2 1 25 3 1 101 2 2 1 2Sample Output2 2 2 2 12 0 0 2 2 ÊÄùË∑ØÊó¢ÁÑ∂ËøôÈáåËÆ≤ÁöÑÊòØÁü©ÈòµÁöÑËøêÁÆó ÈÇ£‰πà‰∏ÄÂÆöÊòØË¶ÅÊûÑÈÄ†‰∏Ä‰∏™ÈÄíÊé®ÁöÑÂÖ≥Á≥ª‰ªéÈ¢òÈù¢‰∏äÂæàÈöæÂèëÁé∞Êúâ‰ªÄ‰πàËßÑÂæãÂèØË®Ä‰∫éÊòØÊàë‰ª¨Âä®ÊâãÁîªÁîªÂèëÁé∞ÊØèÊ¨°ÁöÑÂèòÂåñÈÉΩÊòØ‰∏äÊ¨°ÁöÑÊúâÂ∫èÊéíÂàóÊØîÂ¶ÇÊ†∑‰æã‰∏≠ÁöÑÁ¨¨‰∏ÄÁªÑËæìÂÖ•ËæìÂá∫[1 1 0 0 1] [1] = [2][1 1 1 0 0] [2] = [2][0 1 1 1 0] [2] = [2][0 0 1 1 1] [1] = [2][1 0 0 1 1] [2] = [1]ÂèëÁé∞‰∫Ü‰πàÔºåÂ∑¶ËæπÁöÑÁü©ÈòµÁöÑÊØè‰∏ã‰∏ÄË°åÈÉΩÊòØ‰∏ä‰∏ÄË°åÁöÑÂÖÉÁ¥†ÂêëÂè≥ÁßªÂä®‰∏ÄÊ†ºËøôÊ†∑ÁöÑÁü©Èòµ Âè™Ë¶Å‰øùÂ≠ò‰∏ÄË°å‰ø°ÊÅØÂç≥ÂèØÊàë‰ª¨Áß∞‰πã‰∏∫‚ÄùÂæ™ÁéØÁü©Èòµ‚Äù.‰∫éÊòØÂéüÊù•n^3logkÁöÑÁàÜÁÇ∏‰∫ã‰ª∂Âú®Ëøô‰∏™Âæ™ÁéØÁü©ÈòµÁöÑ‰ºòÂåñ‰∏ãÈôçÂà∞‰∫Ün^2logk. ‰ª£Á†Å1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std; #define INF 0x3f3f3f3f const long long N=505; typedef long long ll; typedef struct &#123; ll mat[N]; &#125;Mat; int n,d,m,k; Mat multi(Mat a,Mat b) &#123; Mat c; memset(c.mat, 0, sizeof(c.mat)); for (int i=1; i&lt;=n; i++) &#123; for (int j=1; j&lt;=n; j++) &#123; c.mat[i]+=a.mat[j]*b.mat[(i-j+n)%n+1]; c.mat[i]%=m; &#125; &#125; return c; &#125; Mat qui(Mat a,int b) &#123; Mat c; memset(c.mat, 0, sizeof(c.mat)); c.mat[1]=1; while (b) &#123; if (b&amp;1) &#123; c=multi(c, a); &#125; a=multi(a, a); b&gt;&gt;=1; &#125; return c; &#125; int main(int argc, char *argv[]) &#123; int f[N]; Mat A; while (cin&gt;&gt;n&gt;&gt;m&gt;&gt;d&gt;&gt;k) &#123; memset(f, 0, sizeof(f)); for (int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;f[i]); &#125; memset(A.mat, 0, sizeof(A.mat)); for (int i=1; i&lt;=1; i++) &#123; A.mat[i]=1; for (int j=1; j&lt;=d; j++) &#123; A.mat[(i-1+j)%n+1]=1; A.mat[(i-1-j+n)%n+1]=1; &#125; &#125; A=qui(A, k); ll res[N]; memset(res, 0, sizeof(res)); for (int i=1; i&lt;=n; i++) &#123; for (int j=1; j&lt;=n; j++) &#123; res[i]+=A.mat[(i-j+n)%n+1]*f[j]; res[i]%=m; &#125; &#125; for (int i=1; i&lt;n; i++) &#123; printf("%lld ",res[i]); &#125; printf("%lld\n",res[n]) ; &#125; return 0; &#125;]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-10870] Recurrences(Áü©ÈòµÊûÑÈÄ†‰∏éÂø´ÈÄüÂπÇ)]]></title>
    <url>%2F2018%2F02%2F12%2FUVa-10870-Recurrences-%E7%9F%A9%E9%98%B5%E6%9E%84%E9%80%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®:UVa-10870È¢òÁõÆÂ§ßÊÑè:ÁªôÂá∫F(n)ÁöÑÈÄíÊé®Âºè,Ê±ÇÂá∫F(n)%mÁöÑÂÄº„ÄÇ Consider recurrent functions of the following form:f(n) = a1f(n ‚àí 1) + a2f(n ‚àí 2) + a3f(n ‚àí 3) + . . . + adf(n ‚àí d), for n &gt; d,where a1, a2, . . . , ad are arbitrary constants.A famous example is the Fibonacci sequence, defined as: f(1) = 1, f(2) = 1, f(n) = f(n ‚àí 1) +f(n ‚àí 2). Here d = 2, a1 = 1, a2 = 1. Every such function is completely described by specifying d (which is called the order of recurrence),values of d coefficients: a1, a2, . . . , ad, and values of f(1), f(2), . . . , f(d). You‚Äôll be given these numbers,and two integers n and m. Your program‚Äôs job is to compute f(n) modulo m.InputInput file contains several test cases. Each test case begins with three integers: d, n, m, followed bytwo sets of d non-negative integers. The first set contains coefficients: a1, a2, . . . , ad. The second set gives values of f(1), f(2), . . . , f(d).You can assume that: 1 ‚â§ d ‚â§ 15, 1 ‚â§ n ‚â§ 2^31-1Ôºå1 ‚â§ m ‚â§ 46340. All numbers in the input will fit in signed 32-bit integer.Input is terminated by line containing three zeroes instead of d, n, m. Two consecutive test casesare separated by a blank line.OutputFor each test case, print the value of f(n)( mod m) on a separate line. It must be a non-negative integer,less than m. Ê†∑‰æãSample Input1 1 100212 10 1001 11 13 2147483647 1234512345678 0 123451 2 30 0 0Sample Output155423 ÊÄùË∑ØÂæàÊòéÊòæÊòØ‰∏Ä‰∏™ÊûÑÈÄ†Á±ªÁöÑÈóÆÈ¢òÔºåÊàë‰ª¨Â¶ÇÊûúËÉΩÂ§ü‰ªéf(n)ÈÄíÊé®Âà∞f(n+1)Â∞±ÂèØ‰ª•‰ΩøÁü©ÈòµÂø´ÈÄüÂπÇ‰∫ÜÊØîÂ¶ÇÂΩìd=5Êó∂,‰∏çÈöæÂÜôÂá∫ËøôÊ†∑ÁöÑÁü©Èòµ‰πòÊ≥ï \begin{bmatrix} a_1 &a_2&a_3&a_4&a_5\\\\ 1 & 0 &0 &0 &0 \\\\ 0& 1 &0&0&0\\\\ 0& 0& 1 &0 &0\\\\ 0&0 &0 & 1 &0 \end{bmatrix} * \begin{bmatrix} f(n)\\\\ f(n-1)\\\\ f(n-2)\\\\ f(n-3)\\\\ f(n-4)\\\\ \end{bmatrix} = \begin{bmatrix} f(n+1)\\\\ f(n)\\\\ f(n-1)\\\\ f(n-2)\\\\ f(n-3)\\\\ \end{bmatrix}ÂêåÁêÜd‰∏∫‰ªªÊÑèÂÄºÊó∂ÈÉΩÂèØ‰ª•ÂÜôÂá∫ËøôÊ†∑ÁöÑÁü©Èòµ‰πòÊ≥ï„ÄÇ ËøôÊ†∑Êàë‰ª¨Â∞±ÂèØ‰ª•ÂÆö‰πâ‰∏Ä‰∏™Â∏∏Êï∞Áü©ÈòµA,Âú®‰ªéf(n)ÈÄíÊé®Âà∞f(n+1)‰πò‰ª•AÂç≥ÂèØ,Êàë‰ª¨Â∑≤ÁªèÁü•ÈÅì‰∫Üf(1)Âà∞f(d)ÁöÑÂÄº ‰ªéf(d)Âà∞f(n)‰∏ÄÂÖ±Ë¶Å‰πò‰ª•A Ôºàn-dÔºâÊ¨° ‰∏Ä‰∏™Áü©ÈòµÂø´ÈÄüÂπÇÂç≥ÂèØÂÖ∂‰∏≠Âø´ÈÄüÂπÇÁöÑÂ§çÊùÇÂ∫¶‰∏∫logn,Áü©ÈòµÁöÑÂ§çÊùÇÂ∫¶‰∏∫d^3(Ê≤°Êúâ‰ºòÂåñÁöÑËØù) Âõ†Ê≠§Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ O(d^3log_2n)Ëøô‰æøÊòØÊ≠£Ëß£‰∫Ü„ÄÇqwq ‰ª£Á†Å1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL d,m,f[26];struct node&#123;LL a[16][16];&#125;;node multi(node x,node y)&#123; node t; memset(t.a,0,sizeof(t.a)); for(int i = 1; i &lt;= d; i++) &#123; for(int j = 1; j &lt;= d; j++) &#123; for(int k = 1; k &lt;= d; k++) t.a[i][j] = (t.a[i][j]+x.a[i][k]*y.a[k][j])%m; &#125; &#125; return t;&#125;LL find(LL n,node sa)&#123; node t; memset(t.a,0,sizeof(t.a)); for(int i=1; i&lt;=d; i++) t.a[i][i]=1; while(n) &#123; if(n&amp;1) t=multi(t,sa); sa=multi(sa,sa); n&gt;&gt;=1; &#125; LL ans=0; for(int i=1;i&lt;=d;i++) ans=(ans+t.a[1][i]*f[i])%m; return ans;&#125;int main(int argc, char *argv[])&#123; LL n; node sa; while(scanf("%lld%lld%lld",&amp;d,&amp;n,&amp;m) == 3 &amp;&amp;d) &#123; memset(sa.a,0,sizeof(sa.a)); for(int i=1; i&lt;=d; i++) scanf("%d",&amp;sa.a[1][i]); for(int i=d; i&gt;=1; i--) scanf("%d",&amp;f[i]); for(int i=2; i&lt;=d; i++) sa.a[i][i-1]=1; if(n&lt;=d) printf("%lld\n",f[d-n+1]%m); else printf("%lld\n",find(n-d,sa)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Áü©ÈòµÂíåÁ∫øÊÄßÊñπÁ®ãÁªÑÂ≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2018%2F02%2F10%2F%E7%9F%A9%E9%98%B5%E5%92%8C%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Áü©ÈòµÊñπÊ≥ïËøòÊòØË¶Å‰ºöÁöÑ Áü©ÈòµÁü©ÈòµÁöÑÂü∫Êú¨ËøêÁÆóÁü©ÈòµÂä†Ê≥ïÊúÄÁÆÄÂçï‰∫ÜÔºåÂ∞±ÊòØÂØπÂ∫îÊï∞ÁöÑÁõ∏Âä†.Â¶ÇÊûúÁî®i,jÊù•Ë°®Á§∫Ë°åÂíåÂàóÈÇ£‰πàÂ∞±Êúâ C_{(i,j)} = A_{(i,j)} + B_{(i,j)}ÂáèÊ≥ïÂêåÁêÜÔºå‰∏ç‰ΩúÂ§™Â§öÁöÑÈòêËø∞„ÄÇÂîØ‰∏ÄÈúÄË¶ÅÊ≥®ÊÑè‰∫ãÈ°πÔºåÂΩì‰∏§‰∏™Áü©ÈòµÁöÑË°åÂíåÂàó‰∏çÁõ∏Á≠âÁöÑÊó∂ÂÄôÔºåÊ±Ç‰ªñ‰ª¨ÁöÑÁü©ÈòµÂíåÊàñËÄÖÁü©ÈòµÂ∑ÆÊòØÊØ´Êó†ÊÑè‰πâÁöÑ„ÄÇÂè™Êúâr1=r2,s1=s2ÊâçÊúâÂä†ÂáèÊ≥ïÁöÑÂÆö‰πâ„ÄÇ Áü©Èòµ‰πòÊ≥ïÔºàÂàíÈáçÁÇπÔºâ Á®çÊòæÂ§çÊùÇÔºåÁü©Èòµ‰πòÊ≥ïÂøÖÈ°ªÂú®nË°åmÂàóÂíåmË°åpÂàóÁöÑ‰∏§‰∏™Áü©Èòµ‰∏≠ËøõË°åËøêÁÆóÔºåÂê¶Âàô‰∏ÄÊ†∑Ê≤°ÊúâÊÑè‰πâ„ÄÇ ÂæóÂà∞‰∏Ä‰∏™nË°åpÂàóÁöÑÁü©Èòµ„ÄÇ Êúâ‰ª•‰∏ãÁöÑÈÄíÊé®Âºè: C_{i,k} = \sum_{j=1}^nA_{i,j} *B_{j,k}ÂÖ∑‰ΩìÁªÜËäÇ Ê†πÊçÆËøô‰∏™ÈÄíÊé®ÂºèÔºåÊàë‰ª¨‰∏çÈöæÂæóÂà∞‰∏Ä‰∏™O(n^3)ÁöÑÁÆóÊ≥ï 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn = 510;const int mod = 1e9+7;struct Matrix&#123; int m[maxn][maxn]; int r, s;&#125;;int N,M,P;Matrix A,B,ans;signed main(signed argc, char *argv[])&#123; scanf("%lld %lld %lld",&amp;N,&amp;P,&amp;M); for (int i = 1; i &lt;= N; i++) for (int j = 1; j &lt;= P; j++) scanf("%lld",&amp;A.m[i][j]); system("pause"); for (int i = 1; i &lt;= P; i++) for (int j = 1; j &lt;= M; j++) scanf("%lld",&amp;B.m[i][j]); for (int i = 1; i &lt;= N; i++) for (int k = 1; k &lt;= P; k++) for (int j = 1; j &lt;= M; j++) &#123; ans.m[i][j] = (ans.m[i][j] + mod) % mod; ans.m[i][j] += (A.m[i][k]%mod)* (B.m[k][j]%mod); ans.m[i][j] = (ans.m[i][j] + mod) % mod; &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) printf("%lld ",(ans.m[i][j]%mod+mod)%mod); printf("\n"); &#125; return 0;&#125; Â∞ΩÁÆ°ËÅîËµõÁöÑË¶ÅÊ±ÇÂ∞±ÊòØO(n^3) ‰ΩÜÊòØËøòÂèØ‰ª•Êõ¥Âø´ ÂèØ‰ª•ËØïÊÉ≥ÔºåÂΩìA(i,j)Á≠â‰∫é0Êó∂,ÈÇ£Èáå‰∏ÄÊï¥ÂùóÁöÑÁªìÊûúÈÉΩÊòØ0Ôºå‰∏çÈúÄË¶ÅÁªßÁª≠ËøêÁÆó 123456789for (int i = 1; i &lt;= N; i++) for (int k = 1; k &lt;= P; k++) if (A.m[i][k]) for (int j = 1; j &lt;= M; j++) &#123; ans.m[i][j] = (ans.m[i][j] + mod) % mod; ans.m[i][j] += (A.m[i][k]%mod)* (B.m[k][j]%mod); ans.m[i][j] = (ans.m[i][j] + mod) % mod; &#125; ËøòÊúâÁ•û‰ªôÊìç‰ΩúÁöÑÂèØ‰ª•‰ºòÂåñÂà∞O(nm)ÁöÑÊìç‰Ωú Ë¥¥‰∏ã‰ª£Á†ÅÊÖ¢ÊÖ¢ÁêÜËß£Âï¶„ÄÇ È´òÊñØË¥πÈ©¨ Ê†ë‰∏äÂºÄËä± Êàë‰ª¨ ‰øØË∫´Ê¨£Ëµè. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;typedef long long i64;const int P=1e9+7;char rb[8000000],*rp=rb,ob[4000000],*op=ob;int _()&#123; int x=0,f=1; while(*rp&lt;48)*rp++=='-'?f=-1:0; while(*rp&gt;47)x=x*10+*rp++-48; return x*f;&#125;void pr(int x)&#123; x+=(x&gt;&gt;31&amp;P); int ss[15],sp=0; do ss[++sp]=x%10,x/=10;while(x); while(sp)*op++=ss[sp--]+48;&#125;int n,p,m;int a[507][507],b[507][507];i64 c[507][507];int main()&#123; fread(rb,1,sizeof(rb),stdin); n=_(),p=_(),m=_(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=p;++j)a[i][j]=_(); for(int i=1;i&lt;=p;++i) for(int j=1;j&lt;=m;++j)b[i][j]=_(); int m1=m; while(m1&amp;3)++m1; for(int i=1;i&lt;=n;++i)&#123; i64*z=c[i]; for(int k=1;k&lt;=p;++k)&#123; int x=a[i][k],*y=b[k]; for(int j=4;j&lt;=m1;j+=4)&#123; z[j-3]+=i64(x)*y[j-3]; z[j-2]+=i64(x)*y[j-2]; z[j-1]+=i64(x)*y[j-1]; z[j ]+=i64(x)*y[j ]; &#125; if(!(k&amp;7)) for(int j=1;j&lt;=m;++j)z[j]-=(z[j]&gt;&gt;30)*P; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; pr(c[i][j]%P); *op++=32; &#125; *op++=10; &#125; fwrite(ob,1,op-ob,stdout); return 0;&#125; È´òÊñØÊ∂àÂÖÉÊàë‰ª¨ÂÅáËÆæÊúâËøôÊ†∑‰∏Ä‰∏™nÈò∂ÁöÑÂèØÈÄÜÁü©ÈòµÔºå‰æãÂ¶Ç 2x+y-z =8(L_1)\\\\-3x-y+2z=-11(L_2)\\\\-2x+y+2z=-3(L_3)ËøôÊ†∑ÁöÑ‰∏Ä‰∏™‰∏âÂÖÉ‰∏ÄÊ¨°ÊñπÁ®ãÁªÑÂÜôÊàêÁü©ÈòµÁöÑÂΩ¢Âºè‰∏∫ \begin{bmatrix} 2 & 1 & -1 &| &8 \\\\ -3 & -1 & 2 & | & -11\\\\ -2 & 1 & 2 & | & -3 \end{bmatrix}Ëøô‰∏™Áü©ÈòµË¢´Áß∞‰ΩúÂ¢ûÂπøÁü©ÈòµÔºàAUGMENTED MATRIXÔºâ,ÊúÄÂêé‰∏ÄÂàó‰∫ãÂÆû‰∏ä‰∏çÊòØÁ≥ªÊï∞Áü©ÈòµËÄåÊòØÂ∏∏Êï∞„ÄÇ Ëøô‰∏™Áü©ÈòµÂèØ‰ª•ÁªèËøáËøôÊ†∑ÁöÑÂ§ÑÁêÜ„ÄÇ ÂØπ‰∫éÊØè‰∏ÄË°åË¶Å‰ΩøÂæóAii‚â†0‰∏îAji(j&gt;i)Âùá‰∏∫0,ÂÖ∑‰ΩìÊìç‰Ωú 1.Êù•Âà∞ÂΩìÂâçË°å ‰ª•‰∏äÊñπÁü©Èòµ‰∏∫‰æãÂ≠êÔºåÁé∞Âú®Ë¶ÅÂ§ÑÁêÜÁ¨¨‰∏ÄË°å„ÄÇÊàë‰ª¨ÂÖàÂæÄ‰∏ãÈù¢ÊâæÂà∞ÁªùÂØπÂÄºÊúÄÂ§ßÁöÑA(i,r),ËøôÈáåÊâæÂà∞ÊòØ-3,‰∫éÊòØ‰∫§Êç¢Á¨¨1Ë°åÂíåÁ¨¨2Ë°å.ÔºàÁü©ÈòµÂèòÊàêËøô‰∏™Ê†∑Â≠êÔºåÂ∞±ÊòØ‰∫§Êç¢‰∫Ü‰∏Ä‰∫å‰∏§Ë°åÔºâ \begin{bmatrix} -3 & -1 & 2 & | & -11\\\\ 2 & 1 & -1 &| &8 \\\\ -2 & 1 & 2 & | & -3 \end{bmatrix}ÂØπ‰∫éL1ÔºåL2 Â∞ÜL1 3 +L2 2Êù•Âä†ÂáèÊ∂àÂÖÉÔºåÂØπ‰∫éÁ¨¨‰∏âË°åÔºåÂíåÁ¨¨‰∫åË°å‰∏ÄÊ†∑ÔºåÁõ¥Êé•‰∏éÁé∞Âú®ÁöÑL1Êìç‰Ωú„ÄÇ Â∞ÜL2„ÄÅL3ÁöÑÈ¶ñÈ°πÊ∂àÊàê0ÂêéÁªßÁª≠Êìç‰ΩúÁ¨¨‰∫åË°å„ÄÇ \begin{bmatrix} -3 & -1 & 2 & | & -11\\\\ \space & \frac{1}{3} & \frac{1}{3} & | &\frac{2}{3} \\\\ \space & \frac{5}{3} & \frac{2}{3} & | &\frac{13}{3} \\\\ \end{bmatrix}‰ª•Ê≠§Á±ªÊé®ÊúÄÁªàÂæóÂà∞‰∏Ä‰∏™‰∏âËßíÁü©Èòµ„ÄÇ Â∑Æ‰∏çÂ§öÂ∞±ÈïøËøô‰∏™Ê†∑Â≠ê„ÄÇÔºàÊªëÁ®Ω \begin{bmatrix} -3 & -1 & 2 & | & -11\\\\ \space & \frac{5}{3} & \frac{2}{3} & | &\frac{13}{3} \\\\ \space & \space & \frac{1}{5} & | &-\frac{1}{5} \\\\ \end{bmatrix}ËøôÊ†∑ÂÖ∂ÂÆûÊúÄÂêé‰∏ÄÂàóÂ∑≤ÁªèÂëäËØâ‰∫ÜÊàë‰ª¨z=-1„ÄÇ Ëá™‰∏ãÂêë‰∏äËø≠‰ª£Âç≥ÂèØ„ÄÇ È´òÊñØÊ∂àÂÖÉ‰ª£Á†ÅÂ¶Ç‰∏ã„ÄÇ 1234567891011121314151617181920212223void Gauss_Eli()&#123; int num; for (int i=1;i&lt;n;i++)&#123; num=i; for (int j=i+1;j&lt;=n;j++) if (fabs(A[j][i])&gt;fabs(A[num][i])) num=j; for (int j=1;j&lt;=n;j++) swap(A[i][j],A[num][j]); swap(b[num],b[i]); for (int j=i+1;j&lt;=n;j++)&#123; if (fabs(A[j][i])&lt;=eps) continue; double t=A[j][i]/A[i][i]; for (int k=1;k&lt;=n;k++) A[j][k]-=A[i][k]*t; b[j]-=b[i]*t; &#125; &#125; for (int i=n;i&gt;=1;i--)&#123; ans[i]=b[i]/A[i][i]; for (int j=i;j&gt;=1;j--) b[j]-=A[j][i]*ans[i]; &#125;&#125; ÂØπ‰∫éÂºÇÊàñ^ÊñπÁ®ãÁªÑÂèØ‰ª•Áî®bitset‰ºòÂåñ.1234567891011121314151617181920bitset&lt;250&gt;A[250]; \\Â∏∏Êï∞È°πb[i]Ë¥¥Âú®A[i][n+1]‰∏≠.void Gauss_Eli()&#123; int num; for (int i=1;i&lt;=n;i++)&#123; if (A[i][i]==0)&#123; num=i; for (int j=i+1;j&lt;=n;j++) if (A[j][i]!=0)&#123;num=j;break;&#125; swap(A[num],A[i]); &#125; for (int j=i+1;j&lt;=n;j++) if (A[j][i]!=0) A[j]^=A[i]; &#125; for (int i=n;i&gt;=1;i--)&#123; ans[i]=A[i][n+1]; for (int j=i;j&gt;=1;j--) if (A[j][i]!=0) A[j][n+1]=A[j][n+1]^ans[i]; &#125;&#125; È¢òÁõÆ‰º†ÈÄÅÈó®: UVa-10870LA-3704UVa-11542POJ-1222]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-10791 Minimum Sum LCM]]]></title>
    <url>%2F2018%2F02%2F10%2FUVa-10791-Minimum-Sum-LCM%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®:UVa-10791È¢òÁõÆÂ§ßÊÑè:ÁªôÂá∫‰∏Ä‰∏™Êï∞N,Ë¶ÅÊ±ÇÂá∫Ëá≥Â∞ë‰∏§‰∏™Êï∞‰ª•‰∏äÁöÑÊ≠£Êï¥Êï∞,‰ΩøÂæó LCM(a_1,a_2, ...,a_k) = N Âπ∂Ê±ÇÂá∫Êª°Ë∂≥Êù°‰ª∂ÁöÑÊúÄÂ∞èÁöÑ{\sum_{i=1}^{k}a_i} Ê†∑‰æãSample Input121050Sample OutputCase 1: 7Case 2: 7Case 3: 6 ÊÄùË∑ØËøòÊòØÂ∫îÁî®ÂîØ‰∏ÄÂàÜËß£ÂÆöÁêÜ,‰∏çÈöæÂèëÁé∞„ÄÇÂØπ‰∫é‰ªª‰Ωï‰∏Ä‰∏™Ë¥®Êï∞ÊàñËÄÖÂØπ‰∫é‰∏Ä‰∏™Âè™ÊúâÂçïÂõ†Â≠êÔºàÈô§Âéª1ÂíåÂÆÉÊú¨Ë∫´ÔºâÁöÑÊï∞ÔºåÂÖ∂Êï∞ÂàóaÂè™ÂåÖÂê´1ÂíåÂÆÉÊú¨Ë∫´Ê≠§Êó∂Á≠îÊ°àÂ∞±‰∏∫n+1. ÂØπ‰∫é‰∏Ä‰∏™ÂêàÊï∞n,ÊÄªÊúâ N = \prod_{i=1}^{k}a_i^{p_i}‰∏çÈöæÂèëÁé∞,ÂΩìË¥®Âõ†Êï∞ÂàÜËß£Êó∂ÂêÑ‰∏™Ë¥®Âõ†Êï∞ÁöÑÂπÇ‰πãÈó¥ÁöÑgcdÂøÖÂÆö‰∏∫1ÔºåËøôÊ†∑ÁöÑÊçüËÄó‰ª£‰ª∑ÊòØÊúÄÂ∞èÁöÑ„ÄÇ ÊâÄ‰ª•Ê±ÇÂá∫ÂêÑ‰∏™aiÂíåpiÂ∞±ÂèØ‰ª•gg‰∫Ü„ÄÇ Ê≥®ÊÑèÁâπÂà§,Êï∞ÊçÆËåÉÂõ¥ÂÜÖÊòØint‰ΩÜÊòØÂæàÂèØËÉΩ‰ºöÂú®ËÆ°ÁÆóËøáÁ®ã‰∏≠Ê∫¢Âá∫„ÄÇ ÂºÄ‰∏™long longÊØîËæÉ‰øùÈô©„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;typedef long long LL; using namespace std;bool is_prime[56440]; //sqrt(2^31-1) Á∫¶Á≠â‰∫é 56340 LL prime[56440],pf[56400],cnt = 0,n;LL kase = 0;bool check(LL x)&#123; if (x == 1) return 0; if (x == 2) return 1; for (LL i = 2; i &lt;= sqrt(x+0.5); i++) if (x % i == 0) &#123; while(x % i == 0) x /= i; if (x == 1) return 1; else return 0; &#125; return 1;&#125;void Euler_Prime(LL x)&#123; memset(is_prime,1,sizeof(is_prime)); is_prime[1] = 0; for (LL i = 2; i &lt;= x; i++) &#123; if (is_prime[i]) prime[++cnt] = i; for (LL j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= x; j++) &#123; is_prime[i * prime[j]] = 0; if (i % prime[j] == 0) break; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; Euler_Prime(56439); while(scanf("%lld",&amp;n) == 1 &amp;&amp; n) &#123; LL ans = 0; memset(pf,0,sizeof(pf)); if (n == 1) &#123; printf("Case %lld: 2\n",++kase); continue; &#125; if (check(n)) &#123; printf("Case %lld: %lld\n",++kase,n+1); continue; &#125; for (LL i = 1; i &lt;= cnt; i++) &#123; if (n % prime[i] == 0) &#123; LL ret = 1; while(n % prime[i] == 0) n/=prime[i],ret *= prime[i]; ans += ret; &#125; if (n == 1) break; &#125; printf("Case %lld: %lld\n",++kase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa-10375] Choose and divide]]></title>
    <url>%2F2018%2F02%2F10%2FUVa-10375-Choose-and-divide%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®:UVa-10375È¢òÁõÆÂ§ßÊÑè:ÁªôÂá∫p,q,r,s,Ê±ÇÂá∫C(p,q)/C(r,s)ÁöÑÂÄº,ÂÖ∂‰∏≠p,q,r,s‚àà[1,10000]Ôºõ‰∏îp &gt;= q,r &gt;= s; Ê†∑‰æãSample Input10 5 14 993 45 84 59145 95 143 92995 487 996 4882000 1000 1999 9999998 4999 9996 4998Sample Output0.12587505606.460551.282230.489962.000003.99960 ÊÄùË∑ØÂÖàÈ¢ÑÂ§ÑÁêÜ1W‰ª•ÂÜÖÁöÑË¥®Êï∞ÈõÜÂêàprime[],ÁÑ∂ÂêéÂîØ‰∏ÄÂàÜËß£ÂÆöÁêÜ,Áî®pf[i]ËÆ∞ÂΩïÊØè‰∏™Ë¥®Êï∞Ë¶Å‰πòÊàñËÄÖÈô§ÁöÑ‰∏™Êï∞,ÊúÄÂêépow‰∏ÄÈÅçÂç≥ÂèØ. ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10001;int prime[maxn],cnt = 0,pf[maxn];bool is_prime[maxn];void Euler_Prime(int x)&#123; memset(is_prime,1,sizeof(is_prime)); is_prime[1] = 0; for (int i = 2; i &lt;= x; i++) &#123; if (is_prime[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i *prime[j] &lt;= x; j++) &#123; is_prime[i*prime[j]] = 0; if (i % prime[j] == 0) break; &#125; &#125;&#125;void work(int n,int d)&#123; for (int i = 1; i &lt;= cnt; i++) &#123; while(n % prime[i] == 0) &#123; n /= prime[i]; pf[i] += d; &#125; if (n == 1) break; &#125;&#125;void update(int n,int d)&#123; for (int q = 1; q &lt;= n; q++) work(q,d);&#125;int main(int argc, char *argv[])&#123; Euler_Prime(10000); int p,q,r,s; while(scanf("%d %d %d %d",&amp;p,&amp;q,&amp;r,&amp;s) == 4) &#123; double ans = 1.0; memset(pf,0,sizeof(pf)); update(p,1); update(q,-1);update(p-q,-1); update(r,-1);update(s,1); update(r-s,1); for (int i = 1; i &lt;= cnt; i++) ans *= pow(prime[i],pf[i]); printf("%.5lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa-11582-FibonacciÊï∞Âàóf(a^b)%nÁöÑÂÄº]]></title>
    <url>%2F2018%2F02%2F09%2FUVa-11582-Fibonacci%E6%95%B0%E5%88%97f-a-b-n%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®:UVa-11582È¢òÁõÆÂ§ßÊÑè:ÁªôÂá∫long longËåÉÂõ¥ÁöÑa,b,n,Ê±ÇÂá∫f(a^b) % nÁöÑÂÄº,ÂÖ∂‰∏≠f(x)‰∏∫FibonacciÊï∞ÂàóÁöÑÁ¨¨xÈ°π. Ê†∑‰æãSample Input31 1 22 3 100018446744073709551615 18446744073709551615 1000Sample Output121250 ÊÄùË∑Ø‰∏ÄÂºÄÂßãÁöÑÊÄùË∑ØÊòØÂà©Áî®FibonacciÁöÑÈÄöÈ°πÂÖ¨ÂºèÂä†‰∏ä‰∫åÈ°πÂºèÂÆöÁêÜÊù•Ê±ÇÂá∫a^b%nÁöÑÈ°π‰ΩÜÊòØÊó†Â•àÊé®ÂÖ¨ÂºèÊó∂Êé®ÈîôËÄå‰∏îÂèëÁé∞a^b%nÁöÑÂÄºÂíåf(a^b)%nÊØ´Êó†ÂÖ≥Á≥ª.ËÅîÊÉ≥Âà∞fibonacciÊï∞ÂàóÂØπ‰∏Ä‰∏™Êï∞nÂèñmod,ÂèØ‰ª•Áî±È∏ΩÂ∑¢ÂéüÁêÜËØÅÊòé, Âè™Ë¶ÅËøûÁª≠Âá∫Áé∞n^2‰∏™ÁöÑmodÂÄº,ÂøÖÁÑ∂‰ºöÂá∫Áé∞Âæ™ÁéØ‰∫éÊòØÂ∞±ËØûÁîü‰∫ÜÂÅöÊ≥ï.ÂÖàÊâæÂá∫ÊúÄÂ∞èÂæ™ÁéØËäÇÔºåÂú®Ëøô‰∏™Âæ™ÁéØËäÇ‰∏≠ÂØªÊâæf(a^b)ÁöÑ‰ΩçÁΩÆ. ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000 + 5;typedef unsigned long long ULL;int f[maxn][maxn*6], period[maxn];int pow_mod(ULL a, ULL b, int n) &#123; if(!b) return 1; int k = pow_mod(a, b/2, n); k = k * k % n; if(b % 2) k = k * a % n; return k;&#125;int solve(ULL a, ULL b, int n) &#123; if(a == 0 || n == 1) return 0; int p = pow_mod(a % period[n], b, period[n]); return f[n][p];&#125;int main(int argc,char *argv[]) &#123; ios::sync_with_stdio(false);//ÂèñÊ∂àcin‰∏éscanfÂêåÊ≠•Âä†Âø´ÈÄüÂ∫¶. for(int n = 2; n &lt;= 1000; n++) &#123; f[n][0] = 0; f[n][1] = 1; for(int i = 2; ; i++) &#123; f[n][i] = (f[n][i-1] + f[n][i-2]) % n; if(f[n][i-1] == 0 &amp;&amp; f[n][i] == 1) &#123; period[n] = i - 1; break; &#125; &#125; &#125; ULL a, b; int n, T; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n; cout &lt;&lt; solve(a, b, n) &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa - 11426] Extreme GCD (II) ‰∫åÁª¥gcdÊ±ÇÂíåÈóÆÈ¢ò]]></title>
    <url>%2F2018%2F02%2F09%2FUVa-11426-Extreme-GCD-II-%E4%BA%8C%E7%BB%B4gcd%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢‰º†ÈÄÅÈó®:UVa-11426Â§ßËá¥ÊÑèÊÄù:ËæìÂÖ•‰∏Ä‰∏™Ê≠£Êï¥Êï∞n,Ë¶ÅÊ±ÇÂú®Êó∂Èôê‰∏∫10secÂÜÖÊ±ÇÂá∫ \sum _ { i = 1 } ^ { N - 1 } \sum _ { j = i + 1 } ^ { N } GCD(i,j)‰øùËØÅÁ≠îÊ°àÂú®long longËåÉÂõ¥ÂÜÖ Ê†∑‰æãSample Input101002000000 Sample Output6713015143295493160 ÊÄùË∑ØÂºïÁêÜ:Â¶ÇÊûúË¶ÅÊª°Ë∂≥gcd(x,n)=i,ÂÖ∂ÂÖÖÂàÜÂøÖË¶ÅÊù°‰ª∂‰∏∫gcd(x/i,n/i) = 1. ÂèØ‰ª•ËÇØÂÆöÁöÑÊòØ,Â¶ÇÊûú‰∏Ä‰∏™‰∏Ä‰∏™Âú∞Êûö‰∏æi,j &lt;= n,Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫O(n^2)ÂøÖÁÑ∂‰ºöTÈ£ûÊàë‰ª¨ÂèØ‰ª•ËÆæ‰∏Ä‰∏™ËæÖÂä©ÂáΩÊï∞ f(n) = gcd(1,n) + gcd(2,n) + ‚Ä¶‚Ä¶ + gcd(n-1,n);ÈÇ£‰πàÁ≠îÊ°àS(n) = f(2) + f(3) + ‚Ä¶‚Ä¶ + f(n).ÂæóÂá∫ÈÄíÊé®ÂºèS(n) - S(n-1) = f(n).‚à¥ÈóÆÈ¢òËΩ¨Âåñ‰∏∫Âú®Á∫øÊÄßÊó∂Èó¥ÂÜÖÊ±ÇÂá∫f(n)ÁöÑÂ§ßÂ∞è.ÂèØ‰ª•ÂèëÁé∞,gcd(x,n) Âõ†‰∏∫ x &lt; n,ÊâÄ‰ª•gcd(x,n)‰∏ÄÂÆöÊòØnÁöÑÁ∫¶Êï∞Â¶ÇÊûúËÉΩÂ∞ÜËøô‰∫õÁ∫¶Êï∞ÂàÜÁ±ª,ÁªßÁª≠ÂàöÊâçÁöÑÂ•óË∑Ø,ÂÜçÂéªËÆæ‰∏Ä‰∏™ËæÖÂä©ÂáΩÊï∞g(n,i)Ë°®Á§∫gcd(x,n) = i ÁöÑxÁöÑ‰∏™Êï∞ÂèØ‰ª•ÂèëÁé∞,f(n)=sigma(i * g(n,i))ÂÖ∂‰∏≠‰øùËØÅiÊòØnÁöÑÂõ†Êï∞Áî±ÂºïÁêÜ,ÂèØÁü•ÈÅìÊª°Ë∂≥Êù°‰ª∂ÁöÑx/iÊúâphi(n/i)‰∏™‚à¥g(n,i) = phi(n,i). Ëá≥Ê≠§,Êàë‰ª¨Â∑≤ÁªèÂèØ‰ª•Âú®sqrt(n) * nÁöÑÊó∂Èó¥ÂÜÖËÆ°ÁÆóÂá∫f(n).‰∏äËø∞ÁÆóÊ≥ïÁöÑ‰ª£Á†ÅÂ¶Ç‰∏ã.1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int maxn = 4000010;LL phi[maxn],f[maxn],S[maxn];void phi_spawn(int x)&#123; memset(phi,0,sizeof(phi)); phi[1] = 1; for (int i = 2; i &lt;= x; i++) if (!phi[i]) &#123; for (int j = i; j &lt;= x; j+=i) &#123; if (!phi[j]) phi[j] = j; phi[j] = phi[j] * (i-1) / i; &#125; &#125;&#125;int calc(int x)&#123; int ret = 0; if (x == 1) return 1; for (int i = 2; i &lt;= sqrt(x+0.5); i++) if (x % i == 0) ret += i*phi[x/i]; return ret; &#125; int main(int argc, char *argv[])&#123; phi_spawn(maxn); memset(f,0,sizeof(f)); for (int i = 1; i &lt;= maxn; i++) f[i] = calc(i); S[2] = f[2]; for (int i = 3; i &lt;= maxn; i++) S[i] = S[i-1] + f[i]; int n; while(scanf("%d",&amp;n) == 1 &amp;&amp; n) printf("%lld\n",S[n]); return 0;&#125; ‰ΩÜÊòØÂú®400WÁöÑÊï∞ÊçÆ‰∏ãËøòÊòØTÈ£û‰∫Ü.ËøòÊòØËèúÂïä. ‰ΩÜÂ∞ΩÁÆ°Â¶ÇÊ≠§ËøòÊòØÊúâÂæàÂ§öÁöÑÈáçÂ§çËÆ°ÁÆóÔºå‰∏∫‰ªÄ‰πàÂë¢ÔºüÊàë‰ª¨Âú®Êûö‰∏æÂõ†Êï∞ÁöÑÊó∂ÂÄôÔºåÊúâÂæàÂ§öÊ¨°ÈáçÂ§çÔºå‰ΩÜÊòØÂ¶ÇÊûúÊûö‰∏æÂõ†Êï∞,ËÆ°ÁÆóÂÆÉÁöÑÂÄçÊï∞,ËøôÊ†∑Â∞±Âá†‰πéÊòØ‰∏Ä‰∏™Á≠õÊ≥ïÂºèÁöÑÊ±Çf[n],ÂØπ‰∫éÊØè‰∏™iÊûö‰∏æÂÄçÊï∞ÂéªÊõ¥Êñ∞f(n)ËøôÊ†∑ÁöÑÁÆóÊ≥ïÂ∞Ü‰ºö‰∏éÁ¥†Êï∞Á≠õÊ≥ïÁöÑÁÆóÊ≥ïÊó∂Èó¥Â§çÊùÇÂ∫¶ÂêåÈò∂. Ê≠£Ëß£‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int maxn = 4000010;LL phi[maxn],f[maxn],S[maxn];void phi_spawn(int x)&#123; memset(phi,0,sizeof(phi)); phi[1] = 1; for (int i = 2; i &lt;= x; i++) if (!phi[i]) &#123; for (int j = i; j &lt;= x; j+=i) &#123; if (!phi[j]) phi[j] = j; phi[j] = phi[j] * (i-1) / i; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; phi_spawn(maxn); memset(f,0,sizeof(f)); for (int i = 1; i &lt;= maxn; i++) for (int j = 2*i; j &lt;= maxn; j+=i) f[j] += i * phi[j/i]; S[2] = f[2]; for (int i = 3; i &lt;= maxn; i++) S[i] = S[i-1] + f[i]; int n; while(scanf("%d",&amp;n) == 1 &amp;&amp; n) printf("%lld\n",S[n]); return 0;&#125; edited by karriganasta ‚ù§ 20180209]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ëß£È¢òÊä•Âëä</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Êï∞ËÆ∫Âü∫Á°Ä]]></title>
    <url>%2F2018%2F02%2F08%2F%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[ÂÇªÈÄºÈÄâÊâãÊï∞ËÆ∫Â±Å‰πü‰∏ç‰ºö Âü∫Êú¨Ê¶ÇÂøµÂèä‰ª£Á†ÅË¥®Êï∞Ë¥®Êï∞‰πüÁß∞Á¥†Êï∞,Âç≥ÊÅ∞Â•ΩÂåÖÂê´‰∏§‰∏™‰∏çÂêåÂõ†Â≠êÁöÑÊï¥Êï∞.ÔºàÂ•ΩÊô∫ÈöúÂïäÔºâ1 ‰∏çÊòØË¥®Êï∞.Âà§Êñ≠Âçï‰∏™Êï∞ÊòØÂê¶‰∏∫Ë¥®Êï∞.Â¶Ç‰∏ã. 12345678bool is_prime(int x)&#123; if (x &lt;= 1) return 0; if (x == 2) return 1; for (int i = 2; i &lt;= sqrt(x+0.5); i++) //Áî®Sqrt(x+0.5)Èò≤Ê≠¢Á≤æÂ∫¶Â§±Áúü if (x % i == 0) return 0; return 1;&#125; ÊØèÊ¨°ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ O(sqrt(n)). ‰ΩÜÊòØÂØπ‰∫éÂæàN‰∏™Êï∞ÁöÑË¥®Êï∞Ë°®Âçï‰∏™Âà§Êñ≠Â∞±ÂæàÊó†Âäõ,Âõ†‰∏∫Âêå‰∏Ä‰∏™Êï∞ÁöÑÂõ†Êï∞‰ºöË¢´ÈáçÂ§çÂú∞Âà§Êñ≠ ÊØîÂ¶Ç4Ë¢´2Á≠õÂéª,‰ΩÜ6ËøòË¶ÅÂÜçÊ¨°Ë¢´Á≠õ‰∏ÄÈÅç. ÊâÄ‰ª•Â∞±ËØûÁîü‰∫ÜEulerÂ§ßÂ∏àÁöÑËÉΩ‰øùËØÅÊØè‰∏™Êï∞Âè™Ë¢´Á≠õÂà∞‰∏ÄÊ¨°ÁöÑÁ∫øÊÄßÁ≠õ,ËÉΩÂÅöÂà∞O(n). 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;const int Maxn = 1e7+10;bool is_prime[Maxn];int prime[Maxn],cnt = 0;void Euler_Prime(int s)&#123; memset(is_prime,1,sizeof(is_prime)); is_prime[1] = 0; //1 ‰∏çÊòØË¥®Êï∞. for (int i = 2; i &lt;= s; i++) &#123; if (!is_prime[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= s; j++) &#123; is_prime[prime[j] * i] = 0; if (i % prime[j] == 0) break;//Á°Æ‰øù‰∫ÜÊØè‰∏™ÂêàÊï∞Âè™Ë¢´‰ªñÊúÄÂ∞èÁöÑË¥®Âõ†Êï∞Á≠õÂéª.6Âïä &#125; &#125;&#125;int main(int argc, char *argv[])&#123; Euler_Prime(Maxn); int x; scanf("%d",&amp;x); printf("%d\n",is_prime[x]); return 0;&#125; EuclidÁÆóÊ≥ï.ÊúÄÁÆÄÂçïÁöÑÊòØÊ¨ßÊ∞èÁöÑËæóËΩ¨Áõ∏Èô§Ê±ÇÊúÄÂ§ßÂÖ¨Á∫¶Êï∞(gcd)ÁöÑÊñπÊ≥ï.1234int gcd(int x,int y)&#123; return (y == 0) ? x : gcd(y,x%y);&#125; ‰ºö‰∏ç‰ºöÁàÜÊ†àÂë¢?‰∏ç‰ºö,ÂèØ‰ª•ËØÅÊòé,gcdÁöÑÈÄíÂΩíÂ±ÇÊï∞‰∏çË∂ÖËøá4.785lgN + 1.6723(Á¥´‰π¶P311) ÂØπ‰∫é‰ªªÊÑèÁöÑx,y,Êúâlcm(x,y) gcd(x,y) = xy; ËØÅÊòéÁï•ËØ∑Ëá™Ë°åÁôæÂ∫¶ Extended EuclidÁÆóÊ≥ïÊâæÂá∫‰∏ÄÂØπÊï¥Êï∞x,yË¶ÅÊ±ÇËÉΩÂ§ü‰ΩøÂæóax+by = gcd(a,b) ‰∏î‰ΩøÂæó|x| +|y|Â∞ΩÂèØËÉΩÁöÑÂ∞è.123456void ex_gcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)&#123; if(!b)&#123;d = a;x = 1;y = 0;&#125; //Â¶ÇÊûúb = 0ÔºåÈÇ£‰πàÂ∞±ÊòØax = dÔºå‰ª§x = 1,y = 0Âç≥ÂèØ else &#123;ex_gcd(b,a%b,d,y,x) y-=x*(a/b);&#125; &#125; Ê¨ßÊãâphi œÜÂáΩÊï∞ÂÖ¨ÂºèÂ¶Ç‰∏ã \varphi (n) = n\prod_{i=1}^k(1-\frac{1}{p_i})Âçï‰∏™Ê¨ßÊãâÂáΩÊï∞ÂèØ‰ª•ËøôÊ†∑Ê±Ç:123456789101112int euler_phi(int n)&#123; int m = sqrt(n+0.5); int ans = 0; for (int i = 2; i &lt;= m; i++) if (n % i == 0) &#123; ans = ans * (i-1)/i; while(n % i == 0) n /= i; &#125; return ans;&#125; ‰ª•EulerÁöÑË¥®Êï∞Á≠õ ÂèØ‰ª•Á±ªÊØîÁÆóÂá∫Ê¨ßÊãâÂáΩÊï∞,Êó∂Èó¥Â§çÊùÇÂ∫¶‰πü‰∏∫O(n).123456789101112void phi_table(int n)&#123; for (int i = 2; i &lt;= n; i++) phi[i] = 0; phi[1] = 1; for (int i = 2; i &lt;= n; i++) if (!phi[i]) for(int j = i; j &lt;= n; j+=i) &#123; if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i-1); &#125;&#125; ‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜÔºàÂ≠ôÂ≠êÂÆöÁêÜÔºâÈóÆÈ¢òÔºö‰ªäÊúâÁâ©‰∏çÁü•ÂÖ∂Êï∞Ôºå‰∏â‰∏âÊï∞‰πãÂâ©‰∫åÔºå‰∫î‰∫îÊï∞‰πãÂâ©‰∏âÔºå‰∏É‰∏ÉÊï∞‰πãÂâ©‰∫å„ÄÇÈóÆÁâ©Âá†‰ΩïÔºü ËØ¥ÊòéÁôΩ‰∏ÄÁÇπÂ∞±ÊòØËØ¥ÔºåÂ≠òÂú®‰∏Ä‰∏™Êï∞xÔºåÈô§‰ª•3‰Ωô2ÔºåÈô§‰ª•5‰Ωô‰∏âÔºåÈô§‰ª•7‰Ωô‰∫åÔºåÁÑ∂ÂêéÊ±ÇËøô‰∏™Êï∞„ÄÇ‰∏äÈù¢ÁªôÂá∫‰∫ÜËß£Ê≥ï„ÄÇÂÜçÊòéÁôΩËøô‰∏™Ëß£Ê≥ïÁöÑÂéüÁêÜ‰πãÂâçÔºåÈúÄË¶ÅÂÖàÁü•ÈÅì‰∏Ä‰∏ã‰∏§‰∏™ÂÆöÁêÜ„ÄÇ ÂÆöÁêÜ1ÔºöÂá†‰∏™Êï∞Áõ∏Âä†ÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™Âä†Êï∞Ôºå‰∏çËÉΩË¢´Êï∞aÊï¥Èô§ÔºåÈÇ£‰πàÂÆÉ‰ª¨ÁöÑÂíåÔºåÂ∞±‰∏çËÉΩË¢´Êï¥Êï∞aÊï¥Èô§„ÄÇ ÂÆöÁêÜ2Ôºö‰∏§Êï∞‰∏çËÉΩÊï¥Èô§ÔºåËã•Èô§Êï∞Êâ©Â§ßÔºàÊàñÁº©Â∞èÔºâ‰∫ÜÂá†ÂÄçÔºåËÄåË¢´Èô§Êï∞‰∏çÂèòÔºåÂàôÂÖ∂ÂïÜÂíå‰ΩôÊï∞‰πüÂêåÊó∂Êâ©Â§ßÔºàÊàñÁº©Â∞èÔºâÁõ∏ÂêåÁöÑÂÄçÊï∞Ôºà‰ΩôÊï∞ÂøÖÂ∞è‰∫éÈô§Êï∞Ôºâ„ÄÇ Áé∞ÁªôÂá∫Ê±ÇËß£ËØ•ÈóÆÈ¢òÁöÑÂÖ∑‰ΩìÊ≠•È™§Ôºö 1„ÄÅÊ±ÇÂá∫ÊúÄÂ∞èÂÖ¨ÂÄçÊï∞ lcm=357=105 2„ÄÅÊ±ÇÂêÑ‰∏™Êï∞ÊâÄÂØπÂ∫îÁöÑÂü∫Á°ÄÊï∞ Ôºà1Ôºâ105√∑3=35 35√∑3=11‚Ä¶‚Ä¶2 //Âü∫Á°ÄÊï∞35 Ôºà2Ôºâ105√∑5=21 21√∑5=4‚Ä¶‚Ä¶1 ÂÆöÁêÜ2Êää1Êâ©Â§ß3ÂÄçÂæóÂà∞3ÔºåÈÇ£‰πàË¢´Èô§Êï∞‰πüÊâ©Â§ß3ÂÄçÔºåÂæóÂà∞21 * 3=63//Âü∫Á°ÄÊï∞63 3„ÄÅ105√∑7=15 15√∑7=2‚Ä¶‚Ä¶1 ÂÆöÁêÜ2Êää1Êâ©Â§ß2ÂÄçÂæóÂà∞2ÔºåÈÇ£‰πàË¢´Èô§Êï∞‰πüÊâ©Â§ß2ÂÄçÔºåÂæóÂà∞15 * 2=30//Âü∫Á°ÄÊï∞30 ÊääÂæóÂà∞ÁöÑÂü∫Á°ÄÊï∞Âä†ÂíåÔºàÊ≥®ÊÑèÔºöÂü∫Á°ÄÊï∞‰∏ç‰∏ÄÂÆöÂ∞±ÊòØÊ≠£Êï∞Ôºâ 35+63+30=128 4„ÄÅÂáèÂéªÊúÄÂ∞èÂÖ¨ÂÄçÊï∞lcmÔºàÂú®ÊØîÊúÄÂ∞èÂÖ¨ÂÄçÊï∞Â§ßÁöÑÊÉÖÂÜµ‰∏ãÔºâ x=128-105=23 ÈÇ£‰πàÊª°Ë∂≥È¢òÊÑèÂæóÊúÄÂ∞èÁöÑÊï∞Â∞±ÊòØ23‰∫Ü„ÄÇ‰∏ÄÂÖ±ÊúâÂõõ‰∏™Ê≠•È™§„ÄÇ‰∏ãÈù¢ËØ¶ÁªÜËß£ÈáäÊØè‰∏ÄÊ≠•ÁöÑÂéüÂõ†„ÄÇ Ôºà1ÔºâÊúÄÂ∞èÂÖ¨ÂÄçÊï∞Â∞±‰∏çÁî®Ëß£Èáä‰∫ÜÔºåË∑≥ËøáÔºàËÆ∞‰ΩèÔºåËøôÈáåËÆ®ËÆ∫ÁöÑÈÉΩÊòØ‰∏§‰∏§‰∫íË¥®ÁöÑÊÉÖÂÜµÔºâ Ôºà2ÔºâËßÇÂØüÊ±ÇÊØè‰∏™Êï∞ÂØπÂ∫îÁöÑÂü∫Á°ÄÊï∞Êó∂ÂÄôÁöÑÊ≠•È™§ÔºåÊØîÂ¶ÇÁ¨¨‰∏Ä‰∏™„ÄÇ105√∑3=35„ÄÇÊòæÁÑ∂Ëøô‰∏™35ÊòØÈô§‰∫ÜÂΩìÂâçËøô‰∏™Êï∞‰∏çËÉΩÊï¥Èô§‰ª•Â§ñÈÉΩËÉΩÂ§üË¢´ÂÖ∂‰ªñÊï∞Êï¥Èô§ÔºåÂ∞±ÊòØÂÖ∂‰ªñÊï∞ÁöÑÊúÄÂ∞èÂÖ¨ÂÄçÊï∞„ÄÇÁõ∏ÂΩì‰∫éÊâæÂà∞‰∫ÜÊúÄÂ∞èÁöÑÂºÄÂßãÂÄºÔºåÁî®ÂÆÉÂéªÈô§‰ª•3ÂèëÁé∞Ê≠£Â•Ω‰Ωô2„ÄÇÈÇ£‰πàËøô‰∏™Âü∫Á°ÄÊï∞Â∞±ÊòØ35„ÄÇËÆ∞‰Ωè35ÁöÑÁâπÂæÅÔºåÂèØ‰ª•Êï¥Èô§ÂÖ∂‰ªñÊï∞‰ΩÜÊòØ‰∏çËÉΩË¢´3Êï¥Èô§ÔºåÂπ∂‰∏î‰ΩôÊï∞ÊòØ2„ÄÇ‰ΩìÁé∞ÁöÑËøò‰∏çÂ§üÊòéÊòæÔºåÂÜçÁúã‰∏ã5ÂØπÂ∫îÁöÑÂü∫Á°ÄÊï∞„ÄÇ21ÊòØÂÖ∂‰ªñÊï∞ÁöÑÊúÄÂ∞èÂÖ¨ÂÄçÊï∞Ôºå‰ΩÜÊòØ‰∏çËÉΩË¢´5Êï¥Èô§ÔºåÁî®21Èô§‰ª•5ÂæóÂà∞ÁöÑ‰ΩôÊï∞ÊòØ1ÔºåËÄåË¶ÅÊ±ÇÁöÑÊï∞Èô§‰ª•5Â∫îËØ•ÊòØ‰Ωô1ÁöÑ„ÄÇÊâÄ‰ª•‰ΩôÊï∞Ë¢´Êâ©Â§ßÔºåÂ∞±ÂæóÂà∞‰∫ÜÁõ∏Â∫îÁöÑÂü∫Á°ÄÊï∞63„ÄÇËÆ∞‰ΩèËøô‰∏™Êï∞ÁöÑÁâπÂæÅÔºåÂèØ‰ª•Ë¢´ÂÖ∂‰ªñÊï∞Êï¥Èô§‰ΩÜÊòØË¢´5Èô§Â∫îËØ•‰Ωô‰∏â„ÄÇÂêåÁêÜÔºåÊàë‰ª¨ÂæóÂà∞‰∫ÜÁ¨¨‰∏â‰∏™Âü∫Á°ÄÊï∞23ÔºåÈÇ£‰πà‰ªñÁöÑÁâπÂæÅÂ∞±ÊòØÔºöÂèØ‰ª•Ë¢´ÂÖ∂‰ªñÊï∞Êï¥Èô§Ôºå‰ΩÜÊòØ‰∏çËÉΩË¢´7Êï¥Èô§ÔºåÂπ∂‰∏î‰ΩôÊï∞‰∏∫2„ÄÇ Ôºà3ÔºâÁ¨¨‰∏âÊ≠•Âü∫Á°ÄÊï∞Âä†ÂíåÔºå‰∏∫‰ªÄ‰πàË¶ÅËøôÊ†∑ÂÅöÂë¢ÔºüÂà©Áî®Â∞±ÊòØ‰∏äÈù¢ÊèêÂà∞ÁöÑÂÆöÁêÜ1„ÄÇ 35+63+30=128„ÄÇÂØπ‰∫é3Êù•ËØ¥ÔºåÂèØ‰ª•Êää63+30ÁöÑÂíåÁúã‰Ωú‰∏Ä‰∏™Êï¥‰ΩìÔºåÂ∫îËØ•‰ªñ‰ª¨ÈÉΩÂèØ‰ª•Ë¢´3Êï¥Èô§„ÄÇÁúãÁùÄ‰∏äÈù¢ÂÜôÂá∫ÁöÑ‰∏â‰∏™Êï∞ÁöÑÁâπÂæÅÔºåËøêÁî®ÂÆöÁêÜ1Êù•ËØ¥ÔºåÂ∞±ÊòØÂú®35ÁöÑÂü∫Á°Ä‰∏äÂä†‰∏ä‰∏Ä‰∏™ÂèØ‰ª•Ë¢´3Êï¥Èô§ÁöÑÂÄçÊï∞ÔºåÈÇ£‰πàÂæóÂà∞ÁöÑÁªìÊûú‰æùÁÑ∂ËøòÊòØÊª°Ë∂≥ÂéüÂÖàÁöÑÊÄßË¥®ÁöÑÔºåÂ∞±ÊòØ128Èô§‰ª•ÂêåÊ†∑ËøòÊòØ‰Ωô2ÁöÑ„ÄÇÂêåÁêÜÔºåÂØπ‰∫é5ËøòËØ¥ÔºåËøô‰∏™Êï∞Ë¢´Èô§‰πãÂêé‰ºöÂâ©‰Ωô3ÔºõÂØπ‰∫é7Êù•ËØ¥ÔºåË¢´Èô§‰πãÂêéÂâ©‰Ωô2„ÄÇÊâÄ‰ª•ËØ¥ÔºåÊàë‰ª¨ÂΩìÂâçÂæóÂà∞ÁöÑËøô‰∏™Êï∞ÊòØÊª°Ë∂≥È¢òÁõÆË¶ÅÊ±ÇÁöÑ‰∏Ä‰∏™Êï∞„ÄÇ‰ΩÜÊòØËøô‰∏™Êï∞ÊòØ‰∏çÊòØÊúÄÂ∞èÁöÑÔºåÈÇ£Â∞±‰∏ç‰∏ÄÂÆö‰∫Ü„ÄÇ Ôºà4ÔºâÂ∫îËØ•‰∏çËÉΩÁ°ÆÂÆöÊòØ‰∏çÊòØÊúÄÂ∞èÁöÑÊï∞ÔºåËøô‰∏™Êó∂ÂÄôÂ∞±Ë¶ÅÁî®Âà∞‰ªñ‰ª¨ÁöÑÊúÄÂ∞èÂÖ¨ÂÄçÊï∞‰∫Ü„ÄÇÊúÄÂ∞èÂÖ¨ÂÄçÊï∞È°æÂêçÊÄù‰πâÔºå‰∏ÄÂÆöÊòØ‰∏Ä‰∏™ÂêåÊó∂Ë¢´Âá†‰∏™Êï∞Êï¥Èô§ÁöÑÊúÄÂ∞èÁöÑ‰∏Ä‰∏™Êï∞ÔºåÊâÄ‰ª•ÂáèÂéªÂÆÉÂâ©‰Ωô‰∏ãÊù•ÁöÑ‰ΩôÊï∞ËøòÊòØÁ¨¶ÂêàÈ¢òÊÑèË¶ÅÊ±ÇÁöÑ„ÄÇÂΩìÁÑ∂‰πüÂêåÊ†∑ÂèØ‰ª•ËøêÁî®ÂÆöÁêÜ1Êù•Ëß£ÈáäÔºåÂè™‰∏çËøáÊòØÂä†Ê≥ïÂèòÊàê‰∫ÜÂáèÊ≥ïÔºåÈÅìÁêÜËøòÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇÂΩìÁÑ∂ÂÖ∑‰ΩìË¶Å‰∏çË¶ÅÂâ™ËøòÊòØË¶ÅÁúãÂíålcmÁöÑÂ§ßÂ∞èÂÖ≥Á≥ªÁöÑ„ÄÇ Á®çÂæÆÁöÑÊÄªÁªì‰∏Ä‰∏ãÔºöÂ∞±ÊòØÂ∑≤Áü•m1,m2,m3ÊòØ‰∏§‰∏§‰∫íË¥®ÁöÑÊ≠£Êï¥Êï∞ÔºåÊ±ÇÊúÄÂ∞èÁöÑÊ≠£Êï¥Êï∞xÔºå‰ΩøÂÆÉË¢´m1,m2,m3Èô§ÊâÄÂæóÁöÑ‰ΩôÊï∞ÂàÜÂà´ÊòØc1,c2,c3„ÄÇÂ≠ôÂ≠êÂÆöÁêÜÁöÑÊÄùÊÉ≥‰æøÊòØÁ∫øÂàÜÂà´Ê±ÇÂá∫Ë¢´ÂÖ∂‰∏≠Êï∞miÊï¥Èô§‰Ωô1ËÄåË¢´‰∏§Â§ñ‰∏§‰∏™Êï∞Êï¥Èô§ÁöÑÊï∞Mi(i=1,2,3)ÔºåÂàôÊâÄÊ±ÇÊï∞‰πã‰∏ÄÁöÑ‰æøÊòØc1M1+c2M2+c3M3„ÄÇÁî±Ê≠§Êàë‰ª¨ÂèØ‰ª•ÂæóÂà∞n‰∏™‰∏§‰∏§‰∫íË¥®Êï∞ÁöÑÊÉÖÂÜµ„ÄÇËØÅÊòé‰∏äÈù¢Â∑≤Áªè‰∏ÄÊ≠•‰∏ÄÊ≠•ÁªôÂá∫„ÄÇ ÈÇ£‰πàÔºåÂà∞Ê≠§‰∏∫Ê≠¢Âü∫Êú¨ÁöÑ‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜÁöÑÂÜÖÂÆπÊàë‰ª¨‰ª•Âèä‰∫ÜËß£‰∫ÜÔºåÂåÖÊã¨Ëß£Á≠îÊñπÊ≥ï„ÄÇÈÇ£‰πàÂ¶Ç‰ΩïÁºñÁ†ÅÂë¢ÔºüÊåâÁÖß‰∏äÈù¢Ëøô‰∏™ÊÄùË∑ØÂéªÁºñÁ†ÅÔºåÂÖ∂ÂÆûÂπ∂‰∏çÈöæ„ÄÇ‰∏ÄÂÖ±ÂàÜ‰∏∫ÂõõÂ§ßÊ≠•„ÄÇ‰ΩÜÊòØÔºåÂ§ßÂ§öÊï∞‰∫∫ÁöÑÂõ∞ÊÉëÂú®‰∫éÂ¶Ç‰ΩïÊ±ÇÂèñÂü∫Á°ÄÊï∞„ÄÇËøôÈáåÂë¢ÔºåÊèê‰æõ‰∏§ÁßçÊñπÊ≥ïÔºö Ôºà1ÔºâÁ¨¨‰∏ÄÁßçÂ∞±ÊòØ‰∏ÄÁõ¥ÈÄíÂ¢ûÔºåÁõ¥Âà∞ÊâæÂà∞„ÄÇ‰æãÂ¶ÇÔºö3ÁöÑÂü∫Á°ÄÊï∞Ôºå35ÊòØÂÖ∂‰ªñÊï∞ÁöÑÊúÄÂ∞èÂÖ¨ÂÄçÊï∞„ÄÇÈÇ£‰πàÂ∞±‰ªé35ÂºÄÂßãÔºå‰∏ÄÁõ¥Ëá™Â¢ûÔºåÁü•ÈÅì‰ΩôÊï∞‰∏∫2Ôºå‰æøÂÅúÊ≠¢ÔºàÂà©Áî®whileÂæ™ÁéØÔºâ„ÄÇ Ôºà2ÔºâÁ¨¨‰∫åÁßçÊñπÊ≥ïÂë¢Â∞±ÊòØËæóËΩ¨Áõ∏Èô§Ê≥ï‰∏äÂæóÊù•ÁöÑ„ÄÇËøôÈáåÁöÑ‰æãÂ≠ê‰ΩìÁé∞ÁöÑ‰∏çÂ§üÊòéÊòæÔºåÂ∫îÂΩìÁúãÁúãÂéªÊ±ÇÂèñ‰πòÊ≥ïÈÄÜÂÖÉÁöÑËøáÁ®ãÔºå‰∏ãÈù¢ËÆ≤ÁöÑÂÜÖÂÆπÂíå‰πòÊ≥ïÈÄÜÂÖÉÊúâÂæàÂ§ßÁöÑÂÖ≥Á≥ªÔºåÊâÄ‰ª•ËøòÊòØÁúãÁúãÁöÑÂ•Ω„ÄÇÁÆÄÂçï‰∏æ‰∏™‰æãÂ≠êÔºö ÂÅáËÆæÁé∞Âú®‰∏â‰∏™Êï∞ÂàÜÂà´ÊòØ14Ôºå3Ôºå5ÔºåÂÆÉ‰ª¨‰∏§‰∏§‰∫íË¥®Ôºå‰∏îË¶ÅÊ±ÇÁöÑÊï∞Èô§‰ª•5‰Ωô3„ÄÇÊ±Ç5ÂØπÂ∫îÁöÑÂü∫Á°ÄÊï∞„ÄÇÊúâÔºö 42√∑5=8‚Ä¶‚Ä¶2 5√∑2=2‚Ä¶‚Ä¶1 ÊâÄ‰ª•1=5 - 2 2=5 - 2 Ôºà42- 8 5 Ôºâ=-2 42+17 * 5 ÈÇ£‰πà-2 42=-84 17 5=85 -84+85=1 Êää1Êâ©Â§ß3ÂÄçÂèòÊàê3ÔºåÂàôÊúâ-84 * 3=-252‰πüÂ∞±ÊòØ5ÂØπÂ∫îÁöÑÂü∫Á°ÄÊï∞„ÄÇ Á¨¨‰∏ÄÁÇπÔºö Âü∫Á°ÄÊï∞ÂèØ‰ª•ÊòØË¥üÊï∞ÔºåËøô‰∏™‰πãÂâçÁÇπÂà∞Ëøá„ÄÇ//Âπ∂‰∏î‰∏ãÈù¢ÁöÑËß£Ê≥ïÂ∞±ÊòØÊúâËøôÊ†∑ÁöÑ„ÄÇ Á¨¨‰∫åÁÇπÔºö ÂΩìÂæóÂà∞‰ΩôÊï∞‰∏∫1ÁöÑÊó∂ÂÄôÂêéÈù¢ÁöÑÁÆóÂºèÁõ∏ÂΩì‰∫éÊòØ‰∏Ä‰∏™ÂõûÊ∫ØÁöÑËøáÁ®ãÔºåÊúÄÂêéËß£Âà∞-2 * 42„ÄÇ ‰ΩÜÊòØËøòÂè™‰∏çËøáÊòØ‰ΩôÊï∞ÊòØ1ÁöÑÊÉÖÂÜµÂØπÂ∫îÁöÑÊï∞ÔºåÂÜçËøêÁî®ÂÆöÁêÜ2Êàë‰ª¨Â∞±ÂæóÂà∞‰∫Ü-252Ëøô‰∏™Âü∫Á°ÄÊï∞„ÄÇÂÆûÈôÖ‰∏äË¶ÅÊòØÁúãËøá‰πòÊ≥ïÈÄÜÂÖÉÔºåËøôÈáåÂÆûÈôÖÂ∞±ÊòØ‰πòÊ≥ïÈÄÜÂÖÉÁöÑÊ±ÇËß£ËøáÁ®ãÔºåËÄå-2‰πüÂ∞±ÊòØ42ÂÖ≥‰∫é15ÂèñÊ®°ÁöÑ‰πòÊ≥ïÈÄÜÂÖÉ„ÄÇ 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt; #define ll long longusing namespace std;//Êâ©Â±ïÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ï void exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(!b)&#123;d=a;x=1,y=0;&#125; else &#123; exgcd(b,a%b,d,y,x); y-=(a/b)*x; &#125;&#125;//‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ ll China(int n,ll *m,ll *a)&#123; ll M=1,d,y,x=0; for(int i=0;i&lt;n;i++) M*=m[i]; for(int i=0;i&lt;n;i++) &#123; ll w=M/m[i]; gcd(m[i],w,d,d,y); x=(x+y*w*a[i])%M; &#125; return (x+M)%M;&#125;ll m[15],a[15];int main(int argc, char *argv[])&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%lld%lld",&amp;m[i],&amp;a[i]); printf("%lld",China(n,m,a));&#125; È¢òÁõÆ‰º†ÈÄÅÈó®UVa-11426UVa-11582UVa-10375UVa-10791 Last edited - 2018-02-08 karriganasta ‚ù§]]></content>
      <categories>
        <category>Êï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Â≠¶‰π†Á¨îËÆ∞</tag>
      </tags>
  </entry>
</search>
